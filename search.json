[{"title":"Kernel-compile","path":"/2024/12/05/kernel-explore/Kernel-compile/","content":"内核编译123456789101112131415161718192021222324252627282930#查看当前内核版本uname -a#源码获取sudo apt-get install linux-sourcecd /usr/srctar xvf linux-source-*.tar.bz2cd linux-source-*#补丁应用patch -p1 &lt; /path/to/patch.diff#`-p1`选项可能需要根据补丁文件的格式进行调整。make menuconfig #或者oldconfig,本质是配置/usr/src/configmake -j$(nproc)#根据 .config 配置文件编译内核、内核模块和其他必要的文件，生成内核镜像（vmlinuz）和其他相关的文件#编译过程中可能出现每包头文件或者其他错误，可能是版本原因，针对报错解决即可#内核安装#安装过程可能会出现头文件报错或者缺库、或安装完成后缺库，只需要apt安装对应的库就好，make过程中会自动hook#安装内核模块(在运行时可以加载或卸载的模块)#从编译输出的目录（如 lib/modules/&lt;kernel_version&gt;/）,并执行 depmod 来生成模块依赖关系sudo make modules_install#内核镜像（如 vmlinuz）、配置文件（如 config）、符号表文件（如 System.map）和 initrd 镜像安装到 /boot 目录sudo make install#更新启动引导程序sudo update-grup proxmox-boot-toolproxmox-boot-tool，一个脚本，设置启动内核、增删内核等 Proxmox VE（Proxmox Virtual Environment）是一个开源的虚拟化管理平台，专为企业级环境设计，能够管理虚拟机（VM）、容器、存储和集群。 其中 proxmox-boot-tool脚本在内核管理切换过程中比较有用，这里做备份，便于不整体下载Proxmox VE而单独使用此工具，仅供个人学习使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714#!/bin/shset -e. /usr/share/proxmox-kernel-helper/scripts/functions_add_entry_to_list_file() &#123; file=&quot;$1&quot; entry=&quot;$2&quot; if [ -e &quot;$file&quot; ]; then cp &quot;$file&quot; &quot;$file.new&quot; fi echo &quot;$entry&quot; &gt;&gt; &quot;$file.new&quot; sort -uo &quot;$file.new&quot; &quot;$file.new&quot; mv &quot;$file.new&quot; &quot;$file&quot;&#125;_remove_entry_from_list_file() &#123; file=&quot;$1&quot; entry=&quot;$2&quot; # guard against removing whole file by accident! if [ -z &quot;$entry&quot; ]; then echo &quot;cannot remove empty entry from &#x27;$file&#x27;.&quot; return fi if [ -e &quot;$file&quot; ]; then grep -vFx -- &quot;$entry&quot; &quot;$file&quot; &gt; &quot;$file.new&quot; || true mv &quot;$file.new&quot; &quot;$file&quot; else echo &quot;&#x27;$file&#x27; does not exist..&quot; fi&#125;_get_partition_info() &#123; if [ ! -e &quot;$1&quot; ]; then warn &quot;E: &#x27;$1&#x27; does not exist!&quot; exit 1 fi bdev=$(realpath &quot;$1&quot;) if [ ! -b &quot;$bdev&quot; ]; then warn &quot;E: &#x27;$bdev&#x27; is not a block device!&quot; exit 1 fi bdev_info=$( \\ lsblk \\ --bytes \\ --pairs \\ -o &#x27;UUID,SIZE,FSTYPE,PARTTYPE,PKNAME,MOUNTPOINT&#x27; \\ &quot;$bdev&quot; \\ ) if [ -z &quot;$bdev_info&quot; ]; then warn &quot;E: unable to get information about block device &#x27;$1&#x27;!&quot; exit 1 fi count=$(echo &quot;$bdev_info&quot; | grep -c &#x27;^&#x27;) if [ &quot;$count&quot; -ne &#x27;1&#x27; ]; then echo &quot;$bdev_info&quot; warn &quot;E: block device &#x27;$1&#x27; has children!&quot; exit 1 fi echo &quot;$bdev_info&quot; eval &quot;$bdev_info&quot; if [ -z &quot;$PKNAME&quot; ]; then warn &quot;E: cannot determine parent device of &#x27;$1&#x27; - please provide a partition, not a full disk.&quot; exit 1 fi if [ -n &quot;$SIZE&quot; ] &amp;&amp; [ &quot;$SIZE&quot; -lt 268435456 ]; then warn &quot;E: &#x27;$1&#x27; is too small (&lt;256M).&quot; exit 1 fi if [ -n &quot;$MOUNTPOINT&quot; ]; then warn &quot;E: &#x27;$1&#x27; is mounted on &#x27;$MOUNTPOINT&#x27; - exiting.&quot; exit 1 fi&#125;format() &#123; part=&quot;$1&quot; force=&quot;$2&quot; _get_partition_info &quot;$part&quot; if [ -n &quot;$FSTYPE&quot; ]; then if [ -z &quot;$force&quot; ] || [ &quot;$force&quot; != &#x27;--force&#x27; ]; then warn &quot;E: &#x27;$part&#x27; contains a filesystem (&#x27;$FSTYPE&#x27;) - exiting (use --force to override)&quot; exit 1 fi fi part_basename=$(basename &quot;$bdev&quot;) if [ -z &quot;$part_basename&quot; ]; then if [ &quot;$part&quot; != &quot;$bdev&quot; ]; then symlinkmsg=&quot; -&gt; &#x27;$bdev&#x27;&quot; fi warn &quot;E: unable to determine basename of &#x27;$part&#x27;$symlinkmsg&quot; exit 1 fi part_num=$(cat /sys/block/&quot;$PKNAME&quot;/&quot;$part_basename&quot;/partition) if [ -z &quot;$part_num&quot; ]; then warn &quot;E: unable to determine partition number of &#x27;$part&#x27;&quot; exit 1 fi if [ -z &quot;$PARTTYPE&quot; ] || [ &quot;$PARTTYPE&quot; != &quot;$ESPTYPE&quot; ]; then echo &quot;Setting partition type of &#x27;$part&#x27; to &#x27;$ESPTYPE&#x27;..&quot; sgdisk &quot;-t$part_num:$ESPTYPE&quot; &quot;/dev/$PKNAME&quot; echo &quot;Calling &#x27;udevadm settle&#x27;..&quot; udevadm settle --timeout=5 fi echo &quot;Formatting &#x27;$part&#x27; as vfat..&quot; mkfs.vfat -F 32 &quot;$part&quot; echo &quot;Done.&quot; exit 0&#125;init_bootloader() &#123; part=&quot;$1&quot; mode=&quot;$2&quot; _get_partition_info &quot;$part&quot; if [ -z &quot;$PARTTYPE&quot; ] || [ &quot;$PARTTYPE&quot; != &quot;$ESPTYPE&quot; ]; then warn &quot;E: &#x27;$part&#x27; has wrong partition type (!= $ESPTYPE).&quot; exit 1 fi if [ -z &quot;$FSTYPE&quot; ] || [ &quot;$FSTYPE&quot; != &#x27;vfat&#x27; ]; then warn &quot;E: &#x27;$part&#x27; has wrong filesystem (!= vfat).&quot; exit 1 fi if [ -z &quot;$UUID&quot; ]; then warn &quot;E: &#x27;$part&#x27; has no UUID set, required for mounting.&quot; exit 1 fi esp_mp=&quot;/var/tmp/espmounts/$UUID&quot; mkdir -p &quot;$esp_mp&quot; echo &quot;Mounting &#x27;$part&#x27; on &#x27;$esp_mp&#x27;.&quot; mount -t vfat &quot;$part&quot; &quot;$esp_mp&quot; if [ -z &quot;$mode&quot; ]; then if [ -e &quot;$esp_mp/EFI/proxmox/grubx64.efi&quot; ]; then # for reinit support mode=grub fi fi if [ -d /sys/firmware/efi ]; then if [ -n &quot;$mode&quot; ] &amp;&amp; [ &quot;$mode&quot; = &quot;grub&quot; ]; then echo &quot;Installing grub x86_64 target..&quot; grub-install.real \\ --boot-directory &quot;$&#123;esp_mp&#125;&quot; \\ --target x86_64-efi \\ --no-floppy \\ --efi-directory &quot;$&#123;esp_mp&#125;&quot; \\ --bootloader-id &#x27;proxmox&#x27; \\ &quot;/dev/$PKNAME&quot; echo &quot;Installing grub x86_64 target (removable)..&quot; grub-install.real \\ --boot-directory &quot;$&#123;esp_mp&#125;&quot; \\ --target x86_64-efi \\ --no-floppy \\ --efi-directory &quot;$&#123;esp_mp&#125;&quot; \\ --removable \\ --bootloader-id &#x27;proxmox&#x27; \\ &quot;/dev/$PKNAME&quot; else echo &quot;Installing systemd-boot..&quot; mkdir -p &quot;$esp_mp/$PMX_ESP_DIR&quot; if ! command -V bootctl &gt;/dev/null 2&gt;&amp;1 ; then warn &quot;E: bootctl is not available - make sure systemd-boot is installed&quot; exit 1 fi bootctl --graceful --path &quot;$esp_mp&quot; install echo &quot;Configuring systemd-boot..&quot; echo &quot;timeout 3&quot; &gt; &quot;$esp_mp/$PMX_LOADER_CONF.tmp&quot; echo &quot;default proxmox-*&quot; &gt;&gt; &quot;$esp_mp/$PMX_LOADER_CONF.tmp&quot; mv &quot;$esp_mp/$PMX_LOADER_CONF.tmp&quot; &quot;$esp_mp/$PMX_LOADER_CONF&quot; fi else echo &quot;Installing grub i386-pc target..&quot; grub-install.real \\ --boot-directory &quot;$esp_mp&quot; \\ --target i386-pc \\ --no-floppy \\ --bootloader-id=&#x27;proxmox&#x27; \\ &quot;/dev/$PKNAME&quot; fi echo &quot;Unmounting &#x27;$part&#x27;.&quot; umount &quot;$part&quot; echo &quot;Adding &#x27;$part&#x27; to list of synced ESPs..&quot; _add_entry_to_list_file &quot;$ESP_LIST&quot; &quot;$UUID&quot;&#125;reinit() &#123; if ! (echo &quot;$&#123;curr_uuid&#125;&quot; | grep -qE &#x27;[0-9a-fA-F]&#123;4&#125;-[0-9a-fA-F]&#123;4&#125;&#x27;); then warn &quot;WARN: $&#123;curr_uuid&#125; read from $&#123;ESP_LIST&#125; does not look like a VFAT-UUID - skipping&quot; return fi path=&quot;/dev/disk/by-uuid/$curr_uuid&quot; if [ ! -e &quot;$&#123;path&#125;&quot; ]; then warn &quot;WARN: $&#123;path&#125; does not exist - clean &#x27;$&#123;ESP_LIST&#125;&#x27;! - skipping&quot; return fi init_bootloader &quot;$path&quot; &quot;$mode&quot;&#125;_clean_impl() &#123; if [ ! -e &quot;/dev/disk/by-uuid/&quot; ]; then warn &#x27;E: /dev/disk/by-uuid does not exist, aborting!&#x27; exit 1 fi printf &quot;Checking whether ESP &#x27;%s&#x27; exists.. &quot; &quot;$curr_uuid&quot; # avoid newline if [ -e &quot;/dev/disk/by-uuid/$curr_uuid&quot; ]; then echo &quot;Found!&quot; else echo &quot;Not found!&quot; if [ -z &quot;$dry_run&quot; ] || [ &quot;$dry_run&quot; != &#x27;--dry-run&#x27; ]; then _remove_entry_from_list_file &quot;$ESP_LIST&quot; &quot;$curr_uuid&quot; fi fi&#125;clean() &#123; dry_run=&quot;$1&quot; rm -f &quot;$ESP_LIST&quot;.tmp loop_esp_list _clean_impl if [ &quot;$?&quot; -eq 2 ]; then warn &quot;E: $ESP_LIST does not exist.&quot; exit 1 fi if [ -e &quot;$ESP_LIST&quot;.tmp ]; then mv &quot;$ESP_LIST&quot;.tmp &quot;$ESP_LIST&quot; fi echo &quot;Sorting and removing duplicate ESPs..&quot; sort -uo &quot;$ESP_LIST&quot;.tmp &quot;$ESP_LIST&quot; mv &quot;$ESP_LIST&quot;.tmp &quot;$ESP_LIST&quot;&#125;refresh() &#123; hook=$1 hookscripts=&#x27;proxmox-auto-removal zz-proxmox-boot&#x27; if [ -n &quot;$hook&quot; ]; then if echo &quot;$hookscripts&quot; | grep -sqE &quot;(^|[[:space:]]+)$hook([[:space:]]+|$)&quot;; then hookscripts=&quot;$hook&quot; else warn &quot;E: &#x27;$hook&#x27; is not a valid hook script name.&quot;; exit 1; fi fi for script in $hookscripts; do scriptpath=&quot;/etc/kernel/postinst.d/$script&quot; if [ -f &quot;$scriptpath&quot; ] &amp;&amp; [ -x &quot;$scriptpath&quot; ]; then echo &quot;Running hook script &#x27;$script&#x27;..&quot; $scriptpath else warn &quot;Hook script &#x27;$script&#x27; not found or not executable, skipping.&quot; fi done&#125;add_kernel() &#123; ver=&quot;$1&quot; if [ -z &quot;$ver&quot; ]; then warn &quot;E: &lt;kernel-version&gt; is mandatory&quot; warn &quot;&quot; exit 1 fi if [ ! -e &quot;/boot/vmlinuz-$ver&quot; ]; then warn &quot;E: no kernel image found in /boot for &#x27;$ver&#x27;, not adding.&quot; exit 1 fi _add_entry_to_list_file &quot;$MANUAL_KERNEL_LIST&quot; &quot;$ver&quot; echo &quot;Added kernel &#x27;$ver&#x27; to manual kernel list. Use the &#x27;refresh&#x27; command to update the ESPs.&quot;&#125;remove_kernel() &#123; ver=&quot;$1&quot; if [ -z &quot;$ver&quot; ]; then warn &quot;E: &lt;kernel-version&gt; is mandatory&quot; warn &quot;&quot; exit 1 fi if grep -sqFx -- &quot;$ver&quot; &quot;$MANUAL_KERNEL_LIST&quot;; then _remove_entry_from_list_file &quot;$MANUAL_KERNEL_LIST&quot; &quot;$ver&quot; echo &quot;Removed kernel &#x27;$ver&#x27; from manual kernel list. Use the &#x27;refresh&#x27; command to update the ESPs.&quot; else echo &quot;Kernel &#x27;$ver&#x27; not found in manual kernel list.&quot; fi&#125;list_kernels() &#123; boot_kernels=&quot;$(boot_kernel_list)&quot; if [ -e &quot;$MANUAL_KERNEL_LIST&quot; ]; then manual_kernels=&quot;$(cat &quot;$MANUAL_KERNEL_LIST&quot; || true)&quot; boot_kernels=&quot;$(echo &quot;$boot_kernels&quot; | grep -Fxv -f &quot;$MANUAL_KERNEL_LIST&quot; || true)&quot; fi if [ -z &quot;$manual_kernels&quot; ]; then manual_kernels=&quot;None.&quot; fi echo &quot;Manually selected kernels:&quot; echo &quot;$manual_kernels&quot; echo &quot;&quot; echo &quot;Automatically selected kernels:&quot; echo &quot;$boot_kernels&quot; pinned_kernel=&quot;$(get_first_line &quot;$PINNED_KERNEL_CONF&quot;)&quot; nextboot_kernel=&quot;$(get_first_line &quot;$NEXT_BOOT_PIN&quot;)&quot; if [ -n &quot;$pinned_kernel&quot; ]; then echo &quot;&quot; echo &quot;Pinned kernel:&quot; echo &quot;$&#123;pinned_kernel&#125;&quot; fi if [ -n &quot;$nextboot_kernel&quot; ]; then echo &quot;&quot; echo &quot;Kernel pinned on next-boot:&quot; echo &quot;$&#123;nextboot_kernel&#125;&quot; fi&#125;usage() &#123; subcmd=&quot;$1&quot; if [ -z &quot;$subcmd&quot; ]; then warn &quot;USAGE: $0 &lt;commands&gt; [ARGS]&quot; warn &quot;&quot; fi if [ -z &quot;$subcmd&quot; ] || [ &quot;$subcmd&quot; = &quot;format&quot; ]; then warn &quot; $0 format &lt;partition&gt; [--force]&quot; fi if [ -z &quot;$subcmd&quot; ] || [ &quot;$subcmd&quot; = &quot;init&quot; ]; then warn &quot; $0 init &lt;partition&gt; [grub]&quot; fi if [ -z &quot;$subcmd&quot; ] || [ &quot;$subcmd&quot; = &quot;reinit&quot; ]; then warn &quot; $0 reinit&quot; fi if [ -z &quot;$subcmd&quot; ] || [ &quot;$subcmd&quot; = &quot;clean&quot; ]; then warn &quot; $0 clean [--dry-run]&quot; fi if [ -z &quot;$subcmd&quot; ] || [ &quot;$subcmd&quot; = &quot;refresh&quot; ]; then warn &quot; $0 refresh [--hook &lt;name&gt;]&quot; fi if [ -z &quot;$subcmd&quot; ] || [ &quot;$subcmd&quot; = &quot;kernel&quot; ]; then warn &quot; $0 kernel &lt;add|remove&gt; &lt;kernel-version&gt;&quot; warn &quot; $0 kernel pin &lt;kernel-version&gt; [--next-boot]&quot; warn &quot; $0 kernel unpin [--next-boot]&quot; warn &quot; $0 kernel list&quot; fi if [ -z &quot;$subcmd&quot; ] || [ &quot;$subcmd&quot; = &quot;status&quot; ]; then warn &quot; $0 status [--quiet]&quot; fi if [ -z &quot;$subcmd&quot; ] || [ &quot;$subcmd&quot; = &quot;help&quot; ]; then warn &quot; $0 help&quot; fi&#125;help() &#123; echo &quot;USAGE: $0 format &lt;partition&gt; [--force]&quot; echo &quot;&quot; echo &quot; format &lt;partition&gt; as EFI system partition. Use --force to format even if &lt;partition&gt; is currently in use.&quot; echo &quot;&quot; echo &quot;USAGE: $0 init &lt;partition&gt;&quot; echo &quot;&quot; echo &quot; initialize EFI system partition at &lt;partition&gt; for automatic synchronization of Proxmox kernels and their associated initrds.&quot; echo &quot;&quot; echo &quot;USAGE: $0 reinit&quot; echo &quot;&quot; echo &quot; reinitialize all configured EFI system partitions from $ESP_LIST.&quot; echo &quot;&quot; echo &quot;USAGE: $0 clean [--dry-run]&quot; echo &quot;&quot; echo &quot; remove no longer existing EFI system partition UUIDs from $ESP_LIST. Use --dry-run to only print outdated entries instead of removing them.&quot; echo &quot;&quot; echo &quot;USAGE: $0 refresh [--hook &lt;name&gt;]&quot; echo &quot;&quot; echo &quot; refresh all configured EFI system partitions. Use --hook to only run the specified hook, omit to run all.&quot; echo &quot;&quot; echo &quot;USAGE: $0 kernel &lt;add|remove&gt; &lt;kernel-version&gt;&quot; echo &quot;&quot; echo &quot; add/remove proxmox-kernel with ABI &lt;kernel-version&gt; to list of synced kernels, in addition to automatically selected ones.&quot; echo &quot; NOTE: you need to manually run &#x27;refresh&#x27; once you&#x27;re finished with adding/removing kernels from the list&quot; echo &quot;&quot; echo &quot;USAGE: $0 kernel pin &lt;kernel-version&gt; [--next-boot]&quot; echo &quot;&quot; echo &quot; pin proxmox-kernel with ABI &lt;kernel-version&gt; as the default entry to be booted.&quot; echo &quot; with --next-boot sets &lt;kernel-version&gt; only for the next boot.&quot; echo &quot; NOTE: you need to manually run &#x27;refresh&#x27; once you&#x27;re finished with pinning kernels&quot; echo &quot;&quot; echo &quot;USAGE: $0 kernel unpin [--next-boot]&quot; echo &quot;&quot; echo &quot; unpin removes pinned and next-boot kernel settings.&quot; echo &quot; with --next-boot only removes the pin for the next boot.&quot; echo &quot;&quot; echo &quot;USAGE: $0 kernel list&quot; echo &quot;&quot; echo &quot; list kernel versions currently selected for inclusion on ESPs.&quot; echo &quot;&quot; echo &quot;USAGE: $0 status [--quiet]&quot; echo &quot;&quot; echo &quot; Print details about the ESPs configuration. Exits with 0 if any ESP is configured, else with 2.&quot; echo &quot;&quot;&#125;_status_detail() &#123; if ! (echo &quot;$&#123;curr_uuid&#125;&quot; | grep -qE &#x27;[0-9a-fA-F]&#123;4&#125;-[0-9a-fA-F]&#123;4&#125;&#x27;); then warn &quot;WARN: $&#123;curr_uuid&#125; read from $&#123;ESP_LIST&#125; does not look like a VFAT-UUID - skipping&quot; return fi path=&quot;/dev/disk/by-uuid/$curr_uuid&quot; if [ ! -e &quot;$&#123;path&#125;&quot; ]; then warn &quot;WARN: $&#123;path&#125; does not exist - clean &#x27;$&#123;ESP_LIST&#125;&#x27;! - skipping&quot; return fi mountpoint=&quot;$&#123;MOUNTROOT&#125;/$&#123;curr_uuid&#125;&quot; mkdir -p &quot;$&#123;mountpoint&#125;&quot; || \\ &#123; warn &quot;creation of mountpoint $&#123;mountpoint&#125; failed - skipping&quot;; return; &#125; mount &quot;$&#123;path&#125;&quot; &quot;$&#123;mountpoint&#125;&quot; || \\ &#123; warn &quot;mount of $&#123;path&#125; failed - skipping&quot;; return; &#125; result=&quot;&quot; if [ -f &quot;$&#123;mountpoint&#125;/$PMX_LOADER_CONF&quot; ]; then if [ ! -d &quot;$&#123;mountpoint&#125;/$PMX_ESP_DIR&quot; ]; then warn &quot;$&#123;path&#125;/$PMX_ESP_DIR does not exist&quot; fi versions_uefi=$(ls -1 $&#123;mountpoint&#125;/$PMX_ESP_DIR | awk &#x27;&#123;printf (NR&gt;1?&quot;, &quot;:&quot;&quot;) $0&#125;&#x27;) result=&quot;uefi (versions: $&#123;versions_uefi&#125;)&quot; fi if [ -d &quot;$&#123;mountpoint&#125;/grub&quot; ]; then versions_grub=$(ls -1 $&#123;mountpoint&#125;/vmlinuz-* | awk &#x27;&#123; gsub(/.*\\/vmlinuz-/, &quot;&quot;); printf (NR&gt;1?&quot;, &quot;:&quot;&quot;) $0 &#125;&#x27;) if [ -n &quot;$result&quot; ]; then result=&quot;$&#123;result&#125;, grub (versions: $&#123;versions_grub&#125;)&quot; else result=&quot;grub (versions: $&#123;versions_grub&#125;)&quot; fi fi echo &quot;$curr_uuid is configured with: $result&quot; umount &quot;$&#123;mountpoint&#125;&quot; || \\ &#123; warn &quot;umount of $&#123;path&#125; failed - failure&quot;; exit 0; &#125; rmdir &quot;$&#123;mountpoint&#125;&quot; || true&#125;status() &#123; quiet=&quot;$1&quot; if [ ! -e &quot;$&#123;ESP_LIST&#125;&quot; ]; then if [ -z &quot;$quiet&quot; ]; then warn &quot;E: $ESP_LIST does not exist.&quot; fi exit 2 fi if [ -z &quot;$quiet&quot; ]; then if [ -d /sys/firmware/efi ]; then echo &quot;System currently booted with uefi&quot; else echo &quot;System currently booted with legacy bios&quot; fi loop_esp_list _status_detail fi&#125;_ask_interactive_refresh() &#123; msg=&quot;$1&quot; if [ -t 0 ] &amp;&amp; [ -t 1 ]; then # check if interactive echo &quot;$msg.&quot; printf &quot;Refresh the actual boot ESPs now? [yN] &quot; read -r do_refresh if [ &quot;$do_refresh&quot; != &quot;$&#123;do_refresh#[Yy]&#125;&quot; ] ;then refresh else echo &quot;Skip auto-refresh, you can call it any time to enact boot changes.&quot; fi else echo &quot;$msg. Use the &#x27;refresh&#x27; command to update the ESPs.&quot; fi&#125;pin_kernel() &#123; ver=&quot;$1&quot; pin_file=&quot;$2&quot; if [ -z &quot;$ver&quot; ]; then boot_kernels=&quot;$(boot_kernel_list)&quot; warn &quot;E: &lt;kernel-version&gt; is mandatory&quot; warn &quot;&quot; warn &quot;Possible Proxmox kernel versions are:&quot; warn &quot;$boot_kernels&quot; exit 1 fi if [ -z &quot;$pin_file&quot; ]; then pin_file=&quot;$PINNED_KERNEL_CONF&quot; fi if [ ! -e &quot;/boot/vmlinuz-$ver&quot; ]; then boot_kernels=&quot;$(boot_kernel_list)&quot; warn &quot;E: no kernel image found in /boot for &#x27;$ver&#x27;, not setting default.&quot; warn &quot;&quot; warn &quot;Possible Proxmox kernel versions are:&quot; warn &quot;$boot_kernels&quot; exit 1 fi if [ -e &quot;$pin_file&quot; ]; then old_pin=$(get_first_line &quot;$&#123;pin_file&#125;&quot;) if [ &quot;$ver&quot; != &quot;$old_pin&quot; ]; then echo &quot;Overriding previously pinned version &#x27;$old_pin&#x27; with &#x27;$ver&#x27;&quot; fi fi echo &quot;$ver&quot; &gt; &quot;$pin_file&quot; if [ -f &quot;$&#123;ESP_LIST&#125;&quot; ]; then _ask_interactive_refresh &quot;Set kernel &#x27;$ver&#x27; in $pin_file&quot; else next_boot_ver=$(get_first_line &quot;$&#123;NEXT_BOOT_PIN&#125;&quot;) pin_ver=&quot;$&#123;next_boot_ver:-$ver&#125;&quot; echo &quot;Setting &#x27;$pin_ver&#x27; as grub default entry and running update-grub.&quot; set_grub_default &quot;$pin_ver&quot; update-grub fi&#125;unpin_kernel() &#123; last_pin=$(get_first_line &quot;$&#123;NEXT_BOOT_PIN&#125;&quot;) rm -f &quot;$NEXT_BOOT_PIN&quot; echo &quot;Removed $NEXT_BOOT_PIN.&quot; if [ -z &quot;$1&quot; ]; then old_pin=$(get_first_line &quot;$&#123;PINNED_KERNEL_CONF&#125;&quot;) last_pin=$&#123;old_pin:-$last_pin&#125; rm -f &quot;$PINNED_KERNEL_CONF&quot; echo &quot;Removed $PINNED_KERNEL_CONF.&quot; fi if [ -f &quot;$&#123;ESP_LIST&#125;&quot; ]; then if [ -n &quot;$last_pin&quot; ]; then _ask_interactive_refresh &quot;Unpinned kernel &#x27;$last_pin&#x27;&quot; fi else echo &quot;Reset default grub entry and running update-grub.&quot; pinned_kernel=$(get_first_line &quot;$&#123;PINNED_KERNEL_CONF&#125;&quot;) set_grub_default &quot;$pinned_kernel&quot; update-grub fi&#125;if [ -z &quot;$1&quot; ]; then usage exit 0ficase &quot;$1&quot; in &#x27;format&#x27;) shift if [ -z &quot;$1&quot; ]; then warn &quot;E: &lt;partition&gt; is mandatory.&quot; warn &quot;&quot; usage &quot;format&quot; exit 1 fi format &quot;$@&quot; exit 0 ;; &#x27;init&#x27;) reexec_in_mountns &quot;$@&quot; shift if [ -z &quot;$1&quot; ]; then warn &quot;E: &lt;partition&gt; is mandatory.&quot; warn &quot;&quot; usage &quot;init&quot; exit 1 fi init_bootloader &quot;$@&quot; echo &quot;Refreshing kernels and initrds..&quot; refresh exit 0 ;; &#x27;reinit&#x27;) reexec_in_mountns &quot;$@&quot; shift if [ &quot;$#&quot; -eq 1 ]; then warn &quot;E: no arguments allowed.&quot; warn &quot;&quot; usage &quot;reinit&quot; exit 1 fi loop_esp_list reinit &quot;$@&quot; exit 0 ;; &#x27;clean&#x27;) shift clean &quot;$@&quot; exit 0 ;; &#x27;refresh&#x27;) shift if [ &quot;$#&quot; -eq 0 ]; then refresh elif [ &quot;$#&quot; -eq 2 ] &amp;&amp; [ &quot;$1&quot; = &quot;--hook&quot; ]; then refresh &quot;$2&quot; else usage &quot;refresh&quot; exit 1 fi exit 0 ;; &#x27;kernel&#x27;|&#x27;kernels&#x27;) shift if [ -z &quot;$1&quot; ]; then warn &quot;E: subcommand is mandatory for &#x27;kernel&#x27;.&quot; warn &quot;&quot; usage &quot;kernel&quot; exit 1 fi cmd=&quot;$1&quot; case &quot;$cmd&quot; in &#x27;add&#x27;) add_kernel &quot;$2&quot; exit 0 ;; &#x27;remove&#x27;) remove_kernel &quot;$2&quot; exit 0 ;; &#x27;list&#x27;) list_kernels exit 0 ;; &#x27;pin&#x27;) if [ &quot;$#&quot; -eq 3 ] &amp;&amp; [ &quot;$3&quot; = &#x27;--next-boot&#x27; ]; then pin_kernel &quot;$2&quot; &quot;$&#123;NEXT_BOOT_PIN&#125;&quot; echo &quot;Pinned for next boot only.&quot; elif [ &quot;$#&quot; -eq 2 ]; then pin_kernel &quot;$2&quot; else usage &quot;kernel&quot; exit 1 fi exit 0 ;; &#x27;unpin&#x27;) if [ &quot;$#&quot; -eq 2 ] &amp;&amp; [ &quot;$2&quot; = &#x27;--next-boot&#x27; ]; then unpin_kernel &quot;$2&quot; elif [ &quot;$#&quot; -eq 1 ]; then unpin_kernel else usage &quot;kernel&quot; exit 1 fi exit 0 ;; *) warn &quot;E: invalid &#x27;kernel&#x27; subcommand &#x27;$cmd&#x27;.&quot; warn &quot;&quot; usage &quot;kernel&quot; exit 1 ;; esac ;; &#x27;status&#x27;) if [ &quot;$#&quot; -eq 2 ] &amp;&amp; [ &quot;$2&quot; = &#x27;--quiet&#x27; ]; then shift status &quot;$1&quot; elif [ &quot;$#&quot; -eq 1 ]; then reexec_in_mountns &quot;$@&quot; shift status else usage &quot;status&quot; exit 1 fi exit 0 ;; &#x27;help&#x27;) shift help exit 0 ;; *) warn &quot;Invalid/unknown command &#x27;$1&#x27;.&quot; warn &quot;&quot; usage exit 1 ;;esacexit 1"},{"title":"Hexo","path":"/2024/11/28/Hexo/hexo/","content":"Hexo部署过程中遇到的一些问题图片与Typora兼容网上给了很多方法，尝试没有效果，自己尝试的方案： 卸载插件hexo-asset-image: yarn remove hexo-asset-image,GitHub有修改的对应插件，但是使用无效果 typora配置 Typora新插入图片路径显示为： Hexo部署时正常显示 Hexo不生效问题Hexo部署到github上不生效，网上解决方案说需要除Main或者Master分支以外额外构建一个分支，然后网站推送到这个分支上，实际使用不管用。 首先，只需要维护一个主分支，不需要其他分支； 其次，hexo -d执行以后，main分支中即使已经更新了代码，但是github page更新也需要一段时间，部署频繁会产生排队 仓库主页github-pages上可以观察到生成静态页面的进度。"},{"title":"Neoperf_study","path":"/2024/11/28/kernel-explore/Neoperf-study/","content":"NeoPerf study 本文主要为学习论文《NeoMem: Hardware&#x2F;Software Co-Design for CXL-Native Memory Tiering》的工作，分为三个部分，用户态、内核以及FPGA部分，内核开源仓库地址为： PKUZHOU&#x2F;linux 代码基于linux内核代码6.0开始修改。 由于初步探索linux内核代码，所以没有按照自顶向下的视角分析代码，而是基于git提交记录，借助AI与互联网搜索，平铺遇到的相关知识。版本不断更新…… a naive neoprof drivercommit ID 9bd35383 本次主要在driver目录下提交了一个驱动neoperf: 主要是实现了一些对外设的IO操作 Linux内核配置文件KconfigKconfig文件用于定义内核配置菜单，这些菜单可以在编译内核时启用或禁用特定的功能。 1234#Kconfig文件config NEOPROF#定义了一个名为`NEOPROF`的内核配置选项，将在内核配置菜单中创建选项\tbool &quot;Enable Neoprofiler&quot; #bool类型，是否启用 default n #默认不启用 在内核编译过程中可以在Drivers下查找到 Kconfig有其独特的语法，也是可以一层一层包裹下去：menu、source、endmenu等组成了编译选项配置过程中的树状菜单 Kconfig设置对应的编译变量后，makefile指导构建编译的过程中会利用这些变量，从而实现选择性的编译 neoperf.h主要新增了四个接口，对neoprof设备（此处指Type2-CXL设备）进行访问： 1234567891011/* * The following functions are used to access the neoprof device*/u64 get_nr_hotpages(void);//获取当前系统中的热页数量u64* get_hotpages(void);//获取热页u64 get_hotness_threshold(void);//获取热度阈值void set_hotness_threshold(u64 threshold);//设置热度阈值 neoperf.c驱动开发hello worldneoperf.c 以下部分参考驱动开发知识：https://www.cnblogs.com/downey-blog/p/10500828.html 123456module_init(neoprof_init);module_exit(neoprof_exit);MODULE_LICENSE(&quot;GPL v2&quot;);MODULE_AUTHOR(&quot;PKUZHOU&quot;);MODULE_DESCRIPTION(&quot;Neoprofiler Linux driver&quot;); io地址映射相关知识需要理解 IO端口的编址方式： 包括IO指令的端口映射方式、MMIO的统一内存映射方式 一些常见的IO操作函数 12void * ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags); //memset_io\\memcpy_fromio\\readb 参考：https://blog.csdn.net/do2jiang/article/details/5450839 neomem migration skeletoncommit ID 26cabad18 新增 NeoMem模块: migrate.c主要是提供接口migrate_misplaced_page_no_vma 调用一些mm中的内存操作函数，进行页面隔离、迁移 neomem.h eomem.c主要就是启动 neomem模块（调用core文件中启动守护进程） late_initcall()在内核启动后期适当时间执行，理解module_init等init宏的顺序，在include/linux/init.h中 linux设备驱动加载的先后顺序 neomem_core.c 内存中的各种分配函数 kthread_run内核线程 FPGA端侧模块结构顶层模块： ddr内存参数调整cxl ip考虑了不同ddr的，包括是否支持DBI、内存通道数量等。采用宏的方式区分，设置不同的方式时，需要对ip内通过宏定义来确定相关的内存参数，同时也需要在顶层模块对相关参数进行修改。 .kwfcchfxdmjc{zoom:50%;} .xvwcbhdyqkve{zoom:50%;} .pwsislyuxfik{zoom:50%;} 或者通过更改ip文件，重新生成新的IP文件夹 .tqdzdutxtsjv{zoom:50%;} quartus1set_global_assignment -name OPTIMIZATION_MODE &quot;AGGRESSIVE COMPILE TIME&quot; 烧录模式AS x4 Neomem todo代码存在一些可以完善的地方： CXL地址采用硬编码，可以引入设备树或者其他检测CXL物理地址的工具进行优化，参考"},{"title":"linux脚本备忘录","path":"/2024/11/26/备忘录/linux脚本备忘录/","content":"Linux脚本备忘录安装系统后的环境准备添加新用户 123456adduser #封装命令，处理完添加用户的全部过程 su到新用户显示username@hostname~$:useradd #底层命令，什么都没有加,su到新用户显示$:# 生成 8 位强密码PASSWORD=$(openssl rand -base64 6 | cut -c1-8)echo &quot;Password: $PASSWORD&quot; 用户添加sudo组 1234567usermod -aG sudo new_user#加完以后记得:newgrp sudo#作用有3：#1.切换到指定的组上下文#2.即时生效组更改#3.启动一个子 shell 配置sshd12345678#服务端安装apt install ssh-server#配置sudo vim /etc/ssh/sshd_config#重启服务sudo service restart sshd VimVim配置推荐 - ma6174 12wget 47.93.11.51:88/install_vim.shbash install_vim.sh zsh1234567891011121314#安装zshsudo apt install zsh#修改默认shell为zshchsh -s /bin/zsh#安装oh-my-zshsh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;##如果不成功，请执行下面两条命令，成功了就不需要做下面两条wget 47.93.11.51:88/install_zsh.shbash install_zsh.sh#安装zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 历史记录推荐命令插件12##命令自动推荐，根据历史记录git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 命令自动补全12345##命令自动补全插件mkdir ~/.oh-my-zsh/plugins/incrwget http://mimosa-pudica.net/src/incr-0.2.zsh -O ~/.oh-my-zsh/plugins/incr/incr.plugin.zsh##目录自动跳转插件sudo apt install autojump .zshrc配置文件配置12#插件添加zsh-syntax-highlightingplugins=(git zsh-syntax-highlighting) 123456789#设置终端颜色，提示符，及上一条指令返回码提示autoload -U colors &amp;&amp; colorsPROMPT=&quot;%&#123;$fg[red]%&#125;%n%&#123;$reset_color%&#125;@%&#123;$fg[blue]%&#125;%m %&#123;$fg[yellow]%&#125;%1~ %&#123;$reset_color%&#125;%# &quot;RPROMPT=&quot;[%&#123;$fg[yellow]%&#125;%?%&#123;$reset_color%&#125;]&quot;# Useful support for interacting with Terminal.app or other terminal programs[ -r &quot;/etc/zshrc_$TERM_PROGRAM&quot; ] &amp;&amp; . &quot;/etc/zshrc_$TERM_PROGRAM&quot;source ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.plugin.zshsource /usr/share/autojump/autojump.shsource ~/.oh-my-zsh/plugins/incr/incr*.zsh ctags12345#安装sudo apt install ctags #建立索引ctags -I __THROW -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --langmap=c:+.h --languages=c,c++ --links=yes --c-kinds=+p --c++-kinds=+p --fields=+iaS --extra=+q -f ~/.vim/systags /usr/include/* /usr/include/x86_64-linux-gnu/sys/* /usr/include/x86_64-linux-gnu/bits/* /usr/include/arpa/* .vimrc添加索引 1set tags+=~/systags 安装glibc-doc 使用以下命令安装 1sudo apt install glibc-doc 常见路径hostname :/etc/hostname host: /ect/hosts tomcat1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#安装JDK8sudo apt install default-jre -ysudo apt install openjdk-11-jre-headless -ysudo apt install openjdk-8-jre-headless -y #sudo wget https://downloads.apache.org/tomcat/tomcat-8/v8.5.65/bin/apache-tomcat-8.5.65.tar.gzsudo wget https://mirrors.bfsu.edu.cn/apache/tomcat/tomcat-8/v8.5.73/bin/apache-tomcat-8.5.73.tar.gztar zxf apache-tomcat-8.5.73.tar.gzsudo mv apache-tomcat-8.5.73 /usr/local/tomcat#建立软连接sudo ln -s /usr/local/tomcat/bin/* /usr/local/sbin/#启动startup.sh start #端口检查netstat -anput | grep 8080#启动命令startup.sh start #//启动shutdown.sh #//关闭catalina.sh stop #//启动catalina.sh start #//关闭#关闭防火墙sudo ufw disable #tomcat 参数配置vim /usr/local/tomcat/conf/server.xml #.......&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; #将之前8080端口改成8081端口connectionTimeout=&quot;20000&quot; # redirectPort=&quot;8443&quot; /&gt;#目录修 # &lt;Host name=&quot;localhost&quot; appBase=&quot;/opt/www&quot; #将网站根目录改到/opt/www # unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;#更改网站家目录，这里的ROOT必须大写，更改完成后需要重启sudo mkdir /opt/www/ROOT -p mysqlmysql 8.0下载 1wget https://repo.mysql.com//mysql-apt-config_0.8.20-1_all.deb 12345678#MySQL 设置#密码sudo mysql -uroot use mysql;update user set authentication_string=PASSWORD(&quot;自定义密码&quot;) where User=&quot;root&quot;;update user set plugin=&quot;mysql_native_password&quot; where User =&quot;root&quot;;flush privileges;quit; 对于Linux和windows下字符集不兼容的情况，需要替换 • 把文件中的所有的utf8mb4_0900_ai_ci替换为utf8_general_ci• 以及utf8mb4替换为utf8• 如上图所示的位置，上图只是一部分，注意全部替换。 数据库导出 1mysqldump -uroot -p &gt;c:ShareYunAlbum。sql 数据库导入 12use ShareYunAlbum source ~/ShqreYunAlbum.sql 卸载mysql 123456sudo apt purge mysql-* -ysudo rm -rf /etc/mysql/ /var/lib/mysqlsudo apt autoremovesudo apt autorecleansudo apt-get remove mysql-common dpkg -l |grep ^rc|awk &#x27;&#123;print $2&#125;&#x27; |sudo xargs dpkg -P"},{"title":"控台项目与iSet项目已使用Qt技能点整理","path":"/2024/10/15/技能点整理/","content":"1. 高度自定义控件1. 中间滑动的slider2. doubleSpinBox3. iSet新建项目的两种模式ListWidget、选中状态设置为图标模式4.QTreeWidget 框架、表头、样式表、代理 Qt QTreeWidget树形控件用法详解_qtreewidget用法_睿科知识云的博客-CSDN博客 2. Qt大模块1. Qt DP指针2. 视图模型机制3. 视图框架4. QStyle 高度自定义实现5. 元对象与信号槽机制6.构建系统7.QInvokeMethod8.国际化3. Qt细节1. 基础控件2. Undo操作3. svg操作4. Qt不在对象树的工具汇总5.Qt中有有用的宏：Q_LIKELY 6.paint在install中绘制 4. Qt锦上添花1. 动画知识2. 拖拽3. 插件机制4.模块化构建5. Qt中的设计模式1. 单例模式2. 责任链模式3. 接口模式4. 适配器模式5.观察者模式， 线程观察、时间压缩 6.全局信号单例转发类 12345678MAINOPERATIONVIEW_EXPORT bool MainOperationView_Init(IISetWidget ** ppWidget, QWidget * parent)&#123; if (ppWidget == nullptr || parent == nullptr) return false; *ppWidget = new CMainOperationView(parent); return true;&#125; 6. C++知识c++11新特性，所有知识点都在这了！ - 知乎 (zhihu.com) this_thread ++ lambda的坑 12345for(int id = enCoef9_Rr ; id &lt;= enCoef9_Bb ;id++)&#123; connect(m_spinBoxs[id],QOverload&lt;double&gt;::of(&amp;QDoubleSpinBox::valueChanged),this,[&amp;](double value)&#123; OnCoefMatrixSlot(id,value); &#125;);&#125; id 恒等于 0 多继承与QOBject private 虚继承 123456789101112131415161718192021class CBase&#123;private:\tvirtual void virtualPrivateFuntion()&#123; std::cout&lt;&lt;&quot;base virtualPrivateFuntion&quot;;\t&#125;&#125;；class CSub :public CBase&#123;\tprivate:\tvirtual void virtualPrivateFuntion() override&#123; std::cout&lt;&lt;&quot;sub virtualPrivateFuntion&quot;;\t&#125;&#125;int main()&#123;\tCBase* pObject = new CSub();\tpObject-&gt;virtualPrivateFuntion();&#125;//结果：sub virtualPrivateFuntion，//结论：子类继承父类的private virtual可以重写 可变参数、变参模板 函数包装器 std::shared_ptrreset、make_shared 右值引用C++反射元编程Metaprogram is a program about a program. 7.杂项QStatusBar插件机制解耦快捷键ISet7.0 接口设计 MVC8.轮子1.单例2.工作线程封装3.stl 迭代器模式和适配器模式报错整理： QMenu 没有添加Action时，不能直接visible或这exec； setGeometry: Unable to set geometry 的一种解决办法是重写sizehint，而不是使用setFixedSize； 工具使用AddressSanitizer（不适用与MinGW）[AddressSanitizer 定位嵌入式c&#x2F;c++内存错误 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/436177229#:~:text=AddressSanitizer （又名 ASan）是 C%2FC%2B%2B 的内存错误检测器。 AddressSanitizer 由 google,的一部分，而从 4.8 版开始逐渐成为 GCC 的一部分。 这也意味着如果交叉编译器版本低于 4.8 ，是无法使用的。) Qt 拾遗 008 在 Qt 中使用 Address Sanitizer - 简书 (jianshu.com) 在Qt中使用gcc 4.8.0的地址消毒剂(Address Sanitizer) MTuner软件【精选】基于MTuner软件进行qt的mingw编译程序的内存泄漏检测_mtuner怎么使用_yantuguiguziPGJ的博客-CSDN博客"}]