[{"title":"CXL-place-llvm-PGO","path":"/2025/04/23/备忘录/CXL-place-llvm-PGO/","content":"CXL-place-llvm-PGO编译1234567cd llvm-projectmkdir buildcd buildcmake -G &quot;Unix Makefiles&quot; -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DCMAKE_BUILD_TYPE=Release ../llvmmake -j$(nproc)clang -c runtime.c -o runtime.o Heap profiler pass compiler12clang -fpass-plugin=lib/LLVMHeapProfiler.so test.c -o test_instrumented 运行 optimizer pass1clang -fpass-plugin=build/lib/LLVMHeapAllocOptimizer.so test.c -o test_optimized 分步骤优化12345678910111213# 编译测试程序build/bin/clang -c -O0 -emit-llvm test.c -o test.bcbuild/bin/clang -S -emit-llvm test.c -o test.ll# 使用opt运行passbuild/bin/opt -passes=heap-profiler test.bc -o test.ll# 编译最终程序build/bin/clang test.ll runtime.o -o testclang++ -std=c++11 -c runtime.cpp -o runtime.obuild/bin/clang++ test_after_instru.ll runtime.o -o test# 运行测试./test 问题 llvm debug, Opt: Option registered more than once! ​"},{"title":"LLVM explore","path":"/2025/04/23/LLVM-explore/LLVM-explore/","content":"入门llvm笔记 新旧新增pass流程CRTP（奇异递归模板模式）(以下内容基于AI生成) 通常通过继承的方式实现单例模式也是这样，只是不知道叫这个名字 CRTP（Curiously Recurring Template Pattern，奇异递归模板模式）是C++中的一种高级模板编程技术，通过让一个类继承自以自身为模板参数的基类模板，实现静态多态或代码复用。 123template &lt;typename Derived&gt;class Base &#123; /* 基类使用Derived类型 */ &#125;;class MyClass : public Base&lt;MyClass&gt; &#123; /* 派生类将自身作为模板参数传递给基类 */ &#125;; 核心作用1. 静态多态（编译时多态） 动态多态（虚函数）的问题：运行时虚表查找导致性能开销。 CRTP的解决方案：基类在编译时通过模板参数直接调用派生类的方法。 123456789101112131415161718192021template &lt;typename Derived&gt;class Animal &#123;public: void speak() &#123; static_cast&lt;Derived*&gt;(this)-&gt;speakImpl(); // 编译时确定调用 &#125;&#125;;class Cat : public Animal&lt;Cat&gt; &#123;public: void speakImpl() &#123; std::cout &lt;&lt; &quot;Meow &quot;; &#125;&#125;;class Dog : public Animal&lt;Dog&gt; &#123;public: void speakImpl() &#123; std::cout &lt;&lt; &quot;Woof &quot;; &#125;&#125;;// 使用Animal&lt;Cat&gt; cat;cat.speak(); // 输出 &quot;Meow&quot;（无虚函数开销） 2. 代码复用 基类可提供通用逻辑，派生类通过特化实现差异部分。 123456789101112131415161718192021template &lt;typename Derived&gt;class Counter &#123;protected: static int count;public: Counter() &#123; ++count; &#125; static int getCount() &#123; return count; &#125;&#125;;template &lt;typename Derived&gt;int Counter&lt;Derived&gt;::count = 0;// 统计对象实例数的类class Widget : public Counter&lt;Widget&gt; &#123;&#125;;class Gadget : public Counter&lt;Gadget&gt; &#123;&#125;;// 使用Widget w1, w2;Gadget g1;std::cout &lt;&lt; Widget::getCount(); // 输出 2std::cout &lt;&lt; Gadget::getCount(); // 输出 1 CRTP vs 虚函数 特性 CRTP 虚函数 多态时机 编译时 运行时 性能 无额外开销（直接调用） 虚表查找开销 灵活性 类型固定（模板参数需明确） 支持运行时类型动态替换 适用场景 高性能库、框架基础设施 需要运行时动态行为的情况 CRTP的典型应用场景 编译时多态：如数学库中的向量&#x2F;矩阵运算（Eigen库）。 对象计数：统计不同派生类的实例数量。 Mixin模式：为类动态添加功能（如LLVM的PassInfoMixin）。 链式调用：返回派生类引用以实现链式语法（return static_cast&lt;Derived&amp;&gt;(*this);）。 llvm中的dyn_cast与C++的RTTIC++ RTTI"},{"title":"龙蜥CXL讲解-高显扬","path":"/2025/01/06/CXL/龙蜥CXL讲解-高显扬/","content":"CXL技术介绍对视频链接的PPT搬运，方便快速阅读 高显杨 浪潮 综述 协议协议演进 1.1内存拓展 2.0内存赤化 3.0特性 CXL子协议 CXL设备 CXL Fabric 参考VPN，下边两张为单switch CXL RAS特性 内存热插拔？如何避免宕机 CXL初始化 RCRB CXL 1.1跑CXL2实现协议兼容 CXL方案 池化管理：FM中的bind和UnBind 业界方案 补充"},{"title":"OCP China 2024 CXL 论坛学习笔记","path":"/2025/01/06/CXL/OCP-China-2024-CXL-论坛学习笔记/","content":"OCP China 2024 CXL论坛 学习笔记会议链接 阿里云 数据中心高性能Scale Up 互联系统趋势 孔阳 阿里云超高速互联负责人 胡文普 CXL部分 Scale Up 云的角度 关注两个计算 ： 通用计算、GPU计算 通用计算上： 考虑弹性分析：存储上-&gt;云盘技术 网络-&gt;CIPU网络虚拟化 内存上-&gt;CXL GPU上：大模型单次任务，数据并行、流水线并行、tensor并行、专家并行，都具有较高的带宽要求 CXL 机柜内的资源弹性实现需要满足高性能接口、资源共享、极致弹性、软件生态兼容性等要求。CXL特性符合这些要求。CXL将一致性访问从CPU内部拓展到CPU和内存之间，实现多服务器之间的互联。 CXL的演进 GIM ： P2P ： DSP与type3互联，type3可以分配给DSP或者host HBR-&gt;PBR:不止树状、星状、网络状 E3.s 热插拔，便于可拓展 JBOM 大容量 PEMEM ：支持2.0，满足redis实时性持久化等要求 基于 内存与CPU实现资源解耦 CXL在小数据上传输性能大大提高； intel: CXL on Intel Xeon@ Platform 赵森林 CXL overview CXL Specification Summary"},{"title":"Kernel-compile","path":"/2024/12/05/kernel-explore/Kernel-compile/","content":"内核编译123456789101112131415161718192021222324252627282930#查看当前内核版本uname -a#源码获取sudo apt-get install linux-sourcecd /usr/srctar xvf linux-source-*.tar.bz2cd linux-source-*#补丁应用patch -p1 &lt; /path/to/patch.diff#`-p1`选项可能需要根据补丁文件的格式进行调整。make menuconfig #或者oldconfig,本质是配置/usr/src/configmake -j$(nproc)#根据 .config 配置文件编译内核、内核模块和其他必要的文件，生成内核镜像（vmlinuz）和其他相关的文件#编译过程中可能出现每包头文件或者其他错误，可能是版本原因，针对报错解决即可#内核安装#安装过程可能会出现头文件报错或者缺库、或安装完成后缺库，只需要apt安装对应的库就好，make过程中会自动hook#安装内核模块(在运行时可以加载或卸载的模块)#从编译输出的目录（如 lib/modules/&lt;kernel_version&gt;/）,并执行 depmod 来生成模块依赖关系sudo make modules_install#内核镜像（如 vmlinuz）、配置文件（如 config）、符号表文件（如 System.map）和 initrd 镜像安装到 /boot 目录sudo make install#更新启动引导程序sudo update-grup 关于配置选项相关操作，参考：:star::star:Linux 内核动手编译实用指南 KGDB配置编译选项 参考资料KGDB原理分析及远程挂载调试ARM64内核 内核启动参数 1kgdboc=ttyS0,115200 kgdbwait kgdbtcp=192.168.1.2:1234 kgdboc=ttyS0,115200：设置串口调试（可选） kgdbwait：启动时等待调试器连接 kgdbtcp=192.168.1.2:1234：被调试主机的IP和端口 永久修改：/etc/default/grub下GRUB_CMDLINE_LINUX变量 proxmox-boot-toolproxmox-boot-tool，一个脚本，设置启动内核、增删内核等 Proxmox VE（Proxmox Virtual Environment）是一个开源的虚拟化管理平台，专为企业级环境设计，能够管理虚拟机（VM）、容器、存储和集群。 其中 proxmox-boot-tool脚本在内核管理切换过程中比较有用，这里做备份，便于不整体下载Proxmox VE而单独使用此工具，仅供个人学习使用 使用前提是需要先下载Promox VE 先换源/etc/apt/sources.list.d/pve-no-subscription.list 12deb http://mirrors.ustc.edu.cn/proxmox/debian/pve bookworm pve-no-subscriptiondeb http://mirrors.tuna.tsinghua.edu.cn/proxmox/debian/pve bookworm pve-no-subscription 记得把&#x2F;etc&#x2F;apt&#x2F;sources.list.d下原有的源注释掉 kernel add等 在 &#x2F;boot下边找到对应版本号 之后可通过apt search \\install 搜索下载对应的pve版本内核 proxmox-boot-tool下载链接,先下载proxmox-kernel-helper 参考链接： https://kernelnewbies.org/KernelBuild"},{"title":"Hexo","path":"/2024/11/28/Hexo/hexo/","content":"Hexo部署过程中遇到的一些问题图片与Typora兼容网上给了很多方法，尝试没有效果，自己尝试的方案： 卸载插件hexo-asset-image: yarn remove hexo-asset-image,GitHub有修改的对应插件，但是使用无效果 typora配置 Typora新插入图片路径显示为： Hexo部署时正常显示 Hexo不生效问题Hexo部署到github上不生效，网上解决方案说需要除Main或者Master分支以外额外构建一个分支，然后网站推送到这个分支上，实际使用不管用。 首先，只需要维护一个主分支，不需要其他分支； 其次，hexo -d执行以后，main分支中即使已经更新了代码，但是github page更新也需要一段时间，部署频繁会产生排队 仓库主页github-pages上可以观察到生成静态页面的进度。"},{"title":"Neoperf_study","path":"/2024/11/28/kernel-explore/Neoperf-study/","content":"NeoPerf study 本文主要为学习论文《NeoMem: Hardware&#x2F;Software Co-Design for CXL-Native Memory Tiering》的工作，分为三个部分，用户态、内核以及FPGA部分，内核开源仓库地址为： PKUZHOU&#x2F;linux 代码基于linux内核代码6.0开始修改。 由于初步探索linux内核代码，所以没有按照自顶向下的视角分析代码，而是基于git提交记录，借助AI与互联网搜索，平铺遇到的相关知识。版本不断更新…… a naive neoprof drivercommit ID 9bd35383 本次主要在driver目录下提交了一个驱动neoperf: 主要是实现了一些对外设的IO操作 Linux内核配置文件KconfigKconfig文件用于定义内核配置菜单，这些菜单可以在编译内核时启用或禁用特定的功能。 1234#Kconfig文件config NEOPROF#定义了一个名为`NEOPROF`的内核配置选项，将在内核配置菜单中创建选项\tbool &quot;Enable Neoprofiler&quot; #bool类型，是否启用 default n #默认不启用 在内核编译过程中可以在Drivers下查找到 Kconfig有其独特的语法，也是可以一层一层包裹下去：menu、source、endmenu等组成了编译选项配置过程中的树状菜单 Kconfig设置对应的编译变量后，makefile指导构建编译的过程中会利用这些变量，从而实现选择性的编译 neoperf.h主要新增了四个接口，对neoprof设备（此处指Type2-CXL设备）进行访问： 1234567891011/* * The following functions are used to access the neoprof device*/u64 get_nr_hotpages(void);//获取当前系统中的热页数量u64* get_hotpages(void);//获取热页u64 get_hotness_threshold(void);//获取热度阈值void set_hotness_threshold(u64 threshold);//设置热度阈值 neoperf.c驱动开发hello worldneoperf.c 以下部分参考驱动开发知识：https://www.cnblogs.com/downey-blog/p/10500828.html 123456module_init(neoprof_init);module_exit(neoprof_exit);MODULE_LICENSE(&quot;GPL v2&quot;);MODULE_AUTHOR(&quot;PKUZHOU&quot;);MODULE_DESCRIPTION(&quot;Neoprofiler Linux driver&quot;); io地址映射相关知识需要理解 IO端口的编址方式： 包括IO指令的端口映射方式、MMIO的统一内存映射方式 一些常见的IO操作函数 12void * ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags); //memset_io\\memcpy_fromio\\readb 参考：https://blog.csdn.net/do2jiang/article/details/5450839 neomem migration skeletoncommit ID 26cabad18 新增 NeoMem模块: migrate.c主要是提供接口migrate_misplaced_page_no_vma 调用一些mm中的内存操作函数，进行页面隔离、迁移 neomem.h eomem.c主要就是启动 neomem模块（调用core文件中启动守护进程） late_initcall()在内核启动后期适当时间执行，理解module_init等init宏的顺序，在include/linux/init.h中 linux设备驱动加载的先后顺序 neomem_core.c 内存中的各种分配函数 kthread_run内核线程 FPGA端侧模块结构顶层模块： cxltyp3_memexp_ddr4_top-&gt;ed_top_wrapper_typ3 ddr内存参数调整cxl ip考虑了不同ddr的，包括是否支持DBI、内存通道数量等。采用宏的方式区分，设置不同的方式时，需要对ip内通过宏定义来确定相关的内存参数，同时也需要在顶层模块对相关参数进行修改。 .jqplclsjphym{zoom:50%;} .wdnlnmhpkjgs{zoom:50%;} .pjzjvhqdjckr{zoom:50%;} 或者通过更改ip文件，重新生成新的IP文件夹 .xlltumiehokv{zoom:50%;} quartus1set_global_assignment -name OPTIMIZATION_MODE &quot;AGGRESSIVE COMPILE TIME&quot; 烧录模式AS Jtag ps 三种烧录模式 Neomem todo代码存在一些可以完善的地方： CXL地址采用硬编码，可以引入设备树或者其他检测CXL物理地址的工具进行优化，参考"},{"title":"linux脚本备忘录","path":"/2024/11/26/备忘录/linux脚本备忘录/","content":"Linux脚本备忘录安装系统后的环境准备添加新用户 123456adduser #封装命令，处理完添加用户的全部过程 su到新用户显示username@hostname~$:useradd #底层命令，什么都没有加,su到新用户显示$:# 生成 8 位强密码PASSWORD=$(openssl rand -base64 6 | cut -c1-8)echo &quot;Password: $PASSWORD&quot; 用户添加sudo组 1234567usermod -aG sudo new_user#加完以后记得:newgrp sudo#作用有3：#1.切换到指定的组上下文#2.即时生效组更改#3.启动一个子 shell 配置sshd12345678#服务端安装apt install ssh-server#配置sudo vim /etc/ssh/sshd_config#重启服务sudo service restart sshd VimVim配置推荐 - ma6174 12wget 47.93.11.51:88/install_vim.shbash install_vim.sh zsh1234567891011121314#安装zshsudo apt install zsh#修改默认shell为zshchsh -s /bin/zsh#安装oh-my-zshsh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;##如果不成功，请执行下面两条命令，成功了就不需要做下面两条wget 47.93.11.51:88/install_zsh.shbash install_zsh.sh#安装zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 历史记录推荐命令插件12##命令自动推荐，根据历史记录git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 命令自动补全12345##命令自动补全插件mkdir ~/.oh-my-zsh/plugins/incrwget http://mimosa-pudica.net/src/incr-0.2.zsh -O ~/.oh-my-zsh/plugins/incr/incr.plugin.zsh##目录自动跳转插件sudo apt install autojump .zshrc配置文件配置12#插件添加zsh-syntax-highlightingplugins=(git zsh-syntax-highlighting) 123456789#设置终端颜色，提示符，及上一条指令返回码提示autoload -U colors &amp;&amp; colorsPROMPT=&quot;%&#123;$fg[red]%&#125;%n%&#123;$reset_color%&#125;@%&#123;$fg[blue]%&#125;%m %&#123;$fg[yellow]%&#125;%1~ %&#123;$reset_color%&#125;%# &quot;RPROMPT=&quot;[%&#123;$fg[yellow]%&#125;%?%&#123;$reset_color%&#125;]&quot;# Useful support for interacting with Terminal.app or other terminal programs[ -r &quot;/etc/zshrc_$TERM_PROGRAM&quot; ] &amp;&amp; . &quot;/etc/zshrc_$TERM_PROGRAM&quot;source ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.plugin.zshsource /usr/share/autojump/autojump.shsource ~/.oh-my-zsh/plugins/incr/incr*.zsh ctags12345#安装sudo apt install ctags #建立索引ctags -I __THROW -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --langmap=c:+.h --languages=c,c++ --links=yes --c-kinds=+p --c++-kinds=+p --fields=+iaS --extra=+q -f ~/.vim/systags /usr/include/* /usr/include/x86_64-linux-gnu/sys/* /usr/include/x86_64-linux-gnu/bits/* /usr/include/arpa/* .vimrc添加索引 1set tags+=~/systags 安装glibc-doc 使用以下命令安装 1sudo apt install glibc-doc 常见路径hostname :/etc/hostname host: /ect/hosts tomcat1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#安装JDK8sudo apt install default-jre -ysudo apt install openjdk-11-jre-headless -ysudo apt install openjdk-8-jre-headless -y #sudo wget https://downloads.apache.org/tomcat/tomcat-8/v8.5.65/bin/apache-tomcat-8.5.65.tar.gzsudo wget https://mirrors.bfsu.edu.cn/apache/tomcat/tomcat-8/v8.5.73/bin/apache-tomcat-8.5.73.tar.gztar zxf apache-tomcat-8.5.73.tar.gzsudo mv apache-tomcat-8.5.73 /usr/local/tomcat#建立软连接sudo ln -s /usr/local/tomcat/bin/* /usr/local/sbin/#启动startup.sh start #端口检查netstat -anput | grep 8080#启动命令startup.sh start #//启动shutdown.sh #//关闭catalina.sh stop #//启动catalina.sh start #//关闭#关闭防火墙sudo ufw disable #tomcat 参数配置vim /usr/local/tomcat/conf/server.xml #.......&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; #将之前8080端口改成8081端口connectionTimeout=&quot;20000&quot; # redirectPort=&quot;8443&quot; /&gt;#目录修 # &lt;Host name=&quot;localhost&quot; appBase=&quot;/opt/www&quot; #将网站根目录改到/opt/www # unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;#更改网站家目录，这里的ROOT必须大写，更改完成后需要重启sudo mkdir /opt/www/ROOT -p mysqlmysql 8.0下载 1wget https://repo.mysql.com//mysql-apt-config_0.8.20-1_all.deb 12345678#MySQL 设置#密码sudo mysql -uroot use mysql;update user set authentication_string=PASSWORD(&quot;自定义密码&quot;) where User=&quot;root&quot;;update user set plugin=&quot;mysql_native_password&quot; where User =&quot;root&quot;;flush privileges;quit; 对于Linux和windows下字符集不兼容的情况，需要替换 • 把文件中的所有的utf8mb4_0900_ai_ci替换为utf8_general_ci• 以及utf8mb4替换为utf8• 如上图所示的位置，上图只是一部分，注意全部替换。 数据库导出 1mysqldump -uroot -p &gt;c:ShareYunAlbum。sql 数据库导入 12use ShareYunAlbum source ~/ShqreYunAlbum.sql 卸载mysql 123456sudo apt purge mysql-* -ysudo rm -rf /etc/mysql/ /var/lib/mysqlsudo apt autoremovesudo apt autorecleansudo apt-get remove mysql-common dpkg -l |grep ^rc|awk &#x27;&#123;print $2&#125;&#x27; |sudo xargs dpkg -P"},{"title":"控台项目与iSet项目已使用Qt技能点整理","path":"/2024/10/15/技能点整理/","content":"Qt与QML知识总结Qt中的设计模式中间滑动的slider 2. doubleSpinBox3. iSet新建项目的两种模式ListWidget、选中状态设置为图标模式4.QTreeWidget 框架、表头、样式表、代理 Qt QTreeWidget树形控件用法详解_qtreewidget用法_睿科知识云的博客-CSDN博客 2. Qt大模块1. Qt DP指针2. 视图模型机制3. 视图框架4. QStyle 高度自定义实现5. 元对象与信号槽机制6.构建系统7.QInvokeMethod8.国际化3. Qt细节1. 基础控件2. Undo操作3. svg操作4. Qt不在对象树的工具汇总5.Qt中有有用的宏：Q_LIKELY 6.paint在install中绘制 4. Qt锦上添花1. 动画知识2. 拖拽3. 插件机制4.模块化构建5. Qt中的设计模式1. 单例模式2. 责任链模式3. 接口模式4. 适配器模式5.观察者模式， 线程观察、时间压缩 6.全局信号单例转发类 12345678MAINOPERATIONVIEW_EXPORT bool MainOperationView_Init(IISetWidget ** ppWidget, QWidget * parent)&#123; if (ppWidget == nullptr || parent == nullptr) return false; *ppWidget = new CMainOperationView(parent); return true;&#125; 6. C++知识c++11新特性，所有知识点都在这了！ - 知乎 (zhihu.com) this_thread ++ lambda的坑 12345for(int id = enCoef9_Rr ; id &lt;= enCoef9_Bb ;id++)&#123; connect(m_spinBoxs[id],QOverload&lt;double&gt;::of(&amp;QDoubleSpinBox::valueChanged),this,[&amp;](double value)&#123; OnCoefMatrixSlot(id,value); &#125;);&#125; id 恒等于 0 多继承与QOBject private 虚继承 123456789101112131415161718192021class CBase&#123;private:\tvirtual void virtualPrivateFuntion()&#123; std::cout&lt;&lt;&quot;base virtualPrivateFuntion&quot;;\t&#125;&#125;；class CSub :public CBase&#123;\tprivate:\tvirtual void virtualPrivateFuntion() override&#123; std::cout&lt;&lt;&quot;sub virtualPrivateFuntion&quot;;\t&#125;&#125;int main()&#123;\tCBase* pObject = new CSub();\tpObject-&gt;virtualPrivateFuntion();&#125;//结果：sub virtualPrivateFuntion，//结论：子类继承父类的private virtual可以重写 可变参数、变参模板 函数包装器 std::shared_ptrreset、make_shared 右值引用C++反射元编程Metaprogram is a program about a program. 7.杂项QStatusBar插件机制解耦快捷键ISet7.0 接口设计 MVC8.轮子1.单例2.工作线程封装3.stl 迭代器模式和适配器模式报错整理： QMenu 没有添加Action时，不能直接visible或这exec； setGeometry: Unable to set geometry 的一种解决办法是重写sizehint，而不是使用setFixedSize； 工具使用AddressSanitizer（不适用与MinGW）[AddressSanitizer 定位嵌入式c&#x2F;c++内存错误 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/436177229#:~:text=AddressSanitizer （又名 ASan）是 C%2FC%2B%2B 的内存错误检测器。 AddressSanitizer 由 google,的一部分，而从 4.8 版开始逐渐成为 GCC 的一部分。 这也意味着如果交叉编译器版本低于 4.8 ，是无法使用的。) Qt 拾遗 008 在 Qt 中使用 Address Sanitizer - 简书 (jianshu.com) 在Qt中使用gcc 4.8.0的地址消毒剂(Address Sanitizer) MTuner软件【精选】基于MTuner软件进行qt的mingw编译程序的内存泄漏检测_mtuner怎么使用_yantuguiguziPGJ的博客-CSDN博客"}]