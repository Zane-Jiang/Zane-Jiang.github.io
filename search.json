[{"path":"/2025/06/29/备忘录/智能边缘计算第一次作业/","content":"智能边缘计算作业 202414131169蒋泽 1.简要阐述边缘计算的赋能技术答：为了给新一代网络提供资源开放、管理开发和网络开放等能力，针对边缘计算的具体实现和实际部署中的问题，需要使用到一些增强边缘计算能力、优化性能以及拓展应用场景的关键技术。以下是基类常见的边缘计算赋能技术： 软件定义网络（SDN）SDN 通过分离控制平面与数据平面，实现网络资源的灵活调度，优化边缘计算中的数据传输路径，降低延迟并提高带宽利用率 网络功能虚拟化（NFV）NFV 将传统网络设备（如防火墙、负载均衡器）虚拟化，使其能在边缘节点上动态部署，提高资源利用率和灵活性，支持边缘计算的弹性扩展 信息中心网络（ICN）ICN 采用内容为中心的数据分发方式，减少冗余传输，提高边缘缓存效率，适用于视频流、AR&#x2F;VR 等低延迟应用 网络人工智能（AI）AI 技术（如深度学习、强化学习）被用于边缘计算的智能调度、负载预测和异常检测，例如像衍科技的智能负载预测模型提升了算力调度效率300% 云计算与数据中心网络边缘计算与云计算协同（云边协同），形成“端-边-云”架构，如国网山东电力公司的微服务全局调用链优化方案，提升了电力系统的实时响应能力 大数据技术边缘计算结合大数据分析，可在本地进行数据预处理，减少云端传输压力，如伏锂码云平台在风电场的故障诊断中减少70%数据传输量 区块链区块链用于边缘计算的安全认证和数据可信交换，如车载边缘计算中的安全通信和电力交易中的智能合约，防止数据篡改 2.简要阐述边缘计算未来的基于与挑战答：2017年美国计算机社区联盟网络发布《边缘计算重大挑战研讨会报告》，阐述了边缘计算的主要挑战。主要从服务管理，隐私安全，优化指标，理论基础和商业模式几方面阐述： 服务管理复杂性边缘计算需应对服务差异性、可扩展性、隔离性和可靠性等挑战。不同优先级服务的需求差异大，系统需灵活扩展以适应新设备；多应用共享数据时易引发资源冲突；同时，异构设备故障原因复杂，服务失败的定位和恢复困难，这对边缘计算的服务管理能力提出了更高要求。 数据隐私与安全风险边缘设备广泛收集用户数据，但隐私保护面临多重难题：用户安全意识不足（如随意连接公共Wi-Fi），敏感数据需本地化存储以避免泄露，而边缘环境资源有限，传统安全工具难以直接应用。此外，动态网络环境使边缘节点更易受攻击，亟需轻量化安全方案。 多目标优化困境边缘计算需同时优化时延、带宽、能耗和成本等指标，但设备异构性使问题复杂化。例如，降低时延需就近处理数据，但可能增加能耗；节省带宽需压缩数据，却可能影响精度。如何动态权衡这些指标并制定高效资源分配策略，仍是未解难题。 基础理论尚未成熟边缘计算涉及计算、通信、存储等多学科交叉，但现有理论碎片化，缺乏统一框架。例如，分布式能耗模型、多设备协同调度理论、边缘可靠性评估等关键基础研究仍不完善，制约了技术的大规模部署与应用创新。 商业模式不清晰当前边缘计算商业模型以单边（服务或数据驱动）为主，难以协调云服务商、设备厂商、用户等多方利益。如何结合云边协同，构建可持续的多边商业模式（如算力交易、数据共享分成），是推动产业落地的关键挑战。 3.画出一个基于移动通信网络的边缘计算详细结构图 4.详细描述边缘计算系统中的计算迁移过程边缘计算系统中的计算迁移是指将终端设备的计算任务动态分配到边缘节点或云端处理的过程，主要包括以下步骤： 决策阶段：终端根据任务需求（计算量、时延要求）和当前状态（电量、网络条件），通过算法（如强化学习）决定是否迁移任务。 任务分发：将任务代码和数据封装（如Docker容器），通过优化路径（如SDN调度）传输至边缘节点。 边缘处理：边缘节点快速部署任务，实时监控执行情况，必要时进行二次迁移。 结果返回：处理结果经压缩后回传终端，完成同步更新。 5.讨论ETSI和中国边缘计算产业联盟的边缘计算参考架构之间的主要区别ETSI与中国边缘计算产业联盟（ECC）的边缘计算架构主要区别如下： 技术定位： ETSI以电信网络为核心，聚焦5G场景，强调基站侧计算（MEC）；ECC面向工业互联网等泛行业场景，注重”云-边-端”协同。 架构设计： ETSI采用”MEC Host+管理平台”分层架构，标准化接口明确；ECC采用三层架构（边缘层&#x2F;平台层&#x2F;应用层），更强调OT与ICT融合。 应用场景： ETSI主要服务运营商（如VR直播、车联网）；ECC侧重工业应用（如预测性维护、智能工厂）。 产业生态： ETSI由国际电信企业主导；ECC由中国产业界推动，更贴合本土需求。"},{"title":"CPP杂记","path":"/2025/06/18/CPP/CPP杂记/","content":"全局静态变量、函数内静态变量、attribute((destructor))析构顺序构造析构顺序的不确定性 以及静态函数获取的单例。 C++ 标准规定：同一个编译单元（同一个 cpp 文件）内，静态&#x2F;全局对象的析构顺序与构造顺序相反。 但不同编译单元（不同 cpp 文件&#x2F;so）之间的析构顺序是未定义的。 局部 static（即函数内 static）对象的析构顺序与其定义顺序有关，但也只在同一编译单元内有保证。 若一个变量仅在单个文件中可见，则建议将这个变量声明为静态全局变量，static修饰的静态全局变量仅在当前文件中可见。 如果一个全局变量只被单个函数使用,将其改为该函数的静态局部变量可以进一步限制变量的作用域,提高代码的内聚性,降低耦合度。静态局部变量具有全局寿命但局部作用域的特点, 静态全局变量是存储在**静态数据区的,**而不是栈区,因此静态全局变量的大小不会导致栈溢出。栈溢出通常是由于函数调用层次过深或局部变量过大导致的。 类的内存占用 1.32位系统中虚函数指针为4字节，64位为8字节 2.只需要考虑虚函数指针，虚函数表不计入某个类的资源 3.char占一字节，但是需要考虑内存调用 4.如果有虚继承，则多一个虚基类指针。 5.空类占一个字节（用于标识） 指针好题 int arr[5]&#x3D;{1,2,3,4,5};在这个数组的定义中，通常的理解arr是数组的地址即数组首元素的地址，进一步理解arr是一个int型的指针常量，常量+1地址偏移sizeof(int)，所以arr+1是首元素下一个元素的地址；考虑到这一层就不难理解**&amp;arr*的含义，&amp;arr是对arr取地址，结果也是个地址，只是这个地址的类型是指向有5个int类型数据的数组的指针常量，这个常量+1地址偏移5sizeof(int)。 各级指针算各级的： 主要就是理解&amp; 和 * 的“升级降级”； 链接：https://www.nowcoder.com/exam/test/89156461/submission?examPageSource=Intelligent&pid=62380309&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fintelligent%3FquestionJobId%3D10%26subTabName%3Dintelligent_page%26tagId%3D21000&amp;testclass&#x3D;%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91 Copy and Swap传统做法operator= 12345678910111213141516171819202122class MyString &#123;private: char* data; // 动态分配的字符串public: // 赋值运算符重载 MyString&amp; operator=(const MyString&amp; other) &#123; // 检查自赋值 if (this == &amp;other) &#123; return *this; &#125; // 释放当前对象的资源 delete[] data; // 复制数据 data = new char[std::strlen(other.data) + 1]; std::strcpy(data, other.data); // 返回当前对象的引用 return *this; &#125;&#125;; Copy and Swap 123456789MyString&amp; operator=(const MyString&amp; other) &#123; // 检查自赋值 if (this == &amp;other) &#123; return *this; &#125; MyString tmp&#123;other&#125;; std::swap(data,other.data); return *this;&#125; 优势： 异常安全：传统方法new抛出异常时，对象出于无效状态。data已经被删除，但是分配失败 强异常安全性: 如果一个操作因为异常而失败，程序的状态会回滚到操作之前的样子，就像这个操作从来没执行过一样 代码复用：复用拷贝构造函数 自动资源管理：自动释放tmp资源 C++11 写法 123456MyString&amp; operator=(MyString other) &#123;//值传递 //传入左值：拷贝构造 //传入右值：移动构造 std::swap(data,other.data); return *this; &#125; 移动构造还是拷贝构造？ 左值：叫得出名字 右值：叫不出名字（临时变量，std::move） 左值用拷贝构造，右值用移动构造（偷）"},{"title":"CXL-place-llvm-PGO杂记","path":"/2025/04/23/备忘录/CXL-place-llvm-PGO杂记/","content":"CXL-place-llvm-PGO杂记 记录完成llvmPGO 中的一些知识杂记 1.llvm中的malloc重定向拦截案例：2.复制构造、移动构造、原地构造3.内存分配器的实现https://blog.lfalive.top/2022/02/15/JeMalloc/ http://hydra.azilian.net/Papers/jemalloc.pdf"},{"title":"LLVM explore","path":"/2025/04/23/LLVM/LLVM/","content":"入门llvm笔记 新旧新增pass流程CRTP（奇异递归模板模式）(以下内容基于AI生成后修改) 通常通过继承的方式实现单例模式也是这样，只是不知道叫这个名字 CRTP（Curiously Recurring Template Pattern，奇异递归模板模式）是C++中的一种高级模板编程技术，通过让一个类继承自以自身为模板参数的基类模板，实现静态多态或代码复用。 123template &lt;typename Derived&gt;class Base &#123; /* 基类使用Derived类型 */ &#125;;class MyClass : public Base&lt;MyClass&gt; &#123; /* 派生类将自身作为模板参数传递给基类 */ &#125;; 核心作用1. 静态多态（编译时多态） 动态多态（虚函数）的问题：运行时虚表查找导致性能开销。 CRTP的解决方案：基类在编译时通过模板参数直接调用派生类的方法。 123456789101112131415161718192021template &lt;typename Derived&gt;class Animal &#123;public: void speak() &#123; static_cast&lt;Derived*&gt;(this)-&gt;speakImpl(); // 编译时确定调用 &#125;&#125;;class Cat : public Animal&lt;Cat&gt; &#123;public: void speakImpl() &#123; std::cout &lt;&lt; &quot;Meow &quot;; &#125;&#125;;class Dog : public Animal&lt;Dog&gt; &#123;public: void speakImpl() &#123; std::cout &lt;&lt; &quot;Woof &quot;; &#125;&#125;;// 使用Animal&lt;Cat&gt; cat;cat.speak(); // 输出 &quot;Meow&quot;（无虚函数开销） 2. 代码复用 基类可提供通用逻辑，派生类通过特化实现差异部分。 123456789101112131415161718192021template &lt;typename Derived&gt;class Counter &#123;protected: static int count;public: Counter() &#123; ++count; &#125; static int getCount() &#123; return count; &#125;&#125;;template &lt;typename Derived&gt;int Counter&lt;Derived&gt;::count = 0;// 统计对象实例数的类class Widget : public Counter&lt;Widget&gt; &#123;&#125;;class Gadget : public Counter&lt;Gadget&gt; &#123;&#125;;// 使用Widget w1, w2;Gadget g1;std::cout &lt;&lt; Widget::getCount(); // 输出 2std::cout &lt;&lt; Gadget::getCount(); // 输出 1 CRTP vs 虚函数 特性 CRTP 虚函数 多态时机 编译时 运行时 性能 无额外开销（直接调用） 虚表查找开销 灵活性 类型固定（模板参数需明确） 支持运行时类型动态替换 适用场景 高性能库、框架基础设施 需要运行时动态行为的情况 CRTP的典型应用场景 编译时多态：如数学库中的向量&#x2F;矩阵运算（Eigen库）。 对象计数：统计不同派生类的实例数量。 Mixin模式：为类动态添加功能（如LLVM的PassInfoMixin）。 链式调用：返回派生类引用以实现链式语法（return static_cast&lt;Derived&amp;&gt;(*this);）。 4 LLVM与CPP实现DenseMap与stdMapdyn_cast与RTTI isadef-use user-value为什么llvm中User会继承value 处理器硬件计数pt LBR PEBS"},{"title":"龙蜥CXL讲解-高显扬","path":"/2025/01/06/CXL/龙蜥CXL讲解-高显扬/","content":"CXL技术介绍对视频链接的PPT搬运，方便快速阅读 高显杨 浪潮 综述 协议协议演进 1.1内存拓展 2.0内存赤化 3.0特性 CXL子协议 CXL设备 CXL Fabric 参考VPN，下边两张为单switch CXL RAS特性 内存热插拔？如何避免宕机 CXL初始化 RCRB CXL 1.1跑CXL2实现协议兼容 CXL方案 池化管理：FM中的bind和UnBind 业界方案 补充"},{"title":"OCP China 2024 CXL 论坛学习笔记","path":"/2025/01/06/CXL/OCP-China-2024-CXL-论坛学习笔记/","content":"OCP China 2024 CXL论坛 学习笔记会议链接 阿里云 数据中心高性能Scale Up 互联系统趋势 孔阳 阿里云超高速互联负责人 胡文普 CXL部分 Scale Up 云的角度 关注两个计算 ： 通用计算、GPU计算 通用计算上： 考虑弹性分析：存储上-&gt;云盘技术 网络-&gt;CIPU网络虚拟化 内存上-&gt;CXL GPU上：大模型单次任务，数据并行、流水线并行、tensor并行、专家并行，都具有较高的带宽要求 CXL 机柜内的资源弹性实现需要满足高性能接口、资源共享、极致弹性、软件生态兼容性等要求。CXL特性符合这些要求。CXL将一致性访问从CPU内部拓展到CPU和内存之间，实现多服务器之间的互联。 CXL的演进 GIM ： P2P ： DSP与type3互联，type3可以分配给DSP或者host HBR-&gt;PBR:不止树状、星状、网络状 E3.s 热插拔，便于可拓展 JBOM 大容量 PEMEM ：支持2.0，满足redis实时性持久化等要求 基于 内存与CPU实现资源解耦 CXL在小数据上传输性能大大提高； intel: CXL on Intel Xeon@ Platform 赵森林 CXL overview CXL Specification Summary"},{"title":"Kernel-compile","path":"/2024/12/05/Linux kernel/Kernel-compile/","content":"内核编译123456789101112131415161718192021222324252627282930#查看当前内核版本uname -a#源码获取sudo apt-get install linux-sourcecd /usr/srctar xvf linux-source-*.tar.bz2cd linux-source-*#补丁应用patch -p1 &lt; /path/to/patch.diff#`-p1`选项可能需要根据补丁文件的格式进行调整。make menuconfig #或者oldconfig,本质是配置/usr/src/configmake -j$(nproc)#根据 .config 配置文件编译内核、内核模块和其他必要的文件，生成内核镜像（vmlinuz）和其他相关的文件#编译过程中可能出现每包头文件或者其他错误，可能是版本原因，针对报错解决即可#内核安装#安装过程可能会出现头文件报错或者缺库、或安装完成后缺库，只需要apt安装对应的库就好，make过程中会自动hook#安装内核模块(在运行时可以加载或卸载的模块)#从编译输出的目录（如 lib/modules/&lt;kernel_version&gt;/）,并执行 depmod 来生成模块依赖关系sudo make modules_install#内核镜像（如 vmlinuz）、配置文件（如 config）、符号表文件（如 System.map）和 initrd 镜像安装到 /boot 目录sudo make install#更新启动引导程序sudo update-grup 关于配置选项相关操作，参考：:star::star:Linux 内核动手编译实用指南 KGDB配置编译选项 参考资料KGDB原理分析及远程挂载调试ARM64内核 内核启动参数 1kgdboc=ttyS0,115200 kgdbwait kgdbtcp=192.168.1.2:1234 kgdboc=ttyS0,115200：设置串口调试（可选） kgdbwait：启动时等待调试器连接 kgdbtcp=192.168.1.2:1234：被调试主机的IP和端口 永久修改：/etc/default/grub下GRUB_CMDLINE_LINUX变量 proxmox-boot-toolproxmox-boot-tool，一个脚本，设置启动内核、增删内核等 Proxmox VE（Proxmox Virtual Environment）是一个开源的虚拟化管理平台，专为企业级环境设计，能够管理虚拟机（VM）、容器、存储和集群。 其中 proxmox-boot-tool脚本在内核管理切换过程中比较有用，这里做备份，便于不整体下载Proxmox VE而单独使用此工具，仅供个人学习使用 使用前提是需要先下载Promox VE 先换源/etc/apt/sources.list.d/pve-no-subscription.list 12deb http://mirrors.ustc.edu.cn/proxmox/debian/pve bookworm pve-no-subscriptiondeb http://mirrors.tuna.tsinghua.edu.cn/proxmox/debian/pve bookworm pve-no-subscription 记得把&#x2F;etc&#x2F;apt&#x2F;sources.list.d下原有的源注释掉 kernel add等 在 &#x2F;boot下边找到对应版本号 之后可通过apt search \\install 搜索下载对应的pve版本内核 proxmox-boot-tool下载链接,先下载proxmox-kernel-helper 参考链接： https://kernelnewbies.org/KernelBuild"},{"title":"Hexo","path":"/2024/11/28/Hexo/hexo/","content":"Hexo部署过程中遇到的一些问题图片与Typora兼容网上给了很多方法，尝试没有效果，自己尝试的方案： 卸载插件hexo-asset-image: yarn remove hexo-asset-image,GitHub有修改的对应插件，但是使用无效果 typora配置 Typora新插入图片路径显示为： Hexo部署时正常显示 Hexo不生效问题Hexo部署到github上不生效，网上解决方案说需要除Main或者Master分支以外额外构建一个分支，然后网站推送到这个分支上，实际使用不管用。 首先，只需要维护一个主分支，不需要其他分支； 其次，hexo -d执行以后，main分支中即使已经更新了代码，但是github page更新也需要一段时间，部署频繁会产生排队 仓库主页github-pages上可以观察到生成静态页面的进度。"},{"title":"Neoperf_study","path":"/2024/11/28/Linux kernel/Neoperf-study/","content":"NeoPerf study 本文主要为学习论文《NeoMem: Hardware&#x2F;Software Co-Design for CXL-Native Memory Tiering》的工作，分为三个部分，用户态、内核以及FPGA部分，内核开源仓库地址为： PKUZHOU&#x2F;linux 代码基于linux内核代码6.0开始修改。 由于初步探索linux内核代码，所以没有按照自顶向下的视角分析代码，而是基于git提交记录，借助AI与互联网搜索，平铺遇到的相关知识。版本不断更新…… a naive neoprof drivercommit ID 9bd35383 本次主要在driver目录下提交了一个驱动neoperf: 主要是实现了一些对外设的IO操作 Linux内核配置文件KconfigKconfig文件用于定义内核配置菜单，这些菜单可以在编译内核时启用或禁用特定的功能。 1234#Kconfig文件config NEOPROF#定义了一个名为`NEOPROF`的内核配置选项，将在内核配置菜单中创建选项\tbool &quot;Enable Neoprofiler&quot; #bool类型，是否启用 default n #默认不启用 在内核编译过程中可以在Drivers下查找到 Kconfig有其独特的语法，也是可以一层一层包裹下去：menu、source、endmenu等组成了编译选项配置过程中的树状菜单 Kconfig设置对应的编译变量后，makefile指导构建编译的过程中会利用这些变量，从而实现选择性的编译 neoperf.h主要新增了四个接口，对neoprof设备（此处指Type2-CXL设备）进行访问： 1234567891011/* * The following functions are used to access the neoprof device*/u64 get_nr_hotpages(void);//获取当前系统中的热页数量u64* get_hotpages(void);//获取热页u64 get_hotness_threshold(void);//获取热度阈值void set_hotness_threshold(u64 threshold);//设置热度阈值 neoperf.c驱动开发hello worldneoperf.c 以下部分参考驱动开发知识：https://www.cnblogs.com/downey-blog/p/10500828.html 123456module_init(neoprof_init);module_exit(neoprof_exit);MODULE_LICENSE(&quot;GPL v2&quot;);MODULE_AUTHOR(&quot;PKUZHOU&quot;);MODULE_DESCRIPTION(&quot;Neoprofiler Linux driver&quot;); io地址映射相关知识需要理解 IO端口的编址方式： 包括IO指令的端口映射方式、MMIO的统一内存映射方式 一些常见的IO操作函数 12void * ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags); //memset_io\\memcpy_fromio\\readb 参考：https://blog.csdn.net/do2jiang/article/details/5450839 neomem migration skeletoncommit ID 26cabad18 新增 NeoMem模块: migrate.c主要是提供接口migrate_misplaced_page_no_vma 调用一些mm中的内存操作函数，进行页面隔离、迁移 neomem.h eomem.c主要就是启动 neomem模块（调用core文件中启动守护进程） late_initcall()在内核启动后期适当时间执行，理解module_init等init宏的顺序，在include/linux/init.h中 linux设备驱动加载的先后顺序 neomem_core.c 内存中的各种分配函数 kthread_run内核线程 FPGA端侧模块结构顶层模块： cxltyp3_memexp_ddr4_top-&gt;ed_top_wrapper_typ3 ddr内存参数调整cxl ip考虑了不同ddr的，包括是否支持DBI、内存通道数量等。采用宏的方式区分，设置不同的方式时，需要对ip内通过宏定义来确定相关的内存参数，同时也需要在顶层模块对相关参数进行修改。 .behluohzkyvr{zoom:50%;} .xmhnqigisxho{zoom:50%;} .sstjsufqkjsx{zoom:50%;} 或者通过更改ip文件，重新生成新的IP文件夹 .tgzdcrkvlouj{zoom:50%;} quartus1set_global_assignment -name OPTIMIZATION_MODE &quot;AGGRESSIVE COMPILE TIME&quot; 烧录模式AS Jtag ps 三种烧录模式 Neomem todo代码存在一些可以完善的地方： CXL地址采用硬编码，可以引入设备树或者其他检测CXL物理地址的工具进行优化，参考"},{"title":"linux脚本备忘录","path":"/2024/11/26/备忘录/linux脚本备忘录/","content":"Linux脚本备忘录安装系统后的环境准备添加新用户 123456adduser #封装命令，处理完添加用户的全部过程 su到新用户显示username@hostname~$:useradd #底层命令，什么都没有加,su到新用户显示$:# 生成 8 位强密码PASSWORD=$(openssl rand -base64 6 | cut -c1-8)echo &quot;Password: $PASSWORD&quot; 用户添加sudo组 1234567usermod -aG sudo new_user#加完以后记得:newgrp sudo#作用有3：#1.切换到指定的组上下文#2.即时生效组更改#3.启动一个子 shell 配置sshd12345678#服务端安装apt install ssh-server#配置sudo vim /etc/ssh/sshd_config#重启服务sudo service restart sshd VimVim配置推荐 - ma6174 12wget 47.93.11.51:88/install_vim.shbash install_vim.sh zsh1234567891011121314#安装zshsudo apt install zsh#修改默认shell为zshchsh -s /bin/zsh#安装oh-my-zshsh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;##如果不成功，请执行下面两条命令，成功了就不需要做下面两条wget 47.93.11.51:88/install_zsh.shbash install_zsh.sh#安装zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 历史记录推荐命令插件12##命令自动推荐，根据历史记录git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 命令自动补全12345##命令自动补全插件mkdir ~/.oh-my-zsh/plugins/incrwget http://mimosa-pudica.net/src/incr-0.2.zsh -O ~/.oh-my-zsh/plugins/incr/incr.plugin.zsh##目录自动跳转插件sudo apt install autojump .zshrc配置文件配置12#插件添加zsh-syntax-highlightingplugins=(git zsh-syntax-highlighting) 123456789#设置终端颜色，提示符，及上一条指令返回码提示autoload -U colors &amp;&amp; colorsPROMPT=&quot;%&#123;$fg[red]%&#125;%n%&#123;$reset_color%&#125;@%&#123;$fg[blue]%&#125;%m %&#123;$fg[yellow]%&#125;%1~ %&#123;$reset_color%&#125;%# &quot;RPROMPT=&quot;[%&#123;$fg[yellow]%&#125;%?%&#123;$reset_color%&#125;]&quot;# Useful support for interacting with Terminal.app or other terminal programs[ -r &quot;/etc/zshrc_$TERM_PROGRAM&quot; ] &amp;&amp; . &quot;/etc/zshrc_$TERM_PROGRAM&quot;source ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.plugin.zshsource /usr/share/autojump/autojump.shsource ~/.oh-my-zsh/plugins/incr/incr*.zsh ctags12345#安装sudo apt install ctags #建立索引ctags -I __THROW -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --langmap=c:+.h --languages=c,c++ --links=yes --c-kinds=+p --c++-kinds=+p --fields=+iaS --extra=+q -f ~/.vim/systags /usr/include/* /usr/include/x86_64-linux-gnu/sys/* /usr/include/x86_64-linux-gnu/bits/* /usr/include/arpa/* .vimrc添加索引 1set tags+=~/systags 安装glibc-doc 使用以下命令安装 1sudo apt install glibc-doc 常见路径hostname :/etc/hostname host: /ect/hosts tomcat1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#安装JDK8sudo apt install default-jre -ysudo apt install openjdk-11-jre-headless -ysudo apt install openjdk-8-jre-headless -y #sudo wget https://downloads.apache.org/tomcat/tomcat-8/v8.5.65/bin/apache-tomcat-8.5.65.tar.gzsudo wget https://mirrors.bfsu.edu.cn/apache/tomcat/tomcat-8/v8.5.73/bin/apache-tomcat-8.5.73.tar.gztar zxf apache-tomcat-8.5.73.tar.gzsudo mv apache-tomcat-8.5.73 /usr/local/tomcat#建立软连接sudo ln -s /usr/local/tomcat/bin/* /usr/local/sbin/#启动startup.sh start #端口检查netstat -anput | grep 8080#启动命令startup.sh start #//启动shutdown.sh #//关闭catalina.sh stop #//启动catalina.sh start #//关闭#关闭防火墙sudo ufw disable #tomcat 参数配置vim /usr/local/tomcat/conf/server.xml #.......&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; #将之前8080端口改成8081端口connectionTimeout=&quot;20000&quot; # redirectPort=&quot;8443&quot; /&gt;#目录修 # &lt;Host name=&quot;localhost&quot; appBase=&quot;/opt/www&quot; #将网站根目录改到/opt/www # unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;#更改网站家目录，这里的ROOT必须大写，更改完成后需要重启sudo mkdir /opt/www/ROOT -p mysqlmysql 8.0下载 1wget https://repo.mysql.com//mysql-apt-config_0.8.20-1_all.deb 12345678#MySQL 设置#密码sudo mysql -uroot use mysql;update user set authentication_string=PASSWORD(&quot;自定义密码&quot;) where User=&quot;root&quot;;update user set plugin=&quot;mysql_native_password&quot; where User =&quot;root&quot;;flush privileges;quit; 对于Linux和windows下字符集不兼容的情况，需要替换 • 把文件中的所有的utf8mb4_0900_ai_ci替换为utf8_general_ci• 以及utf8mb4替换为utf8• 如上图所示的位置，上图只是一部分，注意全部替换。 数据库导出 1mysqldump -uroot -p &gt;c:ShareYunAlbum。sql 数据库导入 12use ShareYunAlbum source ~/ShqreYunAlbum.sql 卸载mysql 123456sudo apt purge mysql-* -ysudo rm -rf /etc/mysql/ /var/lib/mysqlsudo apt autoremovesudo apt autorecleansudo apt-get remove mysql-common dpkg -l |grep ^rc|awk &#x27;&#123;print $2&#125;&#x27; |sudo xargs dpkg -P"},{"title":"控台项目与iSet项目已使用Qt技能点整理","path":"/2024/10/15/Qt/技能点整理/","content":"Qt与QML知识总结Qt中的设计模式中间滑动的slider 2. doubleSpinBox3. iSet新建项目的两种模式ListWidget、选中状态设置为图标模式4.QTreeWidget 框架、表头、样式表、代理 Qt QTreeWidget树形控件用法详解_qtreewidget用法_睿科知识云的博客-CSDN博客 2. Qt大模块1. Qt DP指针2. 视图模型机制3. 视图框架4. QStyle 高度自定义实现5. 元对象与信号槽机制6.构建系统7.QInvokeMethod8.国际化3. Qt细节1. 基础控件2. Undo操作3. svg操作4. Qt不在对象树的工具汇总5.Qt中有有用的宏：Q_LIKELY 6.paint在install中绘制 4. Qt锦上添花1. 动画知识2. 拖拽3. 插件机制4.模块化构建5. Qt中的设计模式1. 单例模式2. 责任链模式3. 接口模式4. 适配器模式5.观察者模式， 线程观察、时间压缩 6.全局信号单例转发类 12345678MAINOPERATIONVIEW_EXPORT bool MainOperationView_Init(IISetWidget ** ppWidget, QWidget * parent)&#123; if (ppWidget == nullptr || parent == nullptr) return false; *ppWidget = new CMainOperationView(parent); return true;&#125; 6. C++知识c++11新特性，所有知识点都在这了！ - 知乎 (zhihu.com) this_thread ++ lambda的坑 12345for(int id = enCoef9_Rr ; id &lt;= enCoef9_Bb ;id++)&#123; connect(m_spinBoxs[id],QOverload&lt;double&gt;::of(&amp;QDoubleSpinBox::valueChanged),this,[&amp;](double value)&#123; OnCoefMatrixSlot(id,value); &#125;);&#125; id 恒等于 0 多继承与QOBject private 虚继承 123456789101112131415161718192021class CBase&#123;private:\tvirtual void virtualPrivateFuntion()&#123; std::cout&lt;&lt;&quot;base virtualPrivateFuntion&quot;;\t&#125;&#125;；class CSub :public CBase&#123;\tprivate:\tvirtual void virtualPrivateFuntion() override&#123; std::cout&lt;&lt;&quot;sub virtualPrivateFuntion&quot;;\t&#125;&#125;int main()&#123;\tCBase* pObject = new CSub();\tpObject-&gt;virtualPrivateFuntion();&#125;//结果：sub virtualPrivateFuntion，//结论：子类继承父类的private virtual可以重写 可变参数、变参模板 函数包装器 std::shared_ptrreset、make_shared 右值引用C++反射元编程Metaprogram is a program about a program. 7.杂项QStatusBar插件机制解耦快捷键ISet7.0 接口设计 MVC8.轮子1.单例2.工作线程封装3.stl 迭代器模式和适配器模式报错整理： QMenu 没有添加Action时，不能直接visible或这exec； setGeometry: Unable to set geometry 的一种解决办法是重写sizehint，而不是使用setFixedSize； 工具使用AddressSanitizer（不适用与MinGW）[AddressSanitizer 定位嵌入式c&#x2F;c++内存错误 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/436177229#:~:text=AddressSanitizer （又名 ASan）是 C%2FC%2B%2B 的内存错误检测器。 AddressSanitizer 由 google,的一部分，而从 4.8 版开始逐渐成为 GCC 的一部分。 这也意味着如果交叉编译器版本低于 4.8 ，是无法使用的。) Qt 拾遗 008 在 Qt 中使用 Address Sanitizer - 简书 (jianshu.com) 在Qt中使用gcc 4.8.0的地址消毒剂(Address Sanitizer) MTuner软件【精选】基于MTuner软件进行qt的mingw编译程序的内存泄漏检测_mtuner怎么使用_yantuguiguziPGJ的博客-CSDN博客"}]