[{"title":"CUDAç®—å­ä¼˜åŒ–-GEMM","path":"/2025/09/06/CUDA ç®—å­ä¼˜åŒ–ç³»åˆ—/CUDAç®—å­ä¼˜åŒ–-GEMM/","content":"TongkaioCUDA_Kernel_Samples: CUDA ç®—å­æ‰‹æ’•ä¸é¢è¯•æŒ‡å—","tags":["CUDA.C++"],"categories":["CUDA"]},{"title":"CUDAç®—å­ä¼˜åŒ–-Reduce","path":"/2025/09/06/CUDA ç®—å­ä¼˜åŒ–ç³»åˆ—/CUDAç®—å­ä¼˜åŒ–-Reduce/","content":"æœ¬æ–‡æ˜¯å¯¹å®˜æ–¹reduceä¼˜åŒ–çš„ç²¾ç®€ï¼Œæ–¹ä¾¿ä¸ªäººå¤ä¹ ,è¯¦ç»†å›é¡¾å‚è€ƒçŸ¥ä¹æ·±å…¥æµ…å‡ºç³»åˆ— leetGPU é—®é¢˜è§£å†³ å±•ç¤º reduceçš„7ç§ä¼˜åŒ– V0_0 naiveè·¨æ­¥ç›¸åŠ ï¼Œéå…¨å±€å†…å­˜è®¿é—®ï¼Œ __global__ void reduce_naive(float *g_idata, float *g_odata, unsigned int n) unsigned int idx = blockIdx.x * blockDim.x + threadIdx.x; if (idx = n) return; // ç›´æ¥åœ¨å…¨å±€å†…å­˜ä¸Šè¿›è¡Œè·¨æ­¥å½’çº¦ for (unsigned int stride = 1; stride blockDim.x; stride *= 2) // ç¡®ä¿æ‰€æœ‰å‰ä¸€è½®çš„å†™å…¥å¯¹ä¸‹ä¸€è½®å¯è§ if (threadIdx.x % (2 * stride) == 0) g_idata[idx] += g_idata[idx + stride]; __syncthreads(); // ä¸€ä¸ªçº¿ç¨‹å—çš„ç»“æœå†™å›å…¨å±€å†…å­˜ if (threadIdx.x == 0) g_odata[blockIdx.x] = g_idata[blockIdx.x * blockDim.x]; æ•´ä¸ªè¿‡ç¨‹éƒ½åœ¨è¯»å†™ç¼“æ…¢çš„å…¨å±€å†…å­˜ï¼Œå»¶è¿Ÿå¾ˆé«˜ï¼ŒO(N)æ¬¡æ“ä½œéœ€è¦è®¿é—®å…¨å±€å†…å­˜O(NlogN)æ¬¡å…¨å±€å†…å­˜ï¼Œæ•ˆç‡ä½ V0 shared_memory.ihdbxsphncdg{zoom:50%;} __global__ void reduce0(int *g_idata, int *g_odata) extern __shared__ int sdata[]; // each thread loads one element from global to shared mem\tunsigned int tid = threadIdx.x;\tunsigned int i = blockIdx.x*blockDim.x + threadIdx.x;\tsdata[tid] = g_idata[i]; __syncthreads();\t// do reduction in shared mem\tfor(unsigned int s=1; s blockDim.x; s *= 2) if (tid % (2*s) == 0) sdata[tid] += sdata[tid + s]; __syncthreads(); // write result for this block to global mem\tif (tid == 0) g_odata[blockIdx.x] = sdata[0]; é—®é¢˜ï¼š ä¼šé€ æˆçº¿ç¨‹æŸåˆ†åŒ–ï¼ŒåŒä¸€ä¸ªwarpså†…æ‰§è¡Œçš„æ“ä½œä¸ä¸€è‡´ V1 çº¿ç¨‹æŸåˆ†åŒ–__global__ void reduce1(float *d_in,float *d_out) __shared__ float sdata[THREAD_PER_BLOCK]; //each thread loads one element from global memory to shared mem unsigned int i=blockIdx.x*blockDim.x+threadIdx.x; unsigned int tid=threadIdx.x; sdata[tid]=d_in[i]; __syncthreads(); // do reduction in shared mem for(unsigned int s=1; sblockDim.x; s*=2) int index = 2*s*tid; if(index blockDim.x)//ä¸åŒçº¿ç¨‹æŸæ‰§è¡Œä¸åŒ sdata[index]+=sdata[index+s]; __syncthreads(); // write result for this block to global mem if(tid==0)d_out[blockIdx.x]=sdata[tid]; æœ¬è´¨ï¼Œå°†åŒºåˆ«é€šè¿‡indexè½¬æ¢è¿ç§»åˆ°çº¿ç¨‹æŸä¹‹é—´è€Œä¸æ˜¯çº¿ç¨‹æŸå†…éƒ¨ï¼Œä»¥å‰æ˜¯æ¯ä¸ªçº¿ç¨‹æŸä¸­éƒ½ä¼šå‡ºç°if elseï¼Œé™åˆ¶æ˜¯ä¸€ä¸ªçº¿ç¨‹æŸä¸­çš„ç¨‹åºéƒ½ä¸€èµ·æ‰§è¡Œæˆ–è€…ä¸€èµ·ä¸æ‰§è¡Œï¼ˆæœ€åå‡ è½®é™¤å¤–ï¼‰ ç»§ç»­å‡å®šblockä¸­å­˜åœ¨256ä¸ªthreadï¼Œå³æ‹¥æœ‰256328ä¸ªwarpã€‚å½“è¿›è¡Œç¬¬1æ¬¡è¿­ä»£æ—¶ï¼Œ0-3å·warpçš„indexblockDim.xï¼Œ 4-7å·warpçš„indexblockDim.xã€‚å¯¹äºæ¯ä¸ªwarpè€Œè¨€ï¼Œéƒ½åªæ˜¯è¿›å…¥åˆ°ä¸€ä¸ªåˆ†æ”¯å†…ï¼Œæ‰€ä»¥å¹¶ä¸ä¼šå­˜åœ¨warp divergenceçš„æƒ…å†µã€‚å½“è¿›è¡Œç¬¬2æ¬¡è¿­ä»£æ—¶ï¼Œ0ã€1å·ä¸¤ä¸ªwarpè¿›å…¥è®¡ç®—åˆ†æ”¯ã€‚å½“è¿›è¡Œç¬¬3æ¬¡è¿­ä»£æ—¶ï¼Œåªæœ‰0å·warpè¿›å…¥è®¡ç®—åˆ†æ”¯ã€‚å½“è¿›è¡Œç¬¬4æ¬¡è¿­ä»£æ—¶ï¼Œåªæœ‰0å·warpçš„å‰16ä¸ªçº¿ç¨‹è¿›å…¥åˆ†æ”¯ã€‚æ­¤æ—¶å¼€å§‹äº§ç”Ÿwarp divergenceã€‚é€šè¿‡è¿™ç§æ–¹å¼ï¼Œæˆ‘ä»¬æ¶ˆé™¤äº†å‰3æ¬¡è¿­ä»£çš„warp divergenceã€‚ æ¥è‡ªçŸ¥ä¹ã€Šæ·±å…¥æµ…å‡ºGPUä¼˜åŒ–ç³»åˆ—ã€‹ V2 bankå†²çª0å·å’Œ32å·å…ƒç´ å†²çª __global__ void reduce2(float *d_in,float *d_out) __shared__ float sdata[THREAD_PER_BLOCK]; //each thread loads one element from global memory to shared mem unsigned int i=blockIdx.x*blockDim.x+threadIdx.x; unsigned int tid=threadIdx.x; sdata[tid]=d_in[i]; __syncthreads(); // do reduction in shared mem for(unsigned int s=blockDim.x/2; s0; s=1) if(tid s) sdata[tid]+=sdata[tid+s]; __syncthreads(); // write result for this block to global mem if(tid==0)d_out[blockIdx.x]=sdata[tid]; è®©ä¸€å¼€å§‹çš„è®¿å­˜è·¨åº¦æœ€å¤§ï¼Œæ°å¥½åœ¨å…ƒç´ å¤šçš„æ—¶å€™é”™å¼€ï¼Œä¸€ä¸ªwarpä¸­ä¸ä¼šåŒæ—¶è®¿é—®åŒä¸€ä¸ªbank é—®é¢˜ï¼š ä¸€åŠçš„çº¿ç¨‹æ˜¯ç©ºé—²çš„ V3 ç©ºé—²çº¿ç¨‹ä¼˜åŒ–__global__ void reduce3(float *d_in,float *d_out) __shared__ float sdata[THREAD_PER_BLOCK]; //each thread loads one element from global memory to shared mem unsigned int i=blockIdx.x*(blockDim.x*2)+threadIdx.x; //æ ¸å¿ƒï¼Œæ¯ä¸ªblockå¤„ç†ä¸¤ä¸ªblock unsigned int tid=threadIdx.x; sdata[tid]=d_in[i] + d_in[i+blockDim.x]; __syncthreads(); // do reduction in shared mem for(unsigned int s=blockDim.x/2; s0; s=1) if(tid s) sdata[tid]+=sdata[tid+s]; __syncthreads(); // write result for this block to global mem if(tid==0)d_out[blockIdx.x]=sdata[tid]; V4 å±•å¼€æœ€åä¸€æ¬¡è®¡ç®—å‡å°‘åŒæ­¥__device__ void warpReduce(volatile float* cache,int tid) //volatile çš„ä½œç”¨ï¼šç¦æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–ï¼Œæ¯æ¬¡è®¿é—®éƒ½å¿…é¡»çœŸæ­£ä»å…±äº«å†…å­˜é‡Œå–å€¼/å†™å€¼,é˜²æ­¢ç¼“å­˜åˆ°å¯„å­˜å™¨é‡Œï¼Œç„¶åé‡å¤ä½¿ç”¨å¯„å­˜å™¨çš„å€¼ï¼Œè€Œä¸æ˜¯æ¯æ¬¡éƒ½ä»å…±äº«å†…å­˜è¯»å– //32åˆ°1æ˜¯è·¨åº¦s cache[tid]+=cache[tid+32]; cache[tid]+=cache[tid+16]; cache[tid]+=cache[tid+8]; cache[tid]+=cache[tid+4]; cache[tid]+=cache[tid+2]; cache[tid]+=cache[tid+1];__global__ void reduce4(float *d_in,float *d_out) __shared__ float sdata[THREAD_PER_BLOCK]; //each thread loads one element from global memory to shared mem unsigned int i=blockIdx.x*(blockDim.x*2)+threadIdx.x; unsigned int tid=threadIdx.x; sdata[tid]=d_in[i] + d_in[i+blockDim.x]; __syncthreads(); // do reduction in shared mem for(unsigned int s=blockDim.x/2; s32; s=1) if(tid s) sdata[tid]+=sdata[tid+s]; __syncthreads(); // write result for this block to global mem if(tid32)warpReduce(sdata,tid); if(tid==0)d_out[blockIdx.x]=sdata[tid]; ä¸€ä¸ªSIMDå•å…ƒå·¥ä½œæ—¶ï¼Œé¿å…__syncthreadsåŒæ­¥ V5 æš´åŠ›forå¾ªç¯å±•å¼€å…¶å®ä¸ªäººæ— æ³•ç†è§£ï¼Œç°ä»£ç‰ˆæœ¬ä¸­æ„Ÿè§‰ä¸éœ€è¦äº† template unsigned int blockSize__device__ void warpReduce(volatile float* cache,int tid) if(blockSize = 64)cache[tid]+=cache[tid+32]; if(blockSize = 32)cache[tid]+=cache[tid+16]; if(blockSize = 16)cache[tid]+=cache[tid+8]; if(blockSize = 8)cache[tid]+=cache[tid+4]; if(blockSize = 4)cache[tid]+=cache[tid+2]; if(blockSize = 2)cache[tid]+=cache[tid+1];template unsigned int blockSize__global__ void reduce5(float *d_in,float *d_out) __shared__ float sdata[THREAD_PER_BLOCK]; //each thread loads one element from global memory to shared mem unsigned int i=blockIdx.x*(blockDim.x*2)+threadIdx.x; unsigned int tid=threadIdx.x; sdata[tid]=d_in[i] + d_in[i+blockDim.x]; __syncthreads(); // do reduction in shared mem if(blockSize=512) if(tid256) sdata[tid]+=sdata[tid+256]; __syncthreads(); if(blockSize=256) if(tid128) sdata[tid]+=sdata[tid+128]; __syncthreads(); if(blockSize=128) if(tid64) sdata[tid]+=sdata[tid+64]; __syncthreads(); // write result for this block to global mem if(tid32)warpReduceblockSize(sdata,tid); if(tid==0)d_out[blockIdx.x]=sdata[tid]; V6ç‰ˆæœ¬å’Œæ–‡ç« ä¸­è®²çš„æœ‰äº›å·®è·ï¼Œæœ¬è´¨ä¸€ä¸ªçº¿ç¨‹å¤„ç†å¤šä¸ªæ•°ã€‚ template unsigned int blockSize, int NUM_PER_THREAD__global__ void reduce6(float *d_in,float *d_out, unsigned int n) __shared__ float sdata[blockSize]; // each thread loads NUM_PER_THREAD element from global to shared mem unsigned int tid = threadIdx.x; unsigned int i = blockIdx.x * (blockSize * NUM_PER_THREAD) + threadIdx.x; sdata[tid] = 0; #pragma unroll for(int iter=0; iterNUM_PER_THREAD; iter++) sdata[tid] += d_in[i+iter*blockSize]; __syncthreads(); // do reduction in shared mem if (blockSize = 512) if (tid 256) sdata[tid] += sdata[tid + 256]; __syncthreads(); if (blockSize = 256) if (tid 128) sdata[tid] += sdata[tid + 128]; __syncthreads(); if (blockSize = 128) if (tid 64) sdata[tid] += sdata[tid + 64]; __syncthreads(); if (tid 32) warpReduceblockSize(sdata, tid); // write result for this block to global mem if (tid == 0) d_out[blockIdx.x] = sdata[0]; reduce6THREAD_PER_BLOCK, NUM_PER_THREADGrid,Block(d_a, d_out, N); V7 shuffleä¼˜åŒ–todo How_to_optimize_in_GPUreducereduce_v7_shuffle.cu at master Â· Liu-xiandongHow_to_optimize_in_GPU é‡‡ç”¨äº†shuffleæŒ‡ä»¤ä¹‹åï¼Œwarpå†…çš„çº¿ç¨‹å¯ä»¥ç›´æ¥å¯¹å…¶ä»–çº¿ç¨‹çš„å¯„å­˜å™¨è¿›è¡Œè®¿å­˜ã€‚é€šè¿‡è¿™ç§æ–¹å¼å¯ä»¥å‡å°‘è®¿å­˜çš„å»¶æ—¶ã€‚ #define THREAD_PER_BLOCK 256#define WARP_SIZE 32template unsigned int blockSize__device__ __forceinline__ float warpReduceSum(float sum) if (blockSize = 32)sum += __shfl_down_sync(0xffffffff, sum, 16); // 0-16, 1-17, 2-18, etc. if (blockSize = 16)sum += __shfl_down_sync(0xffffffff, sum, 8);// 0-8, 1-9, 2-10, etc. if (blockSize = 8)sum += __shfl_down_sync(0xffffffff, sum, 4);// 0-4, 1-5, 2-6, etc. if (blockSize = 4)sum += __shfl_down_sync(0xffffffff, sum, 2);// 0-2, 1-3, 4-6, 5-7, etc. if (blockSize = 2)sum += __shfl_down_sync(0xffffffff, sum, 1);// 0-1, 2-3, 4-5, etc. return sum;template unsigned int blockSize, int NUM_PER_THREAD__global__ void reduce7(float *d_in,float *d_out, unsigned int n) float sum = 0; // each thread loads one element from global to shared mem unsigned int tid = threadIdx.x; #pragma unroll //çº¿ç¨‹çº§å±€éƒ¨è§„çº¦ for(int iter=0; iterNUM_PER_THREAD; iter++) sum += d_in[i+iter*blockSize]; // Shared mem for partial sums (one per warp in the block) static __shared__ float warpLevelSums[WARP_SIZE]; const int laneId = threadIdx.x % WARP_SIZE; const int warpId = threadIdx.x / WARP_SIZE; sum = warpReduceSumblockSize(sum); if(laneId == 0 )warpLevelSums[warpId] = sum; __syncthreads(); // read from shared memory only if that warp existed sum = (threadIdx.x blockDim.x / WARP_SIZE) ? warpLevelSums[laneId] : 0; // Final reduce using first warp if (warpId == 0) sum = warpReduceSumblockSize/WARP_SIZE(sum); // write result for this block to global mem if (tid == 0) d_out[blockIdx.x] = sum;reduce7THREAD_PER_BLOCK, NUM_PER_THREADGrid,Block(d_a, d_out, N); ä¼˜åŒ–æ€»ç»“ ä½¿ç”¨å…±äº«å†…å­˜ å‡å°‘çº¿ç¨‹æŸåˆ†åŒ–ï¼ˆå·®å¼‚ä¿ç•™åœ¨çº¿ç¨‹æŸä¹‹é—´ï¼‰ å‡å°‘bankå†²çªï¼›å˜æ¢è§’æ ‡ï¼Œé”™ä½ï¼ˆ+1ä¸è·¨åº¦é”™ä½ï¼‰ å‡å°‘ç©ºé—²çº¿ç¨‹ï¼Œä¸€ä¸ªçº¿ç¨‹å–ä¸¤ä¸ªå…ƒç´  å‡å°‘__syncthreadsåŒæ­¥ï¼Œä¸€ä¸ªSIMDå†…å¯ä»¥ä¸ä½¿ç”¨ åˆç†è®¾ç½®blockæ•°é‡ ä½¿ç”¨shuffleæŒ‡ä»¤","tags":["CUDA.C++"],"categories":["CUDA"]},{"title":"CUDAç®—å­ä¼˜åŒ–-SoftMax","path":"/2025/09/06/CUDA ç®—å­ä¼˜åŒ–ç³»åˆ—/CUDAç®—å­ä¼˜åŒ–-SoftMax/","content":"TongkaioCUDA_Kernel_Samples: CUDA ç®—å­æ‰‹æ’•ä¸é¢è¯•æŒ‡å—","tags":["CUDA.C++"],"categories":["CUDA"]},{"title":"GGMLæºç æµ…æ(1) åŸºç¡€æ•°æ®ç»“æ„ã€å†…å­˜ç®¡ç†ã€åç«¯ç®¡ç†","path":"/2025/08/01/GGMLæºç æµ…æ/","content":"GGML æºç æµ…æï¼ˆ1ï¼‰å‰è¨€1.é˜…è¯»è·¯çº¿ â€‹\t1.å†…å­˜ç®¡ç†ï¼šä¸ä½¿ç”¨åç«¯æ—¶ï¼ˆå‚è§examplesimple-ctxï¼‰ä»‹ç»ggmlä¸­çš„é‡è¦æ•°æ®ç»“æ„ä»¥åŠå†…å­˜ç®¡ç† â€‹\t2.åç«¯çš„è®¾è®¡é€»è¾‘ 3.åŸºäºgpt-2å­¦ä¹ æ¨¡å‹æ„å»ºè¿‡ç¨‹ä¸­æƒé‡ä¸kv-cacheç®¡ç† 2.é‡ç‚¹ â€‹\t1.å…³äºggml-contextçš„ç›¸å…³æ•°æ®ç»“æ„ï¼Œéœ€è¦ç†è§£ggml-contxtä¸­å†…å­˜åˆ†é…ç»“æ„ï¼Œå¯ä»¥å‚çœ‹å…¶ä¸­ç»™çš„å‡ å¼ å›¾ â€‹\t2.é€šè¿‡è¾“å‡ºç»“æœåæ¨æ„å»ºè®¡ç®—å›¾ â€‹\t3.åç«¯è®¾è®¡ä¸­ï¼Œä¸€å®šç”¨é¢å‘å¯¹è±¡çš„æ–¹å¼æ¥æ€è€ƒç›¸å…³åç«¯å®ç°ï¼Œå…¶å®å°±æ˜¯ç”¨cå®ç°äº†C++çš„é¢å‘å¯¹è±¡ï¼Œè‡ªå·±å®ç°äº†è™šå‡½æ•°è¡¨ï¼Œç§æœ‰æˆå‘˜å˜é‡ï¼ˆvoid*) â€‹\t4.ä¸€æ¬¡æ“ä½œçš„é€»è¾‘ å¤§ä½¬æ•™ç¨‹ æ·±å…¥ç†è§£GGMLï¼ˆä¸€ï¼‰æ¨¡å‹å’Œè®¡ç®—å›¾ - çŸ¥ä¹ 1.æ ¸å¿ƒæ•°æ®ç»“æ„1.1ggml_contextstruct ggml_context size_t mem_size; void* mem_buffer; //cpué‡‡ç”¨ç”±poxsi_alignåˆ†é…çš„å†…å­˜å¯¹é½å†…å­˜ï¼Œå¯¹äºä¸åŒçš„åç«¯ï¼Œåˆ†é…ä¸åŒçš„å†…å­˜ bool mem_buffer_owned;//å¤–éƒ¨åˆ†é…è¿˜æ˜¯å±äºæœ¬å¤„ï¼Œå†³å®šå†…å­˜åˆ†é…æƒï¼Ÿ bool no_alloc; bool no_alloc_save; // this is used to save the no_alloc state when using scratch buffers int n_objects; struct ggml_object * objects_begin;//ggml_objectç»´æŠ¤çš„æ˜¯ä¸€ä¸ªé“¾è¡¨ struct ggml_object * objects_end; struct ggml_scratch scratch; struct ggml_scratch scratch_save;; struct ggml_object size_t offs; size_t size; struct ggml_object * next; enum ggml_object_type type; char padding[4]; ; ggml_contextæ˜¯æœ€æ ¸å¿ƒçš„æ•°æ®ç»“æ„ï¼Œæ‰€æœ‰çš„å¼ é‡ã€è®¡ç®—å›¾éƒ½ä¾èµ–äºè¿™ä¸ªæ•°æ®ç»“æ„: mem_sizeè¡¨ç¤ºggml_initæ—¶åˆ†é…ä¸€å—å¤šå¤§çš„å†…å­˜ï¼Œåç»­çš„å¼ é‡éƒ½ä»è¿™å—å†…å­˜ä¸­åˆ†é…ç©ºé—´ï¼Œé¿å…åå¤çš„malloc mem_buffer_ownedè¡¨ç¤ºè¿™ä¸ªmem_bufferæ˜¯å¤–éƒ¨ä¼ è¿›æ¥çš„è¿˜æ˜¯è‡ªå·±åˆ†é…çš„ï¼Œå†³å®šåˆ†é…æƒï¼Œé¿å…è¯¯é‡Šæ”¾ ã€‚ no_mallocæ˜¯è¡¨ç¤ºå¼ é‡åˆ†é…å†…å­˜çš„æ—¶å€™æ˜¯çœŸçš„åˆ†é…å†…å­˜è¿˜æ˜¯ä»…ä»…ç”¨äºå ä½ no_alloc_saveä½¿ç”¨äº†scratchä¼šå¼ºåˆ¶å¼€å¯å†…å­˜ï¼Œæ‰€ä»¥éœ€è¦æš‚å­˜ä¸€ä¸‹no_malloc scratchæ˜¯ä¸€å—ä¸´æ—¶å†…å­˜ï¼Œç”¨äºå­˜æ”¾ä¸­é—´çš„ä¸´æ—¶ç»“æœã€ç¼“å­˜ scratch_saveæš‚å­˜scatchçš„çŠ¶æ€ n_objectsä»¥åŠä¸¤ä¸ªæŒ‡é’ˆç»´æŠ¤äº†ä¸€ä¸ªå¯¹è±¡åŒå‘é“¾è¡¨ï¼Œè®°å½•æ‰€æœ‰å·²åˆ›å»ºçš„å¯¹è±¡ï¼Œå¯ä»¥çœ‹åˆ°è¿™ä¸ªggml_objectä¸»è¦ç»´æŠ¤äº†åç§»offså’Œsize,å®¹æ˜“ç†è§£å®é™…æ•°æ®å°±æ˜¯åˆ†é…åœ¨ggml_contextçš„bufferä¸­ï¼Œè€Œè¦æ‰¾åˆ°è¿™äº›æ•°æ®å°±é€šè¿‡objecté“¾è¡¨æ¥è¿›è¡ŒæŸ¥æ‰¾ä¸åˆ†é…ã€‚ ggml_objectè¿™ä¸ªç»“æ„ä½“æœ¬æœ¬èº«ä¹Ÿæ˜¯åˆ†é…åœ¨ggml_context.mem_bufferä¸Šçš„ï¼Œä¹‹åè·Ÿç€å¯¹åº”çš„æ•°æ®ã€‚ ggml-object-ggml_tensor-tensor_data è¿™ä¸€éƒ¨åˆ†çš„å®ç°å…·ä½“æŸ¥çœ‹ggml_new_object static struct ggml_object * ggml_new_object(struct ggml_context * ctx, enum ggml_object_type type, size_t size) // always insert objects at the end of the contexts memory pool struct ggml_object * obj_cur = ctx-objects_end; const size_t cur_offs = obj_cur == NULL ? 0 : obj_cur-offs; const size_t cur_size = obj_cur == NULL ? 0 : obj_cur-size; const size_t cur_end = cur_offs + cur_size; // align to GGML_MEM_ALIGN size_t size_needed = GGML_PAD(size, GGML_MEM_ALIGN); char * const mem_buffer = ctx-mem_buffer; struct ggml_object * const obj_new = (struct ggml_object *)(mem_buffer + cur_end); if (cur_end + size_needed + GGML_OBJECT_SIZE ctx-mem_size) GGML_PRINT(%s: not enough space in the contexts memory pool (needed %zu, available %zu) , __func__, cur_end + size_needed, ctx-mem_size); assert(false); return NULL; *obj_new = (struct ggml_object) .offs = cur_end + GGML_OBJECT_SIZE, .size = size_needed, .next = NULL, .type = type, ; GGML_ASSERT_ALIGNED(mem_buffer + obj_new-offs); if (obj_cur != NULL) obj_cur-next = obj_new; else // this is the first object in this context ctx-objects_begin = obj_new; ctx-objects_end = obj_new; //printf(%s: inserted new object at %zu, size = %zu , __func__, cur_end, obj_new-size); return obj_new; å®é™…ä½¿ç”¨è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥çœ‹åˆ°æ‰€æœ‰çš„æ“ä½œéƒ½æŒ‚é åˆ°ggml_contextä¸Š å†…å­˜åˆ†é…ï¼š struct ggml_init_params params = .mem_size = 64 * 1024 * 1024, .mem_buffer = malloc(mem_size), .no_alloc = false;struct ggml_context * ctx = ggml_init(params); å¼ é‡åˆ†é…ï¼š struct ggml_tensor * a = ggml_new_tensor_1d(ctx, GGML_TYPE_F32, 10); â€‹\tå¯ä»¥æŸ¥çœ‹ggml.c/ggml_new_tensor_impl()å…·ä½“å®ç°ï¼Œæœ€ç»ˆåˆ†é…çš„tensorçš„data,æŒ‡é’ˆæŒ‡å‘çš„æ•°æ®è¿˜æ˜¯ggml_contxt.mem_bufä¸­çš„å¯¹åº”åç§»é‡ã€‚ è®¡ç®—æ“ä½œï¼š struct ggml_tensor * c = ggml_add(ctx, a, b); æ‰§è¡Œè®¡ç®—å›¾ï¼š struct ggml_cgraph graph = ggml_build_forward(c);ggml_graph_compute_with_ctx(ctx, graph, n_threads); ä¸‹è¾¹å°çº¢ä¹¦åšä¸»**TransormerX**ç»˜åˆ¶çš„è¿™å‡ å¼ å›¾ æ¸…æ™° ç¾è§‚çš„å±•ç¤ºäº†å†…å­˜åˆ†é…æƒ…å†µï¼š .rukpuhzkixwe{zoom:80%;} .wbojeilyatoh{zoom:67%;} .slxvfjefcmmk{zoom:50%;} é™¤äº†å›¾ä¸­ç»˜åˆ¶çš„tensoræ˜¯æŒ‰ç…§è¿™æ ·çš„å†…å­˜åˆ†å¸ƒä»¥å¤–ï¼Œå…¶ä»–ç±»å‹graphã€workbufferç­‰ç±»å‹çš„objectéƒ½æ˜¯é‡‡ç”¨è¿™æ ·çš„å†…å­˜æ’å¸ƒï¼Œå³ï¼šobjectç»“æ„ä½“-å¯¹åº”ç±»å‹ç»“æ„ä½“ï¼ˆtensor\\graph)-ç›¸åº”data æ¯”å¦‚å›¾çš„å­˜å‚¨å°±æ˜¯object-ggml_cgraph(ç»“æ„ä½“æœ¬èº«)-èŠ‚ç‚¹å¶å­ç­‰æŒ‡é’ˆæ•°ç»„ WORK_BUFFERå°±æ˜¯objectâ€“work_data ï¼ˆç›´æ¥è¢«cplanä¸­çš„æŒ‡é’ˆæ‰€æŒ‡ï¼‰ 1.2ggml_stateæ•´ä¸ªggmlç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­æœ‰ä¸€ä¸ªå…¨å±€çš„g_state. static struct ggml_state g_state;#define GGML_MAX_CONTEXTS 64struct ggml_state struct ggml_context_container contexts[GGML_MAX_CONTEXTS]; struct ggml_numa_nodes numa;;struct ggml_context_container bool used; struct ggml_context context;;struct ggml_numa_nodes enum ggml_numa_strategy numa_strategy; struct ggml_numa_node nodes[GGML_NUMA_MAX_NODES]; uint32_t n_nodes; uint32_t total_cpus; // hardware threads on system uint32_t current_node; // node on which main process is execting#if defined(__gnu_linux__) cpu_set_t cpuset; // cpuset from numactl#else uint32_t cpuset; // no NUMA support outside of Linux at this time. Use a portable datatype#endif; ggml_stateä¸­åŒ…å«äº†ä¸€ä¸ªggml_contextï¼ˆé¢å¤–åŠ ä¸€ä¸ªusedæ ‡è¯†è€Œå·²ï¼‰æ•°ç»„ã€‚ åœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨ggml_initæ—¶ï¼Œä¼šå¯¹g_stateè¿›è¡Œåˆå§‹åŒ–ã€‚ //ä½äºggml.c/ggml_initif (is_first_call) //.....åˆå§‹åŒ–æ¿€æ´»å‡½æ•°è¡¨ //åˆå§‹åŒ–g_state g_state = (struct ggml_state) /*.contexts =*/ 0 , /*.numa =*/ .n_nodes = 0, .total_cpus = 0, , ; for (int i = 0; i GGML_MAX_CONTEXTS; ++i) g_state.contexts[i].used = false; äºæ˜¯å¯ä»¥ç†è§£åˆ°ï¼Œç¨‹åºè¿è¡Œæ—¶ï¼Œä¼šåœ¨å…¨å±€é™æ€å†…å­˜åŒºåˆ†é…ä¸€ä¸ªg_state,åŒ…å«äº†ä¸€ä¸ªg_contextæ•°ç»„ï¼Œæ¯æ¬¡ggml_initçš„æ—¶å€™å°±å»g_stateä¸­æ‰¾ä¸€ä¸ªæ²¡æœ‰ä½¿ç”¨çš„g_context,è·å¾—å…¶æŒ‡é’ˆåè¿›è¡Œæ¯ä¸ªå­—æ®µçš„åˆå§‹åŒ–ä»¥åŠå¡«å……ï¼Œä¹‹åå°±ä¾é è¿™ä¸ªggml_contextè¿›è¡Œä¸€æ¬¡ä¸€æ¬¡ã€‚ ç›®å‰ä¸ªäººçœ‹ä»£ç è§‰å¾—æ¯æ¬¡æ¨¡å‹æ‰§è¡Œåªéœ€è¦ä¸€ä¸ªggml_conterxtï¼Œä½†æ˜¯ç»™äº†ä¸€ä¸ª64ä¸ªggml_contextç»„æˆçš„æ•°ç»„ï¼Œæ˜¯å› ä¸ºå¯èƒ½éœ€è¦æ”¯æŒæ¨¡å‹çš„å¹¶è¡Œï¼ˆè¿™ä¸ªè§‚ç‚¹å‚è€ƒGPTï¼‰ 1.3ggml_tensor// n-dimensional tensor struct ggml_tensor enum ggml_type type; //æ•°æ®ç±»å‹ GGML_DEPRECATED(enum ggml_backend_type backend, use the buffer type to find the storage location of the tensor); struct ggml_backend_buffer * buffer;//ä¸€ä¸ªè¡¨ç¤ºæ•°æ®å®é™…å­˜å‚¨çš„å†…å­˜åç«¯ï¼Œå¤šæ€å®ç°ï¼Œä¸€ä¸ªé‡è¦çš„ç»“æ„ä½“ int64_t ne[GGML_MAX_DIMS]; // number of elements//æ¯ä¸€ç»´çš„å…ƒç´ ä¸ªæ•° size_t nb[GGML_MAX_DIMS]; // stride in bytes: //æ¯ä¸€ä½èµ°åˆ°ä¸‹ä¸€ä¸ªå…ƒç´ çš„å­—èŠ‚æ•° // nb[0] = ggml_type_size(type) // nb[1] = nb[0] * (ne[0] / ggml_blck_size(type)) + padding // nb[i] = nb[i-1] * ne[i-1] // compute data enum ggml_op op;//è¿™ä¸ªtensoræ˜¯é€šè¿‡ä»€ä¹ˆæ“ä½œè®¡ç®—å¾—åˆ°çš„ // op params - allocated as int32_t for alignment int32_t op_params[GGML_MAX_OP_PARAMS / sizeof(int32_t)]; //å­˜å‚¨å½“å‰opçš„å‚æ•°op = CONV2D æ—¶ï¼Œå¯èƒ½å­˜å‚¨ kernel sizeã€stride int32_t flags; struct ggml_tensor * grad; //å¦‚æœå½“å‰å¼ é‡æ”¯æŒåå‘ä¼ æ’­ï¼Œåˆ™å­˜å‚¨æ¢¯åº¦å¼ é‡ struct ggml_tensor * src[GGML_MAX_SRC]; //å½“å‰å¼ é‡æ˜¯æŸä¸ªå¼ é‡çš„è¿ç®—ç»“æœï¼Œåˆ™è®°å½•è¾“å…¥å¼ é‡ // source tensor and offset for views struct ggml_tensor * view_src; size_t view_offs; void * data;//å®é™…å¼ é‡çš„æ•°æ®æŒ‡é’ˆï¼Œé€šå¸¸æŒ‡å‘ggml_context char name[GGML_MAX_NAME]; void * extra; // extra things e.g. for ggml-cuda.cu // char padding[4]; ; è¿™é‡Œæœ‰ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„æ¦‚å¿µæ˜¯view,viewä¸ä¼šä¿¡åˆ†é…å†…å­˜ã€‚ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼šå¦‚æœä¸€ä¸ªçŸ­å‘é‡æ˜¯ä¸€ä¸ªé•¿å‘é‡çš„å­å‘é‡ï¼Œå¯ä»¥ç†è§£ä¸ºçŸ­å‘é‡æ˜¯é•¿å‘é‡çš„å­å‘é‡ï¼Œä¹Ÿå°±æ˜¯é•¿å‘é‡çš„è§†å›¾ï¼Œåˆ†é…çŸ­å‘é‡æ—¶ï¼Œå¯ä»¥åˆ©ç”¨é•¿å‘é‡å·²ç»åˆ†é…çš„å†…å­˜ï¼Œä»è€Œé¿å…äº†å†…å­˜çš„åˆ†é…ã€‚ 1.4 ggml_cgraphstruct ggml_cgraph int size; int n_nodes;//èŠ‚ç‚¹ int n_leafs;//å¶å­èŠ‚ç‚¹æ•° struct ggml_tensor ** nodes;//ä¸­é—´èŠ‚ç‚¹æ•° struct ggml_tensor ** grads; struct ggml_tensor ** leafs;//å¶å­èŠ‚ç‚¹ struct ggml_hash_set visited_hash_set;//åå‘æ„å»ºä¸­ hashå»é‡ enum ggml_cgraph_eval_order order; ; 2.æ ¸å¿ƒæ“ä½œ2.1æ¨¡å‹åŠ è½½ggufç»“æ„ä¸è§£æggufå®šä¹‰äº†æ¨¡å‹çš„æƒé‡ä¿å­˜æ–¹å¼ï¼Œä»¥ä¸‹ä¸ºggufçš„ç»“æ„ ä¸»è¦å¯ä»¥åˆ†ä¸ºä»¥ä¸‹4éƒ¨åˆ†ï¼š 1.header åŒ…å«æ¨¡å¼ï¼Œtensoræ•°é‡ã€kvå…ƒæ•°æ®æ•°ã€ç‰ˆæœ¬ç­‰ 2.æ¨¡å‹å…ƒæ•°æ®ï¼ˆKVè¡¨ç¤ºï¼‰ 3.æ¯ä¸ªtensorçš„ä¿¡æ¯ï¼ˆoffsetç­‰ï¼Œä¸åŒ…å«tensorçš„å€¼ï¼‰ 4.tensorçš„å€¼ æ–‡ä»¶ggml.cä¸­ï¼Œå®šä¹‰äº†ggufç›¸å…³çš„ç»“æ„ä½“ï¼Œå…¶ä¸­gguf_contextå¯¹åº”äºä¸€ä¸ªæ–‡ä»¶ï¼ŒåŒ…å«headerã€kvã€tensor_infoç­‰ union gguf_value uint8_t uint8; int8_t int8; uint16_t uint16; int16_t int16; uint32_t uint32; int32_t int32; float float32; uint64_t uint64; int64_t int64; double float64; bool bool_; struct gguf_str str; struct enum gguf_type type; uint64_t n; // GGUFv2 void * data; arr;;struct gguf_kv struct gguf_str key; enum gguf_type type; union gguf_value value;;struct gguf_header char magic[4]; uint32_t version; uint64_t n_tensors; // GGUFv2 uint64_t n_kv; // GGUFv2;struct gguf_tensor_info struct gguf_str name; uint32_t n_dims; uint64_t ne[GGML_MAX_DIMS]; enum ggml_type type; uint64_t offset; // offset from start of `data`, must be a multiple of `ALIGNMENT` // for writing API const void * data; size_t size;;struct gguf_context struct gguf_header header; struct gguf_kv * kv; struct gguf_tensor_info * infos; size_t alignment; size_t offset; // offset of `data` from beginning of file size_t size; // size of `data` in bytes //uint8_t * padding; void * data;; ggml.c/gguf_init_from_fileå®ç°äº†ä»æ–‡ä»¶åŠ è½½æ¨¡å‹åˆ°ç»“æ„ä½“ä¸­ 2.2è®¡ç®—å›¾ï¼ˆå‰å‘å›¾ï¼‰æ„å»ºä»¥simple-ctxä¸ºä¾‹è¯´æ˜è®¡ç®—å›¾æ„å»ºæµç¨‹ struct ggml_cgraph * build_graph(const simple_model model) struct ggml_cgraph * gf = ggml_new_graph(model.ctx); // result = a*b^T struct ggml_tensor * result = ggml_mul_mat(model.ctx, model.a, model.b); ggml_build_forward_expand(gf, result); return gf;struct ggml_tensor * ggml_mul_mat( struct ggml_context * ctx, struct ggml_tensor * a, struct ggml_tensor * b) GGML_ASSERT(ggml_can_mul_mat(a, b)); GGML_ASSERT(!ggml_is_transposed(a)); bool is_node = false; if (a-grad || b-grad) is_node = true; const int64_t ne[4] = a-ne[1], b-ne[1], b-ne[2], b-ne[3] ; struct ggml_tensor * result = ggml_new_tensor(ctx, GGML_TYPE_F32, 4, ne); result-op = GGML_OP_MUL_MAT; result-grad = is_node ? ggml_dup_tensor(ctx, result) : NULL; result-src[0] = a; result-src[1] = b; return result; ggml_new_graphä¼šåœ¨ggml-contxtä¸­ç›¸å…³çš„å†…å­˜åŒºåŸŸåˆ†é…ggml_cgraphçš„å†…å­˜ï¼Œè¿›è¡Œåˆå§‹åŒ–ï¼› è€Œåè¿›è¡Œå®é™…çš„ç®—å­æ„å»ºï¼Œè¿™ä¸ªè¿‡ç¨‹æ¯ä¸€æ­¥å¾—åˆ°çš„è¾“å‡ºå¼ é‡ä¼šè®°å½•å¯¹åº”çš„è¾“å…¥ã€ä»¥åŠæ“ä½œç±»å‹ï¼Œå‚ç…§ä¸Šè¾¹çš„ggml_tensorçš„æ•°æ®ç»“æ„ æœ€åæ ¸å¿ƒçš„å‡½æ•°æ˜¯ggml_build_forward_expandï¼Œè¿™ä¸ªè¿‡ç¨‹æ ¹æ®è¾“å‡ºçš„tensorï¼Œåå‘æ·»åŠ graphä¸­çš„è®¡ç®—èŠ‚ç‚¹ã€‚ å³æµç¨‹ä¸ºæ‰‹åŠ¨è®¾ç½®æœ€ç»ˆè¾“å‡ºtensorçš„è¿‡ç¨‹ï¼Œåˆ©ç”¨tensorä¸­çš„å˜é‡åå‘æ„å»ºé™æ€è¾“å‡ºå›¾ï¼ŒæˆåŠŸåœ¨graphä¸­æ·»åŠ ä¸åŒçš„èŠ‚ç‚¹ï¼Œå®Œæˆgraphçš„ç»´æŠ¤ å…·ä½“æ„å»ºè¿‡ç¨‹è§ï¼šggml.c/ggml_visit_parentsç®€è¨€ä¹‹å°±æ˜¯ååºéå†+hashå»é‡ï¼Œå¡«å……cgraphä¸­çš„ç›¸å…³æŒ‡é’ˆ static void ggml_visit_parents(struct ggml_cgraph * cgraph, struct ggml_tensor * node) if (node-grad == NULL) // this usually happens when we generate intermediate nodes from constants in the backward pass // it can also happen during forward pass, if the user performs computations with constants if (node-op != GGML_OP_NONE) //GGML_PRINT_DEBUG(%s: warning: node %p has no grad, but op %d , __func__, (void *) node, node-op); // check if already visited if (ggml_hash_insert(cgraph-visited_hash_set, node) == GGML_HASHSET_ALREADY_EXISTS) return; for (int i = 0; i GGML_MAX_SRC; ++i) const int k = (cgraph-order == GGML_CGRAPH_EVAL_ORDER_LEFT_TO_RIGHT) ? i : (cgraph-order == GGML_CGRAPH_EVAL_ORDER_RIGHT_TO_LEFT) ? (GGML_MAX_SRC-1-i) : /* unknown order, just fall back to using i*/ i; if (node-src[k]) ggml_visit_parents(cgraph, node-src[k]); if (node-op == GGML_OP_NONE node-grad == NULL) // reached a leaf node, not part of the gradient graph (e.g. a constant) GGML_ASSERT(cgraph-n_leafs cgraph-size); if (strlen(node-name) == 0) ggml_format_name(node, leaf_%d, cgraph-n_leafs); cgraph-leafs[cgraph-n_leafs] = node; cgraph-n_leafs++; else GGML_ASSERT(cgraph-n_nodes cgraph-size); if (strlen(node-name) == 0) ggml_format_name(node, node_%d, cgraph-n_nodes); cgraph-nodes[cgraph-n_nodes] = node; if (cgraph-grads) cgraph-grads[cgraph-n_nodes] = node-grad; cgraph-n_nodes++; åå‘å›¾çš„æ„å»ºè¿‡ç¨‹æ›´åŠ å¤æ‚ä¸€äº›ï¼Œä¼šåŒæ—¶ä¿å­˜ç›¸å…³çš„æ¢¯åº¦ä¿¡æ¯ã€‚ åå‘å›¾çš„æ„å»ºä¾èµ–å‰å‘å›¾ï¼Œåå‘å›¾é æ‹·è´äº†å‰å‘è®¡ç®—å›¾ï¼Œ 2.3è®¡ç®—æ ¸å¿ƒå‡½æ•° enum ggml_status ggml_graph_compute_with_ctx(struct ggml_context * ctx, struct ggml_cgraph * cgraph, int n_threads) struct ggml_cplan cplan = ggml_graph_plan(cgraph, n_threads, NULL); struct ggml_object * obj = ggml_new_object(ctx, GGML_OBJECT_TYPE_WORK_BUFFER, cplan.work_size); cplan.work_data = (uint8_t *)ctx-mem_buffer + obj-offs; return ggml_graph_compute(cgraph, cplan); ä¸»è¦æ­¥éª¤ä¸ºï¼Œ 1.æ„å»ºæ‰§è¡Œè®¡åˆ’ggml_graph_plan,ç”Ÿæˆæ‰§è¡Œé¡ºåºå’Œä»»åŠ¡è®¡åˆ’ã€æ‰€æœ‰ç®—å­ä¸­çš„é¢„è®¡åˆ†é…å†…å­˜å¤§å°ã€çº¿ç¨‹æ•°é‡ã€‚çº¿ç¨‹åˆ†é…æ•°é‡ç”±ggml_get_n_tasksä¸­çš„ä¸€ä¸ªswitch caseå†³å®šã€‚å…¶ä¸­æœ‰ä¸€æ®µwork_size += CACHE_LINE_SIZE * n_threads;çš„ä»£ç æ˜¯é¿å…å¤šä¸ªçº¿ç¨‹è®¿é—®åŒä¸€ä¸ªç¼“å­˜å’Œï¼Œé€ æˆä¼ªå…±äº«ã€‚ä¸€äº›å¯ä»¥è¢«å¤šçº¿ç¨‹æ‰§è¡Œçš„ç®—å­è®¡ç®—é¢„è®¡å†…å­˜åˆ†é…çš„æ—¶å€™è¿˜ä¼šä¹˜ä»¥çº¿ç¨‹æ•°ï¼Œä¿è¯ä¸ä¼šå¯¼è‡´é¢å¤–çš„å†…å­˜åŒæ­¥å¼€é”€ã€‚ 2.ggml_new_objectç”Ÿæˆä»»åŠ¡ç¼“å†²åŒº,ggml_contextä¸­ ã€‚ 3.æ‰§è¡Œè®¡ç®—å›¾ggml_graph_compute ggml_graph_compute æ‰§è¡Œggml_graph_computeæ—¶ï¼Œé¦–å…ˆåˆå§‹åŒ–æˆ–è€…è®¾ç½®ggml_threadpoolä¸­çš„ç›¸å…³å‚æ•°ï¼ŒåŒ…æ‹¬cplanç­‰ åªæœ‰è°ƒç”¨ggml_graph_compute_threadè¿›è¡Œå¤šçº¿ç¨‹å¤„ç†ï¼Œå¯ç”¨ompè¿›è¡Œå¤šçº¿ç¨‹å¤„ç†ï¼Œå¦åˆ™å•çº¿ç¨‹ å…¶ä¸­éå†cgraphä¸­çš„æ¯ä¸ªç®—å­èŠ‚ç‚¹ï¼Œé€šè¿‡ggml_compute_forwardè½¬å‘åˆ°ä¸åŒçš„ç®—å­è¿›è¡Œè®¡ç®—ï¼Œæ¯ä¸ªç®—å­å†…éƒ¨åŒºåˆ†ä¸åŒçš„ç²¾è¯»ï¼Œè½¬å‘åˆ°ä¸åŒçš„ç²¾åº¦å¤„ç†å‡½æ•°ï¼Œæœ€åä¸åŒçš„ç²¾åº¦è®¡ç®—ç®—å­å‡½æ•° é€šè¿‡ith thè€ƒè™‘çº¿ç¨‹åˆ†é…ï¼Œå†…å­˜å­˜å– å°†çº¿ç¨‹åˆ’åˆ†è®¡ç®—çš„æƒåˆ©äº¤ç»™äº†ç®—å­è‡ªèº«æ¥æ‰§è¡Œã€‚ ä¾‹å¦‚ä»¥f16_addä¸ºä¾‹,é€šè¿‡ithåˆ’åˆ†ä¸¾è¯çš„è¡Œå’Œåˆ—ï¼Œæ¯ä¸ªçº¿ç¨‹è®¡ç®—ä¸åŒçš„å°çŸ©é˜µï¼Œå®ç°å¹¶è¡ŒåŒ–ã€‚ static void ggml_compute_forward_add_f16_f16( const struct ggml_compute_params * params, struct ggml_tensor * dst) const struct ggml_tensor * src0 = dst-src[0]; const struct ggml_tensor * src1 = dst-src[1]; GGML_ASSERT(ggml_are_same_shape(src0, src1) ggml_are_same_shape(src0, dst)); const int ith = params-ith; const int nth = params-nth; const int nr = ggml_nrows(src0); GGML_TENSOR_BINARY_OP_LOCALS GGML_ASSERT(src0-type == GGML_TYPE_F16); GGML_ASSERT(src1-type == GGML_TYPE_F16); GGML_ASSERT(dst-type == GGML_TYPE_F16); GGML_ASSERT( nb0 == sizeof(ggml_fp16_t)); GGML_ASSERT(nb00 == sizeof(ggml_fp16_t)); // rows per thread const int dr = (nr + nth - 1)/nth; // row range for this thread const int ir0 = dr*ith; const int ir1 = MIN(ir0 + dr, nr); if (nb10 == sizeof(ggml_fp16_t)) for (int ir = ir0; ir ir1; ++ir) // src0, src1 and dst are same shape = same indices const int i3 = ir/(ne2*ne1); const int i2 = (ir - i3*ne2*ne1)/ne1; const int i1 = (ir - i3*ne2*ne1 - i2*ne1); ggml_fp16_t * dst_ptr = (ggml_fp16_t *) ((char *) dst-data + i3*nb3 + i2*nb2 + i1*nb1); ggml_fp16_t * src0_ptr = (ggml_fp16_t *) ((char *) src0-data + i3*nb03 + i2*nb02 + i1*nb01); ggml_fp16_t * src1_ptr = (ggml_fp16_t *) ((char *) src1-data + i3*nb13 + i2*nb12 + i1*nb11); for (int i = 0; i ne0; i++) dst_ptr[i] = GGML_FP32_TO_FP16(GGML_FP16_TO_FP32(src0_ptr[i]) + GGML_FP16_TO_FP32(src1_ptr[i])); else // src1 is not contiguous GGML_ABORT(fatal error); 3.åç«¯å®ç°å¿«é€Ÿå…¥é—¨æŠ€å·§ï¼š ç”¨é¢å‘å¯¹è±¡æ€æƒ³æ¥é˜…è¯»ï¼ 3.1ç›¸å…³æ•°æ®ç»“æ„ggml_backendæŸ¥çœ‹examplesimpleä»£ç æ—¶ï¼Œåç«¯çš„æ¨¡å‹ä¸­å¢åŠ äº†ä¸€ä¸ªggml_backendç»“æ„ã€‚ ggml_backendå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªè®¾å¤‡ç®¡ç†å™¨ struct ggml_backend ggml_guid_t guid;//ç”¨äºå”¯ä¸€æ ‡è¯† backend å®ä¾‹ï¼Œä¾¿äºæ³¨å†Œã€æŸ¥æ‰¾æˆ–è°ƒè¯•ã€‚ struct ggml_backend_i iface;//å®šä¹‰åç«¯è¡Œä¸ºçš„å‡½æ•°è™šè¡¨ï¼ŒåŒ…å«åç«¯è¡Œä¸ºçš„å‡½æ•°æŒ‡é’ˆ ggml_backend_context_t context;//void *ï¼Œå…·ä½“å†…å®¹ä¾èµ–åç«¯å®ç°; ggml_backend_bufferstruct ggml_backend_buffer struct ggml_backend_buffer_i iface; ggml_backend_buffer_type_t buft; ggml_backend_buffer_context_t context; size_t size; enum ggml_backend_buffer_usage usage; ; åˆåŒ…å«äº†ggml_backend_buffer_type struct ggml_backend_buffer_type struct ggml_backend_buffer_type_i iface; ggml_backend_buffer_type_context_t context; ; è¿™é‡Œç»“æ„ä½“æ¯”è¾ƒå¤šï¼Œçœ‹èµ·æ¥æ¯”è¾ƒå¤æ‚ï¼Œç”¨è¿™ç¯‡åšå®¢ä¸­çš„å›¾ç‰‡æè¿°æ˜¯è¿™æ ·çš„ .kdzykbyphfii{zoom: 80%;} ä½†æ˜¯å¦‚æœç”¨é¢å‘å¯¹è±¡çš„æ€æƒ³æ¥ç†è§£ï¼Œä¸€åˆ‡éƒ½å¾ˆç®€å•ã€‚ æœ€å¼€å§‹çš„åˆè¡·æ˜¯æœ‰ä¸€ä¸ªåç«¯åŸºç±»ï¼Œä¸åŒç±»å‹çš„åç«¯åŸºäºæ­¤æ´¾ç”Ÿï¼Œè€Œåç«¯åŒ…å«æœ‰ä¸åŒçš„bufferï¼Œå› æ­¤åˆ›å»ºäº†åç«¯bufferä¸€ç»„åŸºç±»ï¼Œå¹¶ä½œä¸ºåç«¯åŸºç±»çš„æˆå‘˜å˜é‡ï¼Œç›¸åŒçš„æ–¹å¼æœ‰äº†åç«¯buffer-typeç±» ä¸åŒçš„åç«¯æœ‰ä¸åŒçš„æˆå‘˜å˜é‡ï¼Œä¹Ÿå°±æ˜¯ctxï¼Œé€šè¿‡void*å®ç° 3.2CPUåç«¯ç¤ºä¾‹è®²è§£load modelåŠ è½½æ¨¡å‹ä¹‹å‰å…ˆæ ¹æ®ä¸åŒçš„å®å¯ç”¨ä¸åŒçš„åç«¯åˆå§‹åŒ–å‡½æ•°ï¼Œ ä¹‹ååˆ›å»ºå¯¹åº”çš„ggml_contxtï¼Œ åˆ›å»ºå‘é‡æ—¶ï¼Œé¦–å…ˆä¼šå°†å‘é‡å­˜å‚¨åœ¨CPUï¼Œ ä¹‹åé€šè¿‡ggml_backend_alloc_ctx_tensors åˆ›å»ºå¯¹åº”çš„åç«¯buffer,ç„¶åé€šè¿‡ggml_backend_tensor_setå°†å‘é‡ä»CPUå†…å­˜æ¬åˆ°åç«¯å†…å­˜ void load_model(simple_model model, float * a, float * b, int rows_A, int cols_A, int rows_B, int cols_B) // initialize the backend#ifdef GGML_USE_CUDA fprintf(stderr, %s: using CUDA backend , __func__); model.backend = ggml_backend_cuda_init(0); // init device 0 if (!model.backend) fprintf(stderr, %s: ggml_backend_cuda_init() failed , __func__); #endif#ifdef GGML_USE_METAL fprintf(stderr, %s: using Metal backend , __func__); ggml_backend_metal_log_set_callback(ggml_log_callback_default, nullptr); model.backend = ggml_backend_metal_init(); if (!model.backend) fprintf(stderr, %s: ggml_backend_metal_init() failed , __func__); #endif // if there arent GPU Backends fallback to CPU backend if (!model.backend) model.backend = ggml_backend_cpu_init(); int num_tensors = 2; struct ggml_init_params params /*.mem_size =*/ ggml_tensor_overhead() * num_tensors, /*.mem_buffer =*/ NULL, /*.no_alloc =*/ true, ; // create context model.ctx = ggml_init(params); // create tensors model.a = ggml_new_tensor_2d(model.ctx, GGML_TYPE_F32, cols_A, rows_A); model.b = ggml_new_tensor_2d(model.ctx, GGML_TYPE_F32, cols_B, rows_B); // create a backend buffer (backend memory) and alloc the tensors from the context model.buffer = ggml_backend_alloc_ctx_tensors(model.ctx, model.backend); // load data from cpu memory to backend buffer ggml_backend_tensor_set(model.a, a, 0, ggml_nbytes(model.a)); ggml_backend_tensor_set(model.b, b, 0, ggml_nbytes(model.b)); ggml_backend_cpu_init ggml_backend_cpu_init XXX_backend_cpu_initè´Ÿè´£åˆ›å»ºå¯¹åº”çš„ggml_backend_tç»“æ„ä½“ å¯ä»¥çœ‹åˆ°ç»“æ„ä½“ä¸­çš„ctxæ˜¯æ¯ä¸ªåç«¯æœ‰ä¸€ä¸ªè‡ªå·±çš„ç»“æ„ä½“ è™šå‡½æ•°è¡¨interfaceæ˜¯å…¨å±€å®šä¹‰äº†æ¯ä¸ªåç«¯çš„è¡¨ï¼Œå¦‚cpu_backend_i ggml_backend_t ggml_backend_cpu_init(void) struct ggml_backend_cpu_context * ctx = malloc(sizeof(struct ggml_backend_cpu_context)); if (ctx == NULL) return NULL; ctx-n_threads = GGML_DEFAULT_N_THREADS; ctx-threadpool = NULL; ctx-work_data = NULL; ctx-work_size = 0; ctx-abort_callback = NULL; ctx-abort_callback_data = NULL; ggml_backend_t cpu_backend = malloc(sizeof(struct ggml_backend)); if (cpu_backend == NULL) free(ctx); return NULL; *cpu_backend = (struct ggml_backend) /* .guid = */ ggml_backend_cpu_guid(), /* .interface = */ cpu_backend_i, /* .context = */ ctx ; return cpu_backend;static struct ggml_backend_i cpu_backend_i = /* .get_name = */ ggml_backend_cpu_name, /* .free = */ ggml_backend_cpu_free, /* .get_default_buffer_type = */ ggml_backend_cpu_get_default_buffer_type, /* .set_tensor_async = */ NULL, /* .get_tensor_async = */ NULL, /* .cpy_tensor_async = */ NULL, /* .synchronize = */ NULL, /* .graph_plan_create = */ ggml_backend_cpu_graph_plan_create, /* .graph_plan_free = */ ggml_backend_cpu_graph_plan_free, /* .graph_plan_update = */ NULL, /* .graph_plan_compute = */ ggml_backend_cpu_graph_plan_compute, /* .graph_compute = */ ggml_backend_cpu_graph_compute, /* .supports_op = */ ggml_backend_cpu_supports_op, /* .supports_buft = */ ggml_backend_cpu_supports_buft, /* .offload_op = */ NULL, /* .event_new = */ NULL, /* .event_free = */ NULL, /* .event_record = */ NULL, /* .event_wait = */ NULL, /* .event_synchronize = */ NULL,; ggml_backend_alloc_ctx_tensors æ ¸å¿ƒä»£ç alloc_tensor_rangeæœ¬è´¨å°±æ˜¯æ„é€ å‡½æ•° ggml_backend_buffer_t ggml_backend_alloc_ctx_tensors(struct ggml_context * ctx, ggml_backend_t backend) return ggml_backend_alloc_ctx_tensors_from_buft(ctx, ggml_backend_get_default_buffer_type(backend));ggml_backend_buffer_t ggml_backend_alloc_ctx_tensors_from_buft(struct ggml_context * ctx, ggml_backend_buffer_type_t buft) GGML_ASSERT(ggml_get_no_alloc(ctx) == true); size_t alignment = ggml_backend_buft_get_alignment(buft); size_t max_size = ggml_backend_buft_get_max_size(buft); ggml_backend_buffer_t * buffers = NULL; size_t n_buffers = 0; size_t cur_buf_size = 0; struct ggml_tensor * first = ggml_get_first_tensor(ctx); for (struct ggml_tensor * t = first; t != NULL; t = ggml_get_next_tensor(ctx, t)) size_t this_size = 0; if (t-data == NULL t-view_src == NULL) this_size = GGML_PAD(ggml_backend_buft_get_alloc_size(buft, t), alignment); if (this_size max_size) fprintf(stderr, %s: tensor %s is too large to fit in a %s buffer (tensor size: %zu, max buffer size: %zu) , __func__, t-name, ggml_backend_buft_name(buft), this_size, max_size); for (size_t i = 0; i n_buffers; i++) ggml_backend_buffer_free(buffers[i]); free(buffers); return NULL; if ((cur_buf_size + this_size) max_size) // allocate tensors in the current buffer if (!alloc_tensor_range(ctx, first, t, buft, cur_buf_size, buffers, n_buffers)) return NULL; first = t; cur_buf_size = this_size; else cur_buf_size += this_size; // allocate remaining tensors if (cur_buf_size 0) if (!alloc_tensor_range(ctx, first, NULL, buft, cur_buf_size, buffers, n_buffers)) return NULL; if (n_buffers == 0) #ifndef NDEBUG fprintf(stderr, %s: all tensors in the context are already allocated , __func__);#endif return NULL; ggml_backend_buffer_t buffer; if (n_buffers == 1) buffer = buffers[0]; else buffer = ggml_backend_multi_buffer_alloc_buffer(buffers, n_buffers); free(buffers); return buffer; æ€»ç»“1.ggmlä¸­åˆ†æ˜å¾ˆå¤šåœ°æ–¹éƒ½æ˜¯é¢å‘å¯¹è±¡çš„æ€æƒ³å†™çš„ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆä¼šç”¨Cè¯­è¨€å†™å‘¢ï¼Ÿ æ›´åŠ ç¨³å®šçš„ABIï¼Œä¸å’Œç¼–è¯‘å™¨å¼ºç›¸å…³ é›¶ä¾èµ–ï¼Œè½»é‡åŒ– æ²¡æœ‰è¿è¡Œæ—¶ï¼Œæ‰‹åŠ¨æ§åˆ¶å†…å­˜æ›´æ–¹ä¾¿","tags":["LLM/ggml"],"categories":["æºç è§£æ/å¤§æ¨¡å‹"]},{"title":"å‡ ç§ç¨‹åºæ¥å£é‡å®šå‘ã€æ’æ¡©æ–¹å¼æ¯”è¾ƒ","path":"/2025/07/29/å‡ ç§ç¨‹åºæ¥å£é‡å®šå‘ã€æ’æ¡©æ–¹å¼æ¯”è¾ƒ/","content":"æœ€è¿‘åœ¨å®éªŒä¸­éœ€è¦åˆ†æç¨‹åºä¸­çš„å †å˜é‡å†…å­˜åˆ†é…æƒ…å†µï¼Œä¸€å¼€å§‹è‡ªå·±çš„å®ç°æ˜¯é‡‡ç”¨llvm IR Passä¿®æ”¹çš„æ–¹å¼ï¼Œåæ¥åœ¨OSDIçš„è®ºæ–‡ä¸­å‘ç°ç›¸å…³çš„æ–¹æ³•é‡‡ç”¨çš„æ˜¯LD_PRELOADçš„æ–¹å¼å®ç°ï¼Œä¸€å¼€å§‹è®¤ä¸ºè¿™ç§æ–¹æ³•ä¼šæ›´åŠ ç®€å•ï¼Œäºæ˜¯è¿›è¡Œäº†å®ç°ï¼Œç»“æœå‘ç°å„æœ‰ç‰¹ç‚¹ã€‚ 1. LLVM IR æ–¹å¼2. LD_PRELOADæ–¹å¼ä»£ç  LD_PRELOADçš„å…¨è¿›ç¨‹çº§åˆ«ï¼šLD_PRELOADæ˜¯åŸºäºå…¨è¿›ç¨‹çº§åˆ«çš„åŠ¨æ€é“¾æ¥ç¬¦å·é‡å®šå‘ã€‚ å¯åŠ¨åŠ è½½æ—¶åŠ è½½æŒ‡å®šçš„.soæ–‡ä»¶ï¼Œç„¶ååç»­æ‰€æœ‰çš„è°ƒç”¨éƒ½ä¼šä½¿ç”¨soæ–‡ä»¶ä¸­æä¾›çš„å®ç°ï¼Œè¿™åŒ…æ‹¬å¼•ç”¨ç¨‹åºä»£ç ã€ç¬¬ä¸‰æ–¹åº“ã€libc æ¯”å¦‚ï¼šé‡å®šå‘äº†ä¸€ä¸ªmallocï¼Œè®°å½•ç¨‹åºä¸­çš„mallocåœ°å€ç„¶åä½¿ç”¨LD_PRELOADçš„æ–¹å¼è¿›è¡Œé‡å®šå‘ã€‚ #include stdio.h#include stdlib.hint main() void* p = malloc(64); // printf(p: %p , p); free(p); return 0; ç†è®ºä»¥ä¸Šä»£ç å€¼è°ƒç”¨ä¸€ä¸ªmalloc,ä½†æ˜¯æ‹¦æˆªé‡å®šå‘ä»¥åå‘ç°æœ‰3ä¸ªmalloc,ä¸æ³¨é‡Šä»£ç ä¸­çš„printfå‡½æ•°ï¼Œè¿˜ä¼šå¤šå‡ºä¸€ä¸ªmallocã€‚ è¿™æ ·çš„å…¨è¿›ç¨‹çº§åˆ«ç‰¹æ€§å¯ä»¥é‡‡é›†åˆ°lib cæœ¬èº«çš„ç‰¹æ€§ï¼Œä½†æ˜¯ä¹Ÿå¯èƒ½ä¼šå¯¹ç¨‹åºåˆ†æä¸å¿…è¦çš„éº»çƒ¦ï¼Œæ¯”å¦‚æˆ‘æœ¬èº«åªæƒ³åˆ†æåº”ç”¨ç¨‹åºçº§åˆ«çš„äº‹åŠ¡ï¼Œå®ç°ç¨‹åºä»£ç ä¸­çš„è¿‡æ»¤å¯ä»¥é€šè¿‡è°ƒç”¨æ ˆè¿‡æ»¤ç­‰æ–¹å¼å®ç°ã€‚","tags":["LD_PRELOAD","LLVM","PIN"]},{"title":"è®ºæ–‡ä¸­å¸¸è§å†…å­˜æ€§èƒ½åˆ†æworkloads","path":"/2025/07/27/è®ºæ–‡ä¸­å¸¸è§å†…å­˜æ€§èƒ½åˆ†æworkloads/","content":"ä¸€ã€åˆ†ç±»è¯´æ˜æ•´ç†æ‰€è¯»åˆ°è®ºæ–‡ä¸­ç»å¸¸ä½¿ç”¨çš„å†…å­˜åˆ†æå·¥ä½œè´Ÿè½½ã€‚ æŒ‰ç…§ç‰¹ç‚¹å¯ä»¥åˆ†ä¸ºå»¶è¿Ÿæ•æ„Ÿå‹ã€å¸¦å®½å¯†é›†å‹ï¼›æŒ‰ç…§ä½œç”¨å¯ä»¥åˆ†ä¸ºAIã€HPCã€Databaseç­‰ åšå®¢ç”¨äºå†…å­˜æ€§èƒ½è¯„ä¼°çš„workloadä¸­æ•´ç†äº†å¸¸è§çš„workloads,ä½†æ˜¯ä¸»è¦è¿˜æ˜¯é‡åœ¨åŸºæœ¬ä»‹ç»ï¼Œæ²¡æœ‰å¯¹å…¶è®¿å­˜ç‰¹å¾ç­‰é•œåƒä»‹ç»ã€‚æœ¬æ–‡å€Ÿé‰´è¿™ç¯‡åšå®¢ï¼Œè‡ªå·±åˆ†æã€è¿è¡Œç›¸å…³workloadsã€‚ äºŒã€LLM inference1.llama.cppè½»é‡åŒ–çš„å¤§æ¨¡å‹æ¨ç†æ¡†æ¶ã€é€‚ç”¨äºåµŒå…¥å‹ç³»ç»Ÿã€è¾¹ç¼˜èŠ‚ç‚¹ä¸Šè¿›è¡Œå¤§æ¨¡å‹æ¨ç†ã€‚ è®¿å­˜ç‰¹å¾ï¼š æ¨¡å‹æƒé‡åŠ è½½é˜¶æ®µï¼šé‡‡ç”¨å¤§å—è¿ç»­å†…å­˜ã€æˆ–è€…å¯é€‰mmap()æ˜ å°„æ¨¡å‹å‚æ•°ã€‚å…·æœ‰è¾ƒå¥½çš„ç©ºé—´å±€éƒ¨æ€§ã€è¾ƒå·®çš„æ—¶é—´å±€éƒ¨æ€§(ä¸€æ¬¡åŠ è½½ä¸€æ¬¡ä½¿ç”¨) æ¨ç†é˜¶æ®µï¼šä¸»è¦æ˜¯KV-Cacheéœ€è¦å¤§é‡å†…å­˜è®¿é—®ï¼Œè¯»å†™é¢‘ç¹ã€æ›´æ–°é¢‘ç¹ã€å„ä¸ªå±‚ä¸­å­˜åœ¨ä¸€äº›å¼ é‡æ“ä½œä¹Ÿéœ€è¦è®¿å­˜ã€‚é«˜è¯»å¯†é›†å‹ å†…å­˜éœ€æ±‚ï¼š â€‹\tåŒå…¶ä»–å¤§æ¨¡å‹æ¨ç†éœ€æ±‚ç›¸ä¼¼ï¼Œå†…å­˜éœ€æ±‚é‡ä¸»è¦æ¥è‡ªæ¨¡å‹æƒé‡ä¸KV-cacheã€‚æ¨¡å‹æƒé‡å†…å­˜ä½¿ç”¨é‡ä¸ç²¾è¯»æœ‰å…³ã€KV-Cacheä¸ä¾èµ–å±‚æ•°æœ‰å…³ã€‚ä¸€ä¸ªqwen-7båœ¨llama.cppçš„å†…å­˜å ç”¨é‡çº¦ä¸º14~16B å…¶ä»–ï¼š â€‹\tllama.cppçš„å†…å­˜ç®¡ç†é‡‡ç”¨ç»Ÿä¸€é¢„åˆ†é…å†…å­˜æ± ï¼Œä½¿ç”¨offsetäºŒæ¬¡åˆ†é…ä¸è®¿é—®ï¼Œæœ€åé›†ä¸­é‡Šæ”¾çš„æ–¹å¼è¿›è¡Œå†…å­˜ç®¡ç†ã€‚å…¶ggmlå†…å­˜ä¸­æœ‰å¯¹å†…å­˜çš„ä¸€æ¬¡æ€§mallocï¼ˆggml_initï¼‰ggml_new_tensorã€ggml_new_tensor_1dè¿›è¡Œå†…å­˜å†…å­˜äºŒæ¬¡åˆ†é…ã€ggml_freeè¿›è¡Œå†…å­˜é‡Šæ”¾ã€‚Arena åˆ†é…å™¨ï¼ˆâ€œæ‰¹å‘å†…å­˜ï¼Œé›¶å”®æŒ‡é’ˆï¼Œæ•´å•æ¸…åœºâ€ï¼‰","tags":["å†…å­˜æ€§èƒ½åˆ†æworkloads"],"categories":["å†…å­˜æ€§èƒ½åˆ†æworkloads"]},{"title":"Qtæºç é˜…è¯»ä¸è®¾è®¡æ¨¡å¼","path":"/2025/07/18/Qtæºç é˜…è¯»ä¸è®¾è®¡æ¨¡å¼/","content":"todo","tags":["Qt","è®¾è®¡æ¨¡å¼"],"categories":["Qt"]},{"path":"/about/index.html","content":"ğŸ§‘â€ğŸ’» About me Hello, welcome to my blog. Iâ€™m Zane Jiang. I graduated with a bachelorâ€™s degree in Computer Science from Nanjing Normal University(NNU), and I am currently pursuing a masterâ€™s degree at the College of Computer Science, Chongqing University(CQU). I have worked as a C++ software development engineer for one year in a company specializing in LED control systems. My current areas of interest include OS,LLVM, CXL, Qt, and more. This blog is used to document some of my reflections on life, work, and study notes. ğŸ“« Contact Email: 2129056867@qq.com GitHub"},{"title":"C++ç®—æ³•åˆ·é¢˜å¸¸ç”¨API","path":"/notebooks/Interview/C++ç®—æ³•åˆ·é¢˜å¸¸ç”¨API.html","content":"ä»…ä¾›å¿«é€Ÿå¤ä¹ ï¼Œæœ€ä½³æ–¹æ¡ˆè¿˜æ˜¯é‡åˆ°äº†æŸ¥dash string å¸¸è§æ“ä½œ æ„é€ ã€é•¿åº¦å®¹é‡ã€è®¿é—®ç•¥ è¾“å…¥è¾“å‡º string s;cin s; // è¯»å–ä¸€ä¸ªå•è¯ï¼ˆé‡åˆ°ç©ºæ ¼åœæ­¢ï¼‰getline(cin, s); // è¯»å–æ•´è¡Œï¼ˆåŒ…æ‹¬ç©ºæ ¼ï¼‰ ä¿®æ”¹ï¼š è¿½åŠ ä¸è¿æ¥ + append push_back æ’å…¥ä¸åˆ é™¤ s.insert(5,â€â€) s.erase(5,6)ä»5çš„ä½ç½®åˆ é™¤6ä¸ªå­—ç¬¦s.replace(1,3,â€xxxâ€) å­ä¸²æ“ä½œ //æå–å­ä¸²string s = Hello World;string sub = s.substr(6, 5); // ä»ä½ç½®6å¼€å§‹ï¼Œå–5ä¸ªå­—ç¬¦ - Worldstring sub2 = s.substr(6); // ä»ä½ç½®6åˆ°ç»“å°¾ - World//æŸ¥æ‰¾size_t pos = s.find(World); // 6 - ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®pos = s.find(Hello, 1); // 12 - ä»ä½ç½®1å¼€å§‹æŸ¥æ‰¾// åå‘æŸ¥æ‰¾pos = s.rfind(Hello); // 12 - ä»åå¾€å‰æ‰¾// æŸ¥æ‰¾å­—ç¬¦pos = s.find_first_of(aeiou); // 1 - ç¬¬ä¸€ä¸ªå…ƒéŸ³å­—æ¯ epos = s.find_last_of(aeiou); // 15 - æœ€åä¸€ä¸ªå…ƒéŸ³å­—æ¯ opos = s.find_first_not_of(Helo ); // 6 - ç¬¬ä¸€ä¸ªä¸æ˜¯è¿™äº›å­—ç¬¦çš„ W æ¯”è¾ƒ string s1 = apple, s2 = banana;if (s1 == s2) /* ç›¸ç­‰ */ if (s1 != s2) /* ä¸ç›¸ç­‰ */ if (s1 s2) /* s1 åœ¨å­—å…¸åºä¸­å°äº s2 */ if (s1.compare(s2) 0) /* åŒä¸Šï¼Œè¿”å›è´Ÿæ•°ã€0æˆ–æ­£æ•° */ æ•°å€¼è½¬æ¢ // å­—ç¬¦ä¸²è½¬æ•°å€¼string num_str = 123;int i = stoi(num_str); // è½¬ intdouble d = stod(3.14); // è½¬ doublelong l = stol(1000000); // è½¬ long// æ•°å€¼è½¬å­—ç¬¦ä¸²string s1 = to_string(123); // 123string s2 = to_string(3.14159); // 3.14159"},{"title":"CPPæ‚è®°","path":"/notebooks/Interview/CPPæ‚è®°.html","content":"å…¨å±€é™æ€å˜é‡ã€å‡½æ•°å†…é™æ€å˜é‡ã€attribute((destructor))ææ„é¡ºåºæ„é€ ææ„é¡ºåºçš„ä¸ç¡®å®šæ€§ ä»¥åŠé™æ€å‡½æ•°è·å–çš„å•ä¾‹ã€‚ C++ æ ‡å‡†è§„å®šï¼šåŒä¸€ä¸ªç¼–è¯‘å•å…ƒï¼ˆåŒä¸€ä¸ª cpp æ–‡ä»¶ï¼‰å†…ï¼Œé™æ€å…¨å±€å¯¹è±¡çš„ææ„é¡ºåºä¸æ„é€ é¡ºåºç›¸åã€‚ ä½†ä¸åŒç¼–è¯‘å•å…ƒï¼ˆä¸åŒ cpp æ–‡ä»¶soï¼‰ä¹‹é—´çš„ææ„é¡ºåºæ˜¯æœªå®šä¹‰çš„ã€‚ å±€éƒ¨ staticï¼ˆå³å‡½æ•°å†… staticï¼‰å¯¹è±¡çš„ææ„é¡ºåºä¸å…¶å®šä¹‰é¡ºåºæœ‰å…³ï¼Œä½†ä¹Ÿåªåœ¨åŒä¸€ç¼–è¯‘å•å…ƒå†…æœ‰ä¿è¯ã€‚ è‹¥ä¸€ä¸ªå˜é‡ä»…åœ¨å•ä¸ªæ–‡ä»¶ä¸­å¯è§ï¼Œåˆ™å»ºè®®å°†è¿™ä¸ªå˜é‡å£°æ˜ä¸ºé™æ€å…¨å±€å˜é‡ï¼Œstaticä¿®é¥°çš„é™æ€å…¨å±€å˜é‡ä»…åœ¨å½“å‰æ–‡ä»¶ä¸­å¯è§ã€‚ å¦‚æœä¸€ä¸ªå…¨å±€å˜é‡åªè¢«å•ä¸ªå‡½æ•°ä½¿ç”¨,å°†å…¶æ”¹ä¸ºè¯¥å‡½æ•°çš„é™æ€å±€éƒ¨å˜é‡å¯ä»¥è¿›ä¸€æ­¥é™åˆ¶å˜é‡çš„ä½œç”¨åŸŸ,æé«˜ä»£ç çš„å†…èšæ€§,é™ä½è€¦åˆåº¦ã€‚é™æ€å±€éƒ¨å˜é‡å…·æœ‰å…¨å±€å¯¿å‘½ä½†å±€éƒ¨ä½œç”¨åŸŸçš„ç‰¹ç‚¹, é™æ€å…¨å±€å˜é‡æ˜¯å­˜å‚¨åœ¨**é™æ€æ•°æ®åŒºçš„,**è€Œä¸æ˜¯æ ˆåŒº,å› æ­¤é™æ€å…¨å±€å˜é‡çš„å¤§å°ä¸ä¼šå¯¼è‡´æ ˆæº¢å‡ºã€‚æ ˆæº¢å‡ºé€šå¸¸æ˜¯ç”±äºå‡½æ•°è°ƒç”¨å±‚æ¬¡è¿‡æ·±æˆ–å±€éƒ¨å˜é‡è¿‡å¤§å¯¼è‡´çš„ã€‚ ç±»çš„å†…å­˜å ç”¨ 1.32ä½ç³»ç»Ÿä¸­è™šå‡½æ•°æŒ‡é’ˆä¸º4å­—èŠ‚ï¼Œ64ä½ä¸º8å­—èŠ‚ 2.åªéœ€è¦è€ƒè™‘è™šå‡½æ•°æŒ‡é’ˆï¼Œè™šå‡½æ•°è¡¨ä¸è®¡å…¥æŸä¸ªç±»çš„èµ„æº 3.charå ä¸€å­—èŠ‚ï¼Œä½†æ˜¯éœ€è¦è€ƒè™‘å†…å­˜è°ƒç”¨ 4.å¦‚æœæœ‰è™šç»§æ‰¿ï¼Œåˆ™å¤šä¸€ä¸ªè™šåŸºç±»æŒ‡é’ˆã€‚ 5.ç©ºç±»å ä¸€ä¸ªå­—èŠ‚ï¼ˆç”¨äºæ ‡è¯†ï¼‰ æŒ‡é’ˆå¥½é¢˜ int arr[5]{1,2,3,4,5};åœ¨è¿™ä¸ªæ•°ç»„çš„å®šä¹‰ä¸­ï¼Œé€šå¸¸çš„ç†è§£arræ˜¯æ•°ç»„çš„åœ°å€å³æ•°ç»„é¦–å…ƒç´ çš„åœ°å€ï¼Œè¿›ä¸€æ­¥ç†è§£arræ˜¯ä¸€ä¸ªintå‹çš„æŒ‡é’ˆå¸¸é‡ï¼Œå¸¸é‡+1åœ°å€åç§»sizeof(int)ï¼Œæ‰€ä»¥arr+1æ˜¯é¦–å…ƒç´ ä¸‹ä¸€ä¸ªå…ƒç´ çš„åœ°å€ï¼›è€ƒè™‘åˆ°è¿™ä¸€å±‚å°±ä¸éš¾ç†è§£**arr*çš„å«ä¹‰ï¼Œarræ˜¯å¯¹arrå–åœ°å€ï¼Œç»“æœä¹Ÿæ˜¯ä¸ªåœ°å€ï¼Œåªæ˜¯è¿™ä¸ªåœ°å€çš„ç±»å‹æ˜¯æŒ‡å‘æœ‰5ä¸ªintç±»å‹æ•°æ®çš„æ•°ç»„çš„æŒ‡é’ˆå¸¸é‡ï¼Œè¿™ä¸ªå¸¸é‡+1åœ°å€åç§»5sizeof(int)ã€‚ å„çº§æŒ‡é’ˆç®—å„çº§çš„ï¼š ä¸»è¦å°±æ˜¯ç†è§£ å’Œ * çš„â€œå‡çº§é™çº§â€ï¼› é“¾æ¥ï¼šhttps://www.nowcoder.com/exam/test/89156461/submission?examPageSource=Intelligentpid=62380309testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fintelligent%3FquestionJobId%3D10%26subTabName%3Dintelligent_page%26tagId%3D21000testclass%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91 Copy and Swapä¼ ç»Ÿåšæ³•operator= class MyString private: char* data; // åŠ¨æ€åˆ†é…çš„å­—ç¬¦ä¸²public: // èµ‹å€¼è¿ç®—ç¬¦é‡è½½ MyString operator=(const MyString other) // æ£€æŸ¥è‡ªèµ‹å€¼ if (this == other) return *this; // é‡Šæ”¾å½“å‰å¯¹è±¡çš„èµ„æº delete[] data; // å¤åˆ¶æ•°æ® data = new char[std::strlen(other.data) + 1]; std::strcpy(data, other.data); // è¿”å›å½“å‰å¯¹è±¡çš„å¼•ç”¨ return *this; ; Copy and Swap MyString operator=(const MyString other) // æ£€æŸ¥è‡ªèµ‹å€¼ if (this == other) return *this; MyString tmpother; std::swap(data,other.data); return *this; ä¼˜åŠ¿ï¼š å¼‚å¸¸å®‰å…¨ï¼šä¼ ç»Ÿæ–¹æ³•newæŠ›å‡ºå¼‚å¸¸æ—¶ï¼Œå¯¹è±¡å‡ºäºæ— æ•ˆçŠ¶æ€ã€‚dataå·²ç»è¢«åˆ é™¤ï¼Œä½†æ˜¯åˆ†é…å¤±è´¥ å¼ºå¼‚å¸¸å®‰å…¨æ€§: å¦‚æœä¸€ä¸ªæ“ä½œå› ä¸ºå¼‚å¸¸è€Œå¤±è´¥ï¼Œç¨‹åºçš„çŠ¶æ€ä¼šå›æ»šåˆ°æ“ä½œä¹‹å‰çš„æ ·å­ï¼Œå°±åƒè¿™ä¸ªæ“ä½œä»æ¥æ²¡æ‰§è¡Œè¿‡ä¸€æ · ä»£ç å¤ç”¨ï¼šå¤ç”¨æ‹·è´æ„é€ å‡½æ•° è‡ªåŠ¨èµ„æºç®¡ç†ï¼šè‡ªåŠ¨é‡Šæ”¾tmpèµ„æº C++11 å†™æ³• MyString operator=(MyString other) //å€¼ä¼ é€’ //ä¼ å…¥å·¦å€¼ï¼šæ‹·è´æ„é€  //ä¼ å…¥å³å€¼ï¼šç§»åŠ¨æ„é€  std::swap(data,other.data); return *this; ç§»åŠ¨æ„é€ è¿˜æ˜¯æ‹·è´æ„é€ ï¼Ÿ å·¦å€¼ï¼šå«å¾—å‡ºåå­— å³å€¼ï¼šå«ä¸å‡ºåå­—ï¼ˆä¸´æ—¶å˜é‡ï¼Œstd::moveï¼‰ å·¦å€¼ç”¨æ‹·è´æ„é€ ï¼Œå³å€¼ç”¨ç§»åŠ¨æ„é€ ï¼ˆå·ï¼‰ æ¨¡æ¿æ¨¡æ¿ç‰¹åŒ–ã€åç‰¹åŒ–æ¨¡æ¿ç‰¹åŒ–æ˜¯ä¸ºç‰¹å®šçš„æ¨¡æ¿å‚æ•°æä¾›ç‰¹æ®Šå®ç°çš„æŠ€æœ¯ã€‚å½“é€šç”¨æ¨¡æ¿ä¸é€‚åˆæŸäº›ç‰¹å®šç±»å‹æ—¶ï¼Œå¯ä»¥ä¸ºå…¶æä¾›å®šåˆ¶ç‰ˆæœ¬ã€‚ æ‰€æœ‰æ¨¡æ¿å‚æ•°éƒ½æŒ‡å®šå…·ä½“ç±»å‹å°±å«æ¨¡æ¿å…¨ç‰¹åŒ– åç‰¹åŒ–åªå¯¹éƒ¨åˆ†æ¨¡æ¿å‚æ•°è¿›è¡Œç‰¹åŒ–,å‡½æ•°æ¨¡æ¿ä¸æ”¯æŒåç‰¹åŒ–ï¼Œåªæœ‰ç±»æ¨¡æ¿æ”¯æŒ å‡½æ•°æ¨¡æ¿ç‰¹åŒ– #include iostream#include cstring// é€šç”¨æ¨¡æ¿templatetypename Tvoid print(T value) std::cout General: value std::endl;// å…¨ç‰¹åŒ– - ä¸ºconst char*ç±»å‹templatevoid printconst char*(const char* value) std::cout C-string: \\ value \\ std::endl;// å…¨ç‰¹åŒ– - ä¸ºintç±»å‹templatevoid printint(int value) std::cout Integer: value (0x std::hex value ) std::endl;int main() print(3.14); // è°ƒç”¨é€šç”¨ç‰ˆæœ¬ print(Hello); // è°ƒç”¨const char*ç‰¹åŒ– print(42); // è°ƒç”¨intç‰¹åŒ– return 0; ç±»æ¨¡æ¿ç‰¹åŒ– #include iostream// é€šç”¨æ¨¡æ¿templatetypename Tclass TypeInfo public: static const char* name() return Unknown; ;// å…¨ç‰¹åŒ– - intç±»å‹templateclass TypeInfoint public: static const char* name() return int; ;// å…¨ç‰¹åŒ– - doubleç±»å‹templateclass TypeInfodouble public: static const char* name() return double; ;// å…¨ç‰¹åŒ– - const char*ç±»å‹templateclass TypeInfoconst char* public: static const char* name() return const char*; ;int main() std::cout TypeInfofloat::name() std::endl; // Unknown std::cout TypeInfoint::name() std::endl; // int std::cout TypeInfoconst char*::name() std::endl; // const char* return 0; åç‰¹åŒ– #include iostream// é€šç”¨æ¨¡æ¿ - ä¸¤ä¸ªç±»å‹å‚æ•°templatetypename T, typename Uclass Pair public: void print() std::cout General PairT, U std::endl; ;// åç‰¹åŒ– - ä¸¤ä¸ªç±»å‹ç›¸åŒtemplatetypename Tclass PairT, T public: void print() std::cout Specialized PairT, T std::endl; ;// åç‰¹åŒ– - ç¬¬äºŒä¸ªå‚æ•°ä¸ºinttemplatetypename Tclass PairT, int public: void print() std::cout Specialized PairT, int std::endl; ;int main() Pairdouble, char p1; p1.print(); // General PairT, U Pairfloat, float p2; p2.print(); // Specialized PairT, T Pairstd::string, int p3; p3.print(); // Specialized PairT, int return 0;//æŒ‡é’ˆç±»å‹è¿›è¡Œåç‰¹åŒ–// é€šç”¨æ¨¡æ¿templatetypename Tclass Wrapper public: static const char* type() return Value; ;// åç‰¹åŒ– - æŒ‡é’ˆç±»å‹templatetypename Tclass WrapperT* public: static const char* type() return Pointer; ;// åç‰¹åŒ– - æŒ‡å‘æŒ‡é’ˆçš„æŒ‡é’ˆtemplatetypename Tclass WrapperT** public: static const char* type() return Pointer-to-Pointer; ;int main() std::cout Wrapperint::type() std::endl; // Value std::cout Wrapperint*::type() std::endl; // Pointer std::cout Wrapperint**::type() std::endl; // Pointer-to-Pointer return 0; å¯å˜å‚æ•°æ¨¡æ¿åŸºæœ¬ç”¨æ³•ï¼š templatetypename... Args // Argsæ˜¯æ¨¡æ¿å‚æ•°åŒ…void function(Args... args) // argsæ˜¯å‡½æ•°å‚æ•°åŒ… // å¤„ç†å‚æ•°... #include iostream// åŸºç¡€æƒ…å†µï¼š0ä¸ªå‚æ•°æ—¶è¿”å›0templatetypename TT sum(T value) return value;// é€’å½’æ±‚å’Œtemplatetypename T, typename... ArgsT sum(T first, Args... args) return first + sum(args...);// è®¡ç®—å‚æ•°ä¸ªæ•°templatetypename... Argsstd::size_t count(Args... args) return sizeof...(args); // sizeof... æ“ä½œç¬¦è·å–å‚æ•°åŒ…å¤§å°int main() std::cout sum(1, 2, 3, 4, 5) std::endl; // 15 std::cout sum(1.5, 2.5, 3.5) std::endl; // 7.5 std::cout count(1, a, hello, 3.14) std::endl; // 4 return 0; éç±»å‹æ¨¡æ¿å‚æ•°(å¸¸é‡æ¨¡æ¿)cudaä¸­ç”¨çš„å¤šï¼Œç”¨äºç¼–è¯‘å™¨å¸¸é‡ä¼˜åŒ– template int Nint sumArray(int (arr)[N]) int sum = 0; for (int i = 0; i N; i++) sum += arr[i]; return sum;int a[5] = 1,2,3,4,5;int total = sumArray(a); // N=5ï¼Œç¼–è¯‘æœŸç¡®å®š ç±»å‹è½¬æ¢è¿ç®—ç¬¦static_cast é™æ€è½¬æ¢ç”¨äºåœ¨ç¼–è¯‘æ—¶å·²çŸ¥çš„ï¼Œæœ‰é€»è¾‘å…³è”çš„ç±»å‹ä¹‹é—´çš„è½¬æ¢ åœºæ™¯ //åŸºæœ¬æ•°æ®ç±»å‹ä¹‹é—´çš„è½¬æ¢int i = 10;double d = static_castdouble(i); // int - double//æ´¾ç”Ÿç±»æŒ‡é’ˆ/å¼•ç”¨ - åŸºç±»æŒ‡é’ˆ/å¼•ç”¨ï¼ˆå‘ä¸Šè½¬æ¢ï¼ŒUpcastingï¼‰ã€‚è¿™æ˜¯å®‰å…¨çš„ï¼Œå¹¶ä¸”æ˜¯éšå¼è½¬æ¢çš„æ˜¾å¼å†™æ³•ã€‚class Base ;class Derived : public Base ;Derived derived;Base* basePtr = static_castBase*(derived); // å®‰å…¨//åŸºç±»æŒ‡é’ˆ/å¼•ç”¨ - æ´¾ç”Ÿç±»æŒ‡é’ˆ/å¼•ç”¨ï¼ˆå‘ä¸‹è½¬æ¢ï¼ŒDowncastingï¼‰ã€‚ä¸å®‰å…¨Base* basePtr = new Derived(); // å®é™…ä¸ŠæŒ‡å‘ä¸€ä¸ªDerivedå¯¹è±¡Derived* derivedPtr = static_castDerived*(basePtr); // å¯ä»¥ï¼Œä½†æœ‰é£é™©//ä»»ä½•å…·æœ‰è½¬æ¢æ„é€ å‡½æ•°çš„ç±»å‹è½¬æ¢class MyClass public: MyClass(int x) // è½¬æ¢æ„é€ å‡½æ•°;int num = 5;MyClass obj = static_castMyClass(num); dynamic_caståŠ¨æ€è½¬æ¢ç”¨äºå®‰å…¨çš„åœ¨ç»§æ‰¿å‚å·®ç»“æ„ä¸­è¿›è¡Œå‘ä¸‹è½¬æ¢æˆ–è€…äº¤å‰è½¬æ¢ï¼Œä¾èµ–è¿è¡Œæ—¶ç±»å‹ä¿¡æ¯RTTI ç”¨æ³•ï¼š å°†åŸºç±»æŒ‡é’ˆæˆ–å¼•ç”¨å®‰å…¨çš„è½¬æ¢ä¸ºæ´¾ç”Ÿç±»çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨ï¼Œå¿…é¡»ç”¨äºå¤šæ€ç±»å‹ï¼ˆè‡³å°‘å«æœ‰ä¸€ä¸ªè™šå‡½æ•°ï¼‰ â€‹\tè½¬æ¢æˆåŠŸä¼šè¿”å›ç›®æ ‡ç±»å‹çš„æŒ‡é’ˆï¼Œè½¬æ¢å¤±è´¥è¿”å›nullæˆ–è€…std::bad_cast class Base virtual void foo() ; // å¤šæ€åŸºç±»ï¼ˆæœ‰è™šå‡½æ•°ï¼‰class Derived : public Base ;Base* basePtr = new Derived(); // æ­£ç¡®æŒ‡å‘æ´¾ç”Ÿç±»// å®‰å…¨å‘ä¸‹è½¬æ¢Derived* derivedPtr = dynamic_castDerived*(basePtr);if (derivedPtr != nullptr) // è½¬æ¢æˆåŠŸï¼Œå¯ä»¥ä½¿ç”¨derivedPtr else // è½¬æ¢å¤±è´¥Base* basePtr2 = new Base(); // æŒ‡å‘åŸºç±»æœ¬èº«Derived* derivedPtr2 = dynamic_castDerived*(basePtr2);// derivedPtr2 å°†æ˜¯ nullptrï¼// å¼•ç”¨è½¬æ¢try Derived derivedRef = dynamic_castDerived(*basePtr); catch (const std::bad_cast e) std::cout è½¬æ¢å¤±è´¥: e.what() std::endl; const_cast å¸¸é‡è½¬æ¢ç”¨äºä¿®æ”¹ç±»å‹çš„ const æˆ– volatile å±æ€§ã€‚è¿™æ˜¯å”¯ä¸€èƒ½â€œå»æ‰â€ const å±æ€§çš„è½¬æ¢æ“ä½œç¬¦ ä¸»è¦ä½¿ç”¨æ–¹å¼å°±æ˜¯å»æ‰constå±æ€§ï¼Œä»¥ä¾¿æ¥å—ä¸€ä¸ªéconstå‚æ•°ä½†æ˜¯ä¸ä¼šä¿®æ”¹è¿˜æ—§API void printString(char* str) // ä¸€ä¸ªæ—§çš„ã€ä¸ä¿®æ”¹strçš„å‡½æ•° std::cout str std::endl;const char* myStr = Hello, World!;// printString(myStr); // é”™è¯¯ï¼šä¸èƒ½å°†const char* ä¼ é€’ç»™char*printString(const_castchar*(myStr)); // å¯è¡Œï¼Œä½†æœ‰é£é™© reinterpret_cast é‡æ–°è§£é‡Šè½¬æ¢è¿›è¡Œä½çº§çš„ã€åº•å±‚çš„ã€â€œé‡æ–°è§£é‡Šâ€æ¯”ç‰¹æ¨¡å¼çš„è½¬æ¢ã€‚å®ƒå¯ä»¥å°†ä¸€ä¸ªæŒ‡é’ˆè½¬æ¢ä¸ºä»»ä½•å…¶ä»–ç±»å‹çš„æŒ‡é’ˆï¼Œç”šè‡³æ˜¯ä¸€ä¸ªæ•´æ•°ã€‚ ä¸è¿›è¡Œä»»ä½•æ ¼å¼æ£€æŸ¥æˆ–å®‰å…¨æ€§æ£€æŸ¥ï¼Œå¯ç§»æ¤æ€§å·® åœºæ™¯ //åœ¨å‡½æ•°æŒ‡é’ˆç±»å‹ä¹‹é—´è¿›è¡Œè½¬æ¢ã€‚//åœ¨æŒ‡é’ˆå’Œè¶³å¤Ÿå¤§çš„æ•´æ•°ç±»å‹ä¹‹é—´è¿›è¡Œè½¬æ¢ï¼ˆå¦‚ void* è½¬ uintptr_tï¼‰ã€‚int* ip = new int(65);// å°†intæŒ‡é’ˆæ¯«æ— å…³ç³»åœ°è½¬æ¢ä¸ºcharæŒ‡é’ˆï¼Œç„¶åæ‰“å°å…¶æŒ‡å‘çš„å€¼char* cp = reinterpret_castchar*(ip);std::cout *cp; // è¾“å‡º A (å› ä¸º65æ˜¯Açš„ASCIIç )","tags":[null]},{"title":"C++11æ–°ç‰¹æ€§","path":"/notebooks/Interview/C++11æ–°ç‰¹æ€§.html","content":"å¾ˆå¥½çš„é¢è¯•èµ„æ–™ï¼š æ•´ç†äº†ä¸€å¹´çš„Linux C++æ­¦æ—ç§˜ç±ï¼Œä½ æ—©æ™šç”¨å¾—åˆ°ï¼ˆC++è¿›é˜¶å¿…çœ‹ï¼‰ - çŸ¥ä¹ è½¬è½½å¹¶ç®€å•æ•´ç†è‡ªçŸ¥ä¹ ç¨‹åºå–µå¤§äºº 1.å·¦å€¼å¼•ç”¨ä¸å®Œç¾è½¬å‘ç­‰åŸºæœ¬æ¦‚å¿µ: å·¦å€¼ã€å³å€¼ ï¼šæ”¾åœ¨ç­‰å·å·¦è¾¹ï¼Œå¯ä»¥å–åœ°å€å¹¶ä¸”æœ‰åå­— çš„å°±å«å·¦å€¼ï¼Œåä¹‹å«å³å€¼ int a = b + c ;int a = 4; çº¯å³å€¼:ç”¨äºåˆå§‹åŒ–ä¸€ä¸ªå¯¹è±¡ã€‚ è¿ç®—è¡¨è¾¾å¼äº§ç”Ÿçš„ä¸´æ—¶å˜é‡ã€ä¸å’Œå¯¹è±¡å…³è”çš„åŸå§‹å­—é¢é‡ã€è¿”å›éå¼•ç”¨çš„å‡½æ•°è°ƒç”¨ã€lambdaè¡¨è¾¾å¼ã€thisæŒ‡é’ˆ å°†äº¡å€¼ï¼šä»£è¡¨ä¸€ä¸ªâ€œå³å°†ç»“æŸç”Ÿå‘½å‘¨æœŸâ€çš„å¯¹è±¡ï¼Œ int main() std::string str = Hello World; // str æ˜¯ä¸€ä¸ªå·¦å€¼ // std::move(str) å°†å·¦å€¼ str è½¬æ¢ä¸ºä¸€ä¸ªå°†äº¡å€¼ // å®ƒåœ¨å‘Šè¯‰ç¼–è¯‘å™¨ï¼šâ€œstr å³å°†æ¶ˆäº¡ï¼Œè¯·ç§»åŠ¨å®ƒè€Œä¸æ˜¯æ‹·è´å®ƒâ€ std::string new_str = std::move(str); // æ­¤æ—¶ï¼Œstr çš„èµ„æºï¼ˆåŠ¨æ€åˆ†é…çš„å­—ç¬¦æ•°ç»„ï¼‰è¢«â€œç§»åŠ¨â€åˆ°äº† new_str ä¸­ // str æœ¬èº«ä»ç„¶å­˜åœ¨ï¼ˆæ˜¯ä¸€ä¸ªåˆæ³•çš„å¯¹è±¡ï¼‰ï¼Œä½†å¤„äºâ€œæœ‰æ•ˆä½†æœªæŒ‡å®šçŠ¶æ€â€ // é€šå¸¸æ˜¯ä¸€ä¸ªç©ºå­—ç¬¦ä¸²ï¼Œä½†ä½ ä¸èƒ½ä¾èµ–è¿™ä¸€ç‚¹ï¼Œåªèƒ½å¯¹å®ƒè¿›è¡Œé‡æ–°èµ‹å€¼æˆ–é”€æ¯ std::cout str after move: \\ str \\ std::endl; // å¯èƒ½æ˜¯ std::cout new_str: \\ new_str \\ std::endl; // Hello World return 0;//std::move(str) å°±æ˜¯ä¸€ä¸ªå°†äº¡å€¼ã€‚å®ƒä¸æ˜¯ä¸€ä¸ªæ–°åˆ›å»ºçš„å€¼ï¼ˆä¸æ˜¯çº¯å³å€¼ï¼‰ï¼Œè€Œæ˜¯å³å°†å¤±æ•ˆçš„ç°æœ‰å¯¹è±¡ str çš„å¦ä¸€ç§è¡¨ç°å½¢å¼//ä¸»è¦äº§ç”Ÿæ–¹æ³•ï¼š//1. std::move(a);A a;auto c = std::move(a); // std::move(a) æ˜¯ä¸€ä¸ªå°†äº¡å€¼//2.static_castA(a)A a;auto d = static_castA(a); // static_castA(a) æ˜¯ä¸€ä¸ªå°†äº¡å€¼ å·¦å€¼ã€å³å€¼å¼•ç”¨: å³å€¼å¼•ç”¨ã€‚æ˜¯ä¸€ç§ç‰¹æ®Šçš„å¼•ç”¨ç±»å‹ï¼Œä¸»è¦è®¾è®¡ç”¨æ¥ç»‘å®šåˆ°å³å€¼ï¼ˆç‰¹åˆ«æ˜¯å°†äº¡å€¼ï¼‰ï¼Œå¹¶è¡¨æ˜æ‰€å¼•ç”¨çš„å¯¹è±¡èµ„æºå¯ä»¥è¢«å®‰å…¨åœ°â€ç§»åŠ¨â€æˆ–â€çªƒå–â€ã€‚ int a=5;int b=a;//bæ˜¯å·¦å€¼å¼•ç”¨b=4;int c = 10;//errorï¼Œ10æ— æ³•å–åœ°å€ï¼Œæ— æ³•è¿›è¡Œå¼•ç”¨const int d = 10;//okï¼Œå› ä¸ºæ˜¯å¸¸å¼•ç”¨ï¼Œå¼•ç”¨å¸¸é‡æ•°å­—ï¼Œè¿™ä¸ªå¸¸é‡æ•°å­—ä¼šå­˜å‚¨åœ¨å†…å­˜ä¸­ï¼Œå¯ä»¥å–åœ°å€int a=4;int b=a;//error,aæ˜¯å·¦å€¼int c=std::move(a);//ok ç§»åŠ¨è¯­ä¹‰æµ…æ‹·è´å®¹æ˜“å¯¼è‡´èµ„æºé‡å¤é‡Šæ”¾ç­‰é—®é¢˜ï¼Œæ·±æ‹·è´ä¼šå¯¼è‡´é¢å¤–çš„å¼€é”€ã€‚ å› æ­¤å¼•å…¥äº†ç§»åŠ¨è¯­ä¹‰ï¼Œä¹Ÿå°±æ˜¯å®ç°äº†æ‰€æœ‰æƒç®¡ç†ï¼Œå·æ‰ä¸€äº›å°†äº¡å€¼çš„èµ„æº C++ä¸­æ‰€æœ‰çš„STLéƒ½å®ç°äº†ç§»åŠ¨è¯­ä¹‰ï¼Œæ–¹ä¾¿ä½¿ç”¨ã€‚ å®ç°ç§»åŠ¨è¯­ä¹‰çš„å…³é”®ç»„ä»¶ 1.å³å€¼å¼•ç”¨ï¼ˆT) 2.ç§»åŠ¨æ„é€ å‡½æ•° class MyString private: char* m_data; size_t m_size; public: // ç§»åŠ¨æ„é€ å‡½æ•° MyString(MyString other) noexcept : m_data(other.m_data), m_size(other.m_size) // å·èµ„æº // å°†æºå¯¹è±¡ç½®äºæœ‰æ•ˆä½†ç©ºçš„çŠ¶æ€ other.m_data = nullptr; other.m_size = 0; ; 3.ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ class MyString public: // ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦ MyString operator=(MyString other) noexcept if (this != other) delete[] m_data; // é‡Šæ”¾å½“å‰èµ„æº // å·èµ„æº m_data = other.m_data; m_size = other.m_size; // ç½®ç©ºæºå¯¹è±¡ other.m_data = nullptr; other.m_size = 0; return *this; ;//èµ‹å€¼å’Œæ„é€ çš„åŒºåˆ«ï¼šèµ‹å€¼æ˜¯æ›¿æ¢ï¼Œæ„é€ æ˜¯åˆ›å»ºåŠ èµ‹å€¼ ç¼–è¯‘å™¨ä¼˜åŒ–ï¼šRVONRVOç°ä»£ç¼–è¯‘å™¨ä¼šè¿›è¡Œè¿”å›å€¼ä¼˜åŒ–ï¼ˆRVOï¼‰å’Œå‘½åè¿”å›å€¼ä¼˜åŒ–ï¼ˆNRVOï¼‰ï¼Œæœ‰æ—¶ç”šè‡³æ¯”ç§»åŠ¨è¯­ä¹‰æ›´é«˜æ•ˆ è¿”å›å€¼ä¼˜åŒ–çš„æ—¶æœºï¼š returnçš„å€¼ç±»å‹ä¸å‡½æ•°çš„è¿”å›å€¼ç±»å‹ç›¸åŒ returnçš„æ˜¯ä¸€ä¸ªå±€éƒ¨å¯¹è±¡ MyString create_string() return MyString(Hello); // RVOï¼šç›´æ¥åœ¨ç›®æ ‡ä½ç½®æ„é€ ï¼Œæ— æ‹·è´æ— ç§»åŠ¨MyString create_string_nrvo() MyString result(Hello); return result; // NRVOï¼šç›´æ¥åœ¨ç›®æ ‡ä½ç½®æ„é€ result å®Œç¾è½¬å‘å®Œç¾è½¬å‘æŒ‡çš„æ˜¯åœ¨å‡½æ•°æ¨¡æ¿ä¸­ï¼Œå°†å‚æ•°ä»¥åŸå§‹çš„å€¼ç±»åˆ«ï¼ˆå·¦å€¼æˆ–å³å€¼ï¼‰å’Œconstvolatileé™å®šç¬¦å®Œå…¨ä¸å˜åœ°è½¬å‘ç»™å¦ä¸€ä¸ªå‡½æ•°ã€‚ ç®€å•æ¥è¯´ï¼šä¿æŒå‚æ•°çš„æ‰€æœ‰ç‰¹æ€§ä¸å˜åœ°ä¼ é€’ä¸‹å»ã€‚ ä¸ºä»€ä¹ˆéœ€è¦å®Œç¾è½¬å‘ï¼Ÿåœ¨æ²¡æœ‰å®Œç¾è½¬å‘ä¹‹å‰ï¼Œæ³›å‹ç¼–ç¨‹ä¸­ä¼šé‡åˆ°å‚æ•°ç±»åˆ«ä¸¢å¤±çš„é—®é¢˜ï¼š void wrapper(Foo arg) callee(arg); void wrapper(const Foo arg) callee(arg); void wrapper(Foo arg) callee(std::move(arg)); ä½¿ç”¨æ¨¡æ¿å¯ä»¥ç®€åŒ– templatetypename Tvoid wrapper(T arg) callee(arg); ä½†é—®é¢˜æ˜¯ï¼š å¦‚æœä¼ çš„æ˜¯å³å€¼ï¼ŒT ä¼šæ¨å¯¼æˆ éå¼•ç”¨ç±»å‹ï¼Œå¯¼è‡´å³å€¼å˜æˆå·¦å€¼ï¼Œä¾‹å¦‚è°ƒç”¨wrapper(42);æ—¶æ¨¡æ¿ä¼šç¿»è¯‘æˆwarpper(int);ä¼šç”¨å³å€¼åˆå§‹åŒ–ä¸ºä¸€ä¸ªæ–°çš„å±€éƒ¨å˜é‡argï¼Œå˜æˆäº†å·¦å€¼ã€‚ constvolatile å±æ€§ä¹Ÿå¯èƒ½ä¸¢å¤±ã€‚ ä¸‡èƒ½å¼•ç”¨ä¸å¼•ç”¨æŠ˜å  templatetypename Tvoid wrapper(T arg); è¿™é‡Œçš„T å½“ä¼ å…¥å³å€¼æ—¶ï¼šT æ¨å¯¼ä¸º Uï¼Œäºæ˜¯å‚æ•°ç±»å‹ä¸º U â†’ å³å€¼å¼•ç”¨ï¼› å½“ä¼ å…¥å·¦å€¼æ—¶ï¼šT æ¨å¯¼ä¸º Uï¼Œäºæ˜¯å‚æ•°ç±»å‹ä¸º U â†’ å¼•ç”¨æŠ˜å  â†’ Uã€‚ å¼•ç”¨æŠ˜å è§„åˆ™ï¼š â†’ â†’ â†’ â†’ æ‰€ä»¥ T åœ¨æ¨¡æ¿ä¸­æ—¢èƒ½ç»‘å®šå·¦å€¼ï¼Œä¹Ÿèƒ½ç»‘å®šå³å€¼ã€‚ std::forwardåœ¨ wrapper ä¸­ç›´æ¥å†™ï¼š callee(arg); ä¼šæŠŠæ‰€æœ‰å‚æ•°å½“æˆå·¦å€¼ä¼ é€’ï¼Œå³å€¼çš„æ€§è´¨ä¸¢å¤±ã€‚ éœ€è¦ç”¨ std::forwardT(arg) æ¥â€œæ¡ä»¶è½¬å‘â€ï¼š å¦‚æœ T æ¨å¯¼ä¸º Uï¼Œåˆ™ std::forwardT(arg) è¿”å› Uã€‚ å¦‚æœ T æ¨å¯¼ä¸º Uï¼Œåˆ™ std::forwardT(arg) è¿”å› Uã€‚ è¿™æ ·å³å€¼ä¿æŒå³å€¼ï¼Œå·¦å€¼ä¿æŒå·¦å€¼ï¼Œå®ç°å®Œç¾è½¬å‘ã€‚ å…¸å‹å†™æ³•#include iostream#include utilityvoid callee(int x) std::cout callee(int) ;void callee(const int x) std::cout callee(const int) ;void callee(int x) std::cout callee(int) ;templatetypename Tvoid wrapper(T arg) callee(std::forwardT(arg)); // å®Œç¾è½¬å‘int main() int a = 42; const int b = 100;\t//æ€è€ƒè¾“å‡ºï¼Ÿ wrapper(a); // callee(int) wrapper(b); // callee(const int) wrapper(10); // callee(int) å…¸å‹åº”ç”¨åœºæ™¯1.å£³å‡½æ•° ä¾‹å¦‚æ—¥å¿—ã€è£…é¥°å™¨æ¨¡å¼ã€å‡½æ•°è°ƒç”¨è®¡æ—¶å™¨ templatetypename F, typename... Argsvoid log_and_call(F f, Args... args) std::cout Calling function... ; std::forwardF(f)(std::forwardArgs(args)...); 2.å®¹å™¨æ„é€ å™¨ //vector::emplace_back, map::emplace templatetypename... Argsvoid emplace_back(Args... args) new (storage[size++]) T(std::forwardArgs(args)...); // push_backï¼šéœ€è¦æ˜¾å¼ç§»åŠ¨ names.push_back(std::move(temp)); // ç§»åŠ¨è¯­ä¹‰ // emplace_backï¼šå®Œç¾è½¬å‘å‚æ•°ï¼Œç›´æ¥æ„é€  names.emplace_back(David); // ç›´æ¥åœ¨vectorä¸­æ„é€ ï¼Œæ›´é«˜æ•ˆï¼ 2.æ™ºèƒ½æŒ‡é’ˆC++11 æ ‡å‡†åº“åœ¨ memory å¤´æ–‡ä»¶ä¸­æä¾›äº†ä¸‰ç§ä¸»è¦æ™ºèƒ½æŒ‡é’ˆï¼š std::unique_ptr std::shared_ptr std::weak_ptr unique_ptrstd::unique_ptræ˜¯ä¸€ä¸ªç‹¬å å‹çš„æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒä¸å…è®¸å…¶å®ƒæ™ºèƒ½æŒ‡é’ˆå…±äº«å…¶å†…éƒ¨æŒ‡é’ˆï¼Œä¹Ÿä¸å…è®¸unique_ptrçš„æ‹·è´å’Œèµ‹å€¼ã€‚ #include iostream#include memorystruct Foo Foo() std::cout Foo ctor ; ~Foo() std::cout Foo dtor ; ;int main() std::unique_ptrFoo p1(new Foo()); // ç‹¬å æ‰€æœ‰æƒ // std::unique_ptrFoo p2 = p1; // é”™è¯¯ï¼Œä¸èƒ½æ‹·è´ std::unique_ptrFoo p3 = std::move(p1); // å¯ä»¥è½¬ç§»æ‰€æœ‰æƒ if (!p1) std::cout p1 is empty ; å…¶å†…éƒ¨å°±æ˜¯å¯¹æŒ‡é’ˆåŒ…äº†ä¸€å±‚ã€ç„¶åç¦ç”¨å…¶æ‹·è´æ„é€ ã€èµ‹å€¼å‡½æ•°ï¼š templatetypename T, typename Deleter = std::default_deleteTclass unique_ptr private: T* ptr; // åŸå§‹æŒ‡é’ˆ Deleter del; // åˆ é™¤å™¨ï¼Œé»˜è®¤è°ƒç”¨ deletepublic: explicit unique_ptr(T* p = nullptr) : ptr(p) ~unique_ptr() if (ptr) del(ptr); // ç¦æ­¢æ‹·è´ unique_ptr(const unique_ptr) = delete; unique_ptr operator=(const unique_ptr) = delete; // æ”¯æŒç§»åŠ¨ unique_ptr(unique_ptr other) noexcept : ptr(other.ptr) other.ptr = nullptr; unique_ptr operator=(unique_ptr other) noexcept if (this != other) reset(); ptr = other.ptr; other.ptr = nullptr; return *this; T* get() const return ptr; T operator*() const return *ptr; T* operator-() const return ptr; void reset(T* p = nullptr) if (ptr) del(ptr); ptr = p; ; shared_ptr shared_ptr ä½¿ç”¨äº†å¼•ç”¨è®¡æ•°ï¼Œæ¯ä¸€ä¸ªshared_ptrçš„æ‹·è´éƒ½æŒ‡å‘ç›¸åŒçš„å†…å­˜ï¼Œæ¯æ¬¡æ‹·è´éƒ½ä¼šè§¦å‘å¼•ç”¨è®¡æ•°+1ï¼Œ æ¯æ¬¡ç”Ÿå‘½å‘¨æœŸç»“æŸææ„çš„æ—¶å€™å¼•ç”¨è®¡æ•°-1ï¼Œåœ¨æœ€åä¸€ä¸ªshared_ptrææ„çš„æ—¶å€™ï¼Œå†…å­˜æ‰ä¼šé‡Šæ”¾ã€‚ æ³¨æ„ç‚¹ï¼š å¯ä»¥è‡ªå®šä¹‰åˆ é™¤å™¨ï¼Œåœ¨å¼•ç”¨è®¡æ•°ä¸º0çš„æ—¶å€™è‡ªåŠ¨è°ƒç”¨åˆ é™¤å™¨æ¥é‡Šæ”¾å¯¹è±¡çš„å†…å­˜ï¼š std::shared_ptrptr(newint,[](int*p)deletep;);std::shared_ptrptr(newint,[](int*p)deletep;); ä¸è¦ç”¨ä¸€ä¸ªè£¸æŒ‡é’ˆåˆå§‹åŒ–å¤šä¸ªshared_ptrï¼Œä¼šå‡ºç°double_freeå¯¼è‡´ç¨‹åºå´©æºƒ é€šè¿‡shared_from_this()è¿”å›thisæŒ‡é’ˆï¼Œä¸è¦æŠŠthisæŒ‡é’ˆä½œä¸ºshared_ptrè¿”å›å‡ºæ¥ï¼Œå› ä¸ºthisæŒ‡é’ˆæœ¬è´¨å°± æ˜¯è£¸æŒ‡é’ˆï¼Œé€šè¿‡thisè¿”å›å¯èƒ½ä¼šå¯¼è‡´é‡å¤ææ„ï¼Œä¸èƒ½æŠŠthisæŒ‡é’ˆäº¤ç»™æ™ºèƒ½æŒ‡é’ˆç®¡ç†ã€‚ classA shared_ptrAGetSelf() returnshared_from_this(); //returnshared_ptrA(this);é”™è¯¯ï¼Œä¼šå¯¼è‡´doublefree ; å°½é‡ä½¿ç”¨make_sharedï¼Œå°‘ç”¨newã€‚ ä¸è¦delete get()è¿”å›æ¥çš„è£¸æŒ‡é’ˆã€‚ è¦é¿å…å¾ªç¯å¼•ç”¨ï¼Œå¾ªç¯å¼•ç”¨å¯¼è‡´å†…å­˜æ°¸è¿œä¸ä¼šè¢«é‡Šæ”¾ï¼Œé€ æˆå†…å­˜æ³„æ¼ã€‚ #include iostream#include memorystruct Node std::shared_ptrNode next; std::shared_ptrNode prev; ~Node() std::cout Node destroyed ; ;int main() auto n1 = std::make_sharedNode(); auto n2 = std::make_sharedNode(); n1-next = n2; n2-prev = n1; std::cout main end ; mainå‡½æ•°è§£é‡Šæ—¶ï¼Œæ ˆä¸Šçš„ n1 è¢«é”€æ¯ - n1å¯¹è±¡ è®¡æ•° -1 1 æ ˆä¸Šçš„ n2 è¢«é”€æ¯ - n2å¯¹è±¡ è®¡æ•° -1 1 ä¸¤è€…çš„å¼•ç”¨è®¡æ•°éƒ½ä¸ä¸º0 ï¼Œå¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼ å®ç°ï¼š templatetypename Tclass shared_ptr private: T* ptr; // æŒ‡å‘èµ„æº ControlBlock* ctrl; // æ§åˆ¶å—ï¼ˆåŒ…å«å¼•ç”¨è®¡æ•°ï¼‰ struct ControlBlock size_t strong_count; // å¼ºå¼•ç”¨è®¡æ•°ï¼ˆshared_ptr æ•°é‡ï¼‰ size_t weak_count; // å¼±å¼•ç”¨è®¡æ•°ï¼ˆweak_ptr æ•°é‡ï¼‰ ControlBlock() : strong_count(1), weak_count(0) ;public: explicit shared_ptr(T* p = nullptr) ptr = p; if (p) ctrl = new ControlBlock(); else ctrl = nullptr; ~shared_ptr() release(); void release() if (ctrl) if (--ctrl-strong_count == 0) delete ptr; // æœ€åä¸€ä¸ªå¼ºå¼•ç”¨é”€æ¯èµ„æº if (ctrl-weak_count == 0) delete ctrl; // æ§åˆ¶å—ä¹Ÿé”€æ¯ // æ‹·è´æ„é€ ï¼šå¢åŠ  strong_count shared_ptr(const shared_ptr other) ptr = other.ptr; ctrl = other.ctrl; if (ctrl) ctrl-strong_count++; // ç§»åŠ¨æ„é€ ï¼šè½¬ç§»æ‰€æœ‰æƒ shared_ptr(shared_ptr other) noexcept ptr = other.ptr; ctrl = other.ctrl; other.ptr = nullptr; other.ctrl = nullptr; // è®¡æ•°æ¥å£ size_t use_count() const return ctrl ? ctrl-strong_count : 0; ; weak_ptrè§£å†³å¾ªç¯å¼•ç”¨å¯èƒ½å‡ºç°å†…å­˜æ³„æ¼çš„é—®é¢˜ å¼±å¼•ç”¨ä¸å‚ä¸èµ„æºçš„ç®¡ç† #include iostream#include memorystruct Node std::shared_ptrNode next; std::weak_ptrNode prev; // æ”¹æˆ weak_ptr ~Node() std::cout Node destroyed ; ;int main() auto n1 = std::make_sharedNode(); auto n2 = std::make_sharedNode(); n1-next = n2; n2-prev = n1; // weak_ptrï¼Œä¸å¢åŠ  strong_count std::cout main end ; åœ¨ä½¿ç”¨ weak_ptr è®¿é—®å¯¹è±¡æ—¶ï¼Œå¿…é¡»æ£€æŸ¥å…¶æœ‰æ•ˆæ€§ã€‚ 3.å‡½æ•°å¼ç¼–ç¨‹ std::fuctionä¸lambdalambdaè¡¨è¾¾å¼ï¼Œæä¾›åŒ¿åå‡½æ•°çš„æ–¹å¼ï¼Œå¿«é€Ÿå®šä¹‰å’Œä½¿ç”¨å‡½æ•°å¯¹è±¡ è¦æ³¨æ„æ‚¬ç©ºå¼•ç”¨ std::functionvoid() createCallback() int local_var = 42; // å±é™©ï¼æ•è·äº†å±€éƒ¨å˜é‡ local_var çš„å¼•ç”¨ return []() std::cout local_var; ; // local_var åœ¨è¿™é‡Œè¢«é”€æ¯int main() auto cb = createCallback(); cb(); // æœªå®šä¹‰è¡Œä¸ºï¼æ‰“å°çš„æ˜¯å·²é”€æ¯æ ˆä¸Šçš„åƒåœ¾å€¼ã€‚ for(int id = enCoef9_Rr ; id = enCoef9_Bb ;id++) connect(m_spinBoxs[id],QOverloaddouble::of(QDoubleSpinBox::valueChanged),this,[](double value) OnCoefMatrixSlot(id,value);//id æ’ç­‰äº 0,æœªå®šä¹‰è¡Œä¸º ); é»˜è®¤æƒ…å†µä¸‹ï¼Œä»¥å€¼æ–¹å¼ [=] æ•è·çš„å˜é‡åœ¨ Lambda ä½“ä¸­æ˜¯ const çš„ã€‚å¦‚æœä½ æƒ³ä¿®æ”¹å®ƒä»¬ï¼Œå¿…é¡»åœ¨å‚æ•°åˆ—è¡¨ååŠ ä¸Š mutable å…³é”®å­—ã€‚ int main() int count = 0; // é”™è¯¯ï¼šæ— æ³•åœ¨é mutable lambda ä¸­ä¿®æ”¹æŒ‰å€¼æ•è·çš„å˜é‡ // auto f = [count]() count++; ; // æ­£ç¡®ï¼šä½¿ç”¨ mutable auto f = [count]() mutable count++; std::cout count; // è¾“å‡ºçš„æ˜¯å‰¯æœ¬ï¼Œå¤–éƒ¨çš„ count ä¸å˜ ; f(); // è¾“å‡º 1 std::cout count; // è¾“å‡º 0 ï¼ˆå¤–éƒ¨å˜é‡æœªè¢«ä¿®æ”¹ï¼‰ std::fuctioné€šç”¨çš„å‡½æ•°åŒ…è£…å™¨ï¼Œä¸ºå„ç§å¯è°ƒç”¨å®ä½“ï¼ˆæ™®é€šå‡½æ•°ã€å‡½æ•°æŒ‡é’ˆã€lambdaã€std::bind è¡¨è¾¾å¼ã€å‡½æ•°å¯¹è±¡ç­‰ï¼‰æä¾›äº†ä¸€ä¸ªç»Ÿä¸€çš„ç±»å‹ã€‚è¿™ä½¿å¾—æˆ‘ä»¬å¯ä»¥åƒä½¿ç”¨æ™®é€šå˜é‡ä¸€æ ·å­˜å‚¨å’Œä¼ é€’å‡½æ•°ï¼Œæå¤§åœ°å¢åŠ äº†ä»£ç çš„çµæ´»æ€§ã€‚ std::bindå®ƒå¯ä»¥ç”¨æ¥ç»‘å®šä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡çš„éƒ¨åˆ†å‚æ•°ï¼Œé‡æ–°æ’åˆ—å‚æ•°é¡ºåºï¼Œæˆ–è€…è®¾ç½®é»˜è®¤å‚æ•°ï¼Œä»è€Œç”Ÿæˆä¸€ä¸ªæ–°çš„å¯è°ƒç”¨å¯¹è±¡ #include iostream#include functionalusing namespace std::placeholders; // å¯¹äº _1, _2, _3...void print_sum(int a, int b, int c) std::cout a + b + c std::endl;void print_coordinates(int x, int y, int z) std::cout ( x , y , z ) ;class MyClass public: void member_func(int x, const std::string msg) std::cout Member func: x , msg std::endl; ;int main() // 1. ç»‘å®šå‚æ•°ï¼šå°† print_sum çš„ç¬¬ä¸‰ä¸ªå‚æ•°å›ºå®šä¸º 10 auto bind_func1 = std::bind(print_sum, _1, _2, 10); // _1 æ˜¯ç¬¬ä¸€ä¸ªå‚æ•°ï¼Œ_2 æ˜¯ç¬¬äºŒä¸ªå‚æ•° bind_func1(5, 3); // ç­‰ä»·äº print_sum(5, 3, 10); è¾“å‡º 18 // 2. é‡æ’åºå‚æ•°ï¼šæ”¹å˜å‚æ•°é¡ºåº auto bind_func2 = std::bind(print_coordinates, _3, _1, _2); // æ–°é¡ºåºï¼šç¬¬ä¸‰ã€ç¬¬ä¸€ã€ç¬¬äºŒ bind_func2(10, 20, 30); // ç­‰ä»·äº print_coordinates(30, 10, 20); è¾“å‡º (30, 10, 20) // 3. ç»‘å®šæˆå‘˜å‡½æ•° MyClass obj; // ç»‘å®šæˆå‘˜å‡½æ•°éœ€è¦ä¼ é€’ä¸€ä¸ªå¯¹è±¡å®ä¾‹çš„æŒ‡é’ˆæˆ–å¼•ç”¨ï¼ˆè¿™é‡Œç”¨ objï¼‰ // _1 å°†ä½œä¸ºæˆå‘˜å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•° (int x) auto bind_member = std::bind(MyClass::member_func, obj, _1, Hello); bind_member(42); // ç­‰ä»·äº obj.member_func(42, Hello); // 4. ä¸ std::function ç»“åˆä½¿ç”¨ std::functionvoid(int, int) func = std::bind(print_sum, _1, _2, 100); func(50, 25); // ç­‰ä»·äº print_sum(50, 25, 100); è¾“å‡º 175 return 0; 4.çº¿ç¨‹C++11 æ˜¯ C++ æ ‡å‡†ä¸­ç¬¬ä¸€æ¬¡æ­£å¼å¼•å…¥è·¨å¹³å°çš„çº¿ç¨‹åº“æ”¯æŒçš„ç‰ˆæœ¬ï¼Œå®ƒå°†å¹¶å‘å’Œå¤šçº¿ç¨‹ç¼–ç¨‹çº³å…¥äº†è¯­è¨€å’Œæ ‡å‡†åº“ï¼Œä½¿å¾—å¼€å‘è€…ä¸å†ä¾èµ– pthreadã€Windows API ç­‰å¹³å°ç‰¹å®šçš„æ¥å£ã€‚ c++11æ–°ç‰¹æ€§ä¹‹çº¿ç¨‹ç›¸å…³æ‰€æœ‰çŸ¥è¯†ç‚¹ - ç®€ä¹¦ åŸºç¡€å®ç°ï¼šstd::threadç”¨äºåˆ›å»ºå’Œç®¡ç†çº¿ç¨‹ã€‚ æ„é€ æ—¶æ¥æ”¶ä¸€ä¸ªå¯è°ƒç”¨å¯¹è±¡ï¼ˆå‡½æ•°ã€lambdaã€å‡½æ•°å¯¹è±¡ç­‰ï¼‰ï¼Œä½œä¸ºçº¿ç¨‹çš„å…¥å£ã€‚ æä¾› join()ï¼ˆé˜»å¡ç­‰å¾…å­çº¿ç¨‹ç»“æŸï¼‰å’Œ detach()ï¼ˆåˆ†ç¦»çº¿ç¨‹ï¼Œè®©å…¶åå°è¿è¡Œï¼‰ä¸¤ç§çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†æ–¹å¼ã€‚ ç¦æ­¢æ‹·è´ï¼ˆé¿å…äºŒä¹‰æ€§ï¼‰ï¼Œæ”¯æŒç§»åŠ¨è¯­ä¹‰ #include iostream#include threadvoid worker(int id) std::cout Thread id is running ;int main() std::thread t(worker, 1); t.join(); // ç­‰å¾…çº¿ç¨‹ç»“æŸ std::mutexstd::mutex m; std::lock_guardstd::mutex lock(m); // ä¸´ç•ŒåŒºstd::unique_lockstd::mutex lock(m);lock.unlock(); // å¯æå‰è§£é”lock.lock(); // å†æ¬¡åŠ é”unique_lockå¼€é”€æ¯”lock_guardæ›´å¤§ std::condition_variableç”¨äºçº¿ç¨‹ä¹‹é—´åŒæ­¥,å¿…é¡»ä¸äº’æ–¥é‡ä¸€èµ·ä½¿ç”¨ã€‚ wait(std::unique_lockstd::mutex lock, Predicate pred)ï¼šé˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°è¢«å”¤é†’ä¸”æ¡ä»¶è°“è¯ pred ä¸º trueã€‚å®ƒä¼šè‡ªåŠ¨é‡Šæ”¾é”ï¼Œå¹¶åœ¨è¢«å”¤é†’åé‡æ–°è·å–é”ã€‚ notify_one()ï¼šå”¤é†’ä¸€ä¸ªç­‰å¾…ä¸­çš„çº¿ç¨‹ï¼ˆå¦‚æœæœ‰ï¼‰ã€‚ notify_all()ï¼šå”¤é†’æ‰€æœ‰ç­‰å¾…ä¸­çš„çº¿ç¨‹ã€‚ å…¸å‹çš„ç”Ÿäº§è€…æ¶ˆè´¹è€…å†™æ³•ï¼š #include iostream#include thread#include mutex#include condition_variable#include queuestd::queueint data_queue;std::mutex mtx;std::condition_variable cv;constexpr int MAX_ITEMS = 10;void producer() for (int i = 0; i MAX_ITEMS; ++i) std::this_thread::sleep_for(std::chrono::milliseconds(100)); std::lock_guardstd::mutex lock(mtx); data_queue.push(i); std::cout Produced: i std::endl; // lock åœ¨è¿™é‡Œææ„è§£é” cv.notify_one(); // é€šçŸ¥ä¸€ä¸ªæ¶ˆè´¹è€… void consumer() while (true) std::unique_lockstd::mutex lock(mtx); // wait ä¼šé‡Šæ”¾ lockï¼Œå¹¶åœ¨è¢«å”¤é†’åé‡æ–°è·å– lock // å¦‚æœ lambda è¿”å› falseï¼Œç»§ç»­ç­‰å¾…ï¼›è¿”å› trueï¼Œåˆ™ç»§ç»­æ‰§è¡Œ cv.wait(lock, [] return !data_queue.empty(); ); int value = data_queue.front(); data_queue.pop(); lock.unlock(); // å¯ä»¥æå‰æ‰‹åŠ¨è§£é”ï¼Œå‡å°‘é”çš„æŒæœ‰æ—¶é—´ std::cout Consumed: value std::endl; if (value == MAX_ITEMS - 1) break; int main() std::thread prod(producer); std::thread cons(consumer); prod.join(); cons.join(); std::future å’Œ std::promise - å¼‚æ­¥ç»“æœstd::futureè¡¨ç¤ºä¸€ä¸ªæœªæ¥ä¼šäº§ç”Ÿçš„å€¼ï¼Œç”¨get()è·å–ç»“æœ,å¯èƒ½ä¼šé˜»å¡ std::promiseæä¾›ç»“æœçš„ç”Ÿäº§è€…ï¼Œå’Œfutureæˆå¯¹å‡ºç°ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸€ä¸ªæ˜¯ç”Ÿäº§è€…ï¼Œä¸€ä¸ªæ˜¯æ¶ˆè´¹è€… #include iostream#include thread#include futurevoid worker(std::promiseint p) int result = 42; p.set_value(result); // æŠŠç»“æœä¼ é€’å‡ºå»int main() std::promiseint p; std::futureint f = p.get_future(); std::thread t(worker, std::move(p)); std::cout Result from worker: f.get() std::endl; t.join(); #include iostream#include thread#include futurevoid worker(std::promiseint p) try throw std::runtime_error(something went wrong); catch (...) p.set_exception(std::current_exception()); // ä¼ é€’å¼‚å¸¸ int main() std::promiseint p; std::futureint f = p.get_future(); std::thread t(worker, std::move(p)); try std::cout f.get() std::endl; // è¿™é‡Œä¼šæŠ›å‡ºå¼‚å¸¸ catch (const std::exception e) std::cout Caught exception: e.what() std::endl; t.join(); std::packaged_task#include future#include iostreamint heavy_work(int x) // æ¨¡æ‹Ÿç¹é‡è®¡ç®— return x * x;int main() // å°†å‡½æ•° heavy_work åŒ…è£…æˆä¸€ä¸ªä»»åŠ¡ std::packaged_taskint(int) task(heavy_work); // è·å–ä¸ä»»åŠ¡ç»“æœå…³è”çš„ future std::futureint fut = task.get_future(); // åœ¨çº¿ç¨‹ä¸­è¿è¡Œä»»åŠ¡ï¼ˆä»»åŠ¡å¯¹è±¡ä¸å¯å¤åˆ¶ï¼Œå¿…é¡»ç§»åŠ¨ï¼‰ std::thread t(std::move(task), 10); t.detach(); // å¯ä»¥åˆ†ç¦»ï¼Œç”¨ future æ¥è·å–ç»“æœ std::cout Result: fut.get() std::endl; // è¾“å‡º 100 return 0; std::async#include iostream#include future#include chronoint compute() // æ¨¡æ‹Ÿè€—æ—¶æ“ä½œ std::this_thread::sleep_for(std::chrono::seconds(2)); return 42;int main() // å¼‚æ­¥å¯åŠ¨ compute å‡½æ•° std::futureint fut = std::async(std::launch::async, compute); // åœ¨ä¸»çº¿ç¨‹åšå…¶ä»–äº‹æƒ…... std::cout Doing other work... ; // å½“éœ€è¦ç»“æœæ—¶ï¼Œget() ä¼šé˜»å¡ç›´åˆ°ç»“æœå°±ç»ª int result = fut.get(); std::cout The answer is: result std::endl; return 0; std::atomicstd::atomic æ˜¯ä¸€ä¸ªæ¨¡æ¿ç±»ï¼ˆå¦‚ std::atomicint, std::atomicboolï¼‰ï¼Œå®ƒåŒ…è£…äº†ä¸€ä¸ªç±»å‹ï¼Œå¹¶æä¾›äº†ä¸€ç³»åˆ—ä¿è¯åŸå­æ“ä½œçš„æˆå‘˜å‡½æ•°ã€‚åŸå­æ“ä½œæ„å‘³ç€è¯¥æ“ä½œä»ä»»ä½•çº¿ç¨‹çš„è§†è§’çœ‹ï¼Œéƒ½æ˜¯ä¸å¯åˆ†å‰²çš„ #include atomicstd::atomicint counter(0);// çº¿ç¨‹ 1 (Writer)int new_value = compute_expensive_value();counter.store(new_value, std::memory_order_release); // åŸå­å†™// çº¿ç¨‹ 2 (Reader)int current_value = counter.load(std::memory_order_acquire); // åŸå­è¯»//std::atomicå…è®¸æ ¹æ®åœºæ™¯é€‰æ‹©ä¸åŒçš„åŒæ­¥å¼ºåº¦ï¼Œåœ¨ä¿è¯æ­£ç¡®æ€§çš„å‰æä¸‹è¿½æ±‚æè‡´æ€§èƒ½ã€‚//å†…å­˜é¡ºåºé€šè¿‡ std::memory_order æšä¸¾æ¥æŒ‡å®šï¼Œä½œä¸ºå‚æ•°ä¼ é€’ç»™ load, store, fetch_* ç­‰æ“ä½œã€‚counter.fetch_add(1, std::memory_order_relaxed); å…³äºå†…å­˜åºï¼Œè¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¤æ‚çš„é—®é¢˜ï¼ŒX86\\Riscvçš„ä¸åŒå¼ºå¼±å†…å­˜åºä¹Ÿæœ‰ä¸åŒå®šä¹‰ä¸å®ç°ã€‚ std::atomic_flag æ˜¯ä¸“ä¸ºå®ç°è‡ªæ—‹é”è€Œè®¾è®¡çš„æœ€ç®€å•çš„åŸå­å¸ƒå°”ç±»å‹ //è‡ªæ—‹é”æ˜¯ä¸€ç§å¿™ç­‰å¾…ï¼ˆBusy-Waitingï¼‰ é”ã€‚å½“ä¸€ä¸ªçº¿ç¨‹å°è¯•è·å–ä¸€ä¸ªå·²ç»è¢«å…¶ä»–çº¿ç¨‹æŒæœ‰çš„è‡ªæ—‹é”æ—¶ï¼Œå®ƒä¸ä¼šç«‹å³è¿›å…¥ç¡çœ çŠ¶æ€ï¼ˆåƒäº’æ–¥é”é‚£æ ·ï¼‰ï¼Œè€Œæ˜¯ä¼šåœ¨ä¸€ä¸ªå¾ªç¯ä¸­ä¸æ–­åœ°æ£€æŸ¥é”æ˜¯å¦å·²ç»è¢«é‡Šæ”¾ï¼ˆå³â€œè‡ªæ—‹â€ï¼‰ï¼Œç›´åˆ°æœ€ç»ˆè·å–åˆ°é”ä¸ºæ­¢ã€‚#include atomicclass Spinlock private: // ATOMIC_FLAG_INIT ç¡®ä¿æ ‡å¿—åˆå§‹ä¸ºâ€œæ¸…é™¤â€ï¼ˆfalseï¼‰çŠ¶æ€ std::atomic_flag lock_flag = ATOMIC_FLAG_INIT;public: void lock() // test_and_set() æ˜¯åŸå­æ“ä½œï¼š // 1. è¯»å–å½“å‰å€¼ // 2. æ— è®ºå½“å‰å€¼æ˜¯ä»€ä¹ˆï¼Œéƒ½å°†å…¶è®¾ç½®ä¸º true // 3. è¿”å›å®ƒè¯»å–åˆ°çš„**æ—§å€¼** while (lock_flag.test_and_set(std::memory_order_acquire)) // å¦‚æœæ—§å€¼æ˜¯ trueï¼Œè¯´æ˜é”å·²è¢«å ç”¨ï¼Œå¾ªç¯ç»§ç»­è‡ªæ—‹ // å¦‚æœæ—§å€¼æ˜¯ falseï¼Œè¯´æ˜æˆåŠŸè·å–é”ï¼Œå¾ªç¯ç»“æŸ // å¯é€‰ï¼šåœ¨è‡ªæ—‹ç­‰å¾…æ—¶æç¤ºCPUé™ä½åŠŸè€—æˆ–åˆ‡æ¢è¶…çº¿ç¨‹ // __builtin_ia32_pause(); // GCC/Clang intrinsic for x86 // std::this_thread::yield(); // å¦‚æœç­‰å¾…æ—¶é—´å¯èƒ½è¾ƒé•¿ï¼Œå¯ä¸»åŠ¨è®©å‡ºæ—¶é—´ç‰‡ void unlock() // å°†æ ‡å¿—æ¸…é™¤ï¼ˆè®¾ä¸ºfalseï¼‰ï¼Œé‡Šæ”¾é” lock_flag.clear(std::memory_order_release); ;// ä½¿ç”¨ç¤ºä¾‹Spinlock my_lock;int shared_data = 0;void critical_section() my_lock.lock(); // è·å–é”ï¼Œè‹¥å¤±è´¥åˆ™è‡ªæ—‹ç­‰å¾… shared_data++; // å®‰å…¨åœ°ä¿®æ”¹å…±äº«æ•°æ® // ...å…¶ä»–æ“ä½œ my_lock.unlock(); // é‡Šæ”¾é” è‡ªæ—‹é”ä¸äº’æ–¥é”çš„æ¯”è¾ƒ ç‰¹æ€§ è‡ªæ—‹é” (Spinlock) äº’æ–¥é” (Mutex, e.g., std::mutex) ç­‰å¾…æœºåˆ¶ å¿™ç­‰å¾… (Busy-Waiting)ã€‚çº¿ç¨‹åœ¨CPUä¸Šå¾ªç¯æ£€æŸ¥ï¼Œä¸æ”¾å¼ƒCPUæ—¶é—´ç‰‡ã€‚ é˜»å¡ç­‰å¾… (Blocking-Wait)ã€‚çº¿ç¨‹è¢«æ“ä½œç³»ç»ŸæŒ‚èµ·ï¼Œæ”¾å…¥ç­‰å¾…é˜Ÿåˆ—ï¼Œæ”¾å¼ƒCPUæ—¶é—´ç‰‡ã€‚ å¼€é”€ è·å–é‡Šæ”¾é”çš„å¼€é”€æå°ï¼ˆä¸»è¦æ˜¯åŸå­CPUæŒ‡ä»¤ï¼‰ã€‚ä½†ç­‰å¾…æœŸé—´æ¶ˆè€—CPUå‘¨æœŸã€‚ è·å–é‡Šæ”¾é”çš„å¼€é”€è¾ƒå¤§ï¼ˆéœ€è¦è¿›å…¥æ“ä½œç³»ç»Ÿå†…æ ¸è¿›è¡Œçº¿ç¨‹è°ƒåº¦ï¼‰ã€‚ä½†ç­‰å¾…æœŸé—´ä¸æ¶ˆè€—CPUã€‚ é€‚ç”¨åœºæ™¯ 1. ä¸´ç•ŒåŒºä»£ç éå¸¸çŸ­ï¼ˆæ‰§è¡Œé€Ÿåº¦å¿«ï¼‰ã€‚ 2. ç­‰å¾…æ—¶é—´æçŸ­ã€‚ 3. ä¸å¸Œæœ›å‘ç”Ÿçº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼ˆå› å…¶å¼€é”€å¯èƒ½æ¯”çŸ­æš‚ç­‰å¾…æ›´å¤§ï¼‰ã€‚ ä¾‹å¦‚ï¼š å†…æ ¸ç¼–ç¨‹ã€æ— é”æ•°æ®ç»“æ„ã€æ€§èƒ½å…³é”®çš„åº•å±‚ä»£ç ã€‚ 1. ä¸´ç•ŒåŒºä»£ç æ‰§è¡Œæ—¶é—´è¾ƒé•¿ã€‚ 2. ç­‰å¾…æ—¶é—´å¯èƒ½è¾ƒé•¿æˆ–ä¸å¯é¢„æµ‹ã€‚ 3. é€‚ç”¨äºç»å¤§å¤šæ•°åº”ç”¨ç¨‹åºçº§åˆ«çš„å¹¶å‘ã€‚ ä¾‹å¦‚ï¼š æ–‡ä»¶æ“ä½œã€æ•°æ®åº“è®¿é—®ã€å¤æ‚çš„è®¡ç®—è¿‡ç¨‹ã€‚ ç¼ºç‚¹ æµªè´¹CPUèµ„æºã€‚å¦‚æœé”è¢«é•¿æ—¶é—´æŒæœ‰ï¼Œè‡ªæ—‹çº¿ç¨‹ä¼šç©ºè½¬CPUï¼Œå¯¼è‡´æ€§èƒ½ä¸‹é™ï¼ˆâ€œçƒ§CPUâ€ï¼‰ã€‚ ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€ã€‚çº¿ç¨‹åˆ‡æ¢éœ€è¦ä¿å­˜å’Œæ¢å¤å¯„å­˜å™¨çŠ¶æ€ï¼Œå¼€é”€è¾ƒå¤§ã€‚ çŸ­æœŸæŒæœ‰ç”¨è‡ªæ—‹ï¼Œé•¿æœŸæŒæœ‰ç”¨äº’æ–¥ 5.ç±»å‹æ¨å¯¼autoè®©ç¼–è¯‘å™¨åœ¨ç¼–è¯‘æœŸæ ¹æ®åˆå§‹åŒ–è¡¨è¾¾å¼è‡ªåŠ¨æ¨å¯¼å‡ºå˜é‡çš„ç±»å‹ decltypeæŸ¥è¯¢ä¸€ä¸ªè¡¨è¾¾å¼ï¼ˆè€Œéåˆå§‹åŒ–å™¨ï¼‰çš„ç±»å‹ã€‚å®ƒè¿”å›è¯¥è¡¨è¾¾å¼çš„ç²¾ç¡®ç±»å‹ï¼ŒåŒ…æ‹¬å¼•ç”¨å’Œ const é™å®šç¬¦ã€‚","tags":[null]},{"title":"QtæŠ€èƒ½ç‚¹æ•´ç†","path":"/notebooks/Interview/QtæŠ€èƒ½ç‚¹æ•´ç†.html","content":"Qtä¸QMLçŸ¥è¯†æ€»ç»“Qtä¸­çš„è®¾è®¡æ¨¡å¼ä¸­é—´æ»‘åŠ¨çš„slider 2. doubleSpinBox3. iSetæ–°å»ºé¡¹ç›®çš„ä¸¤ç§æ¨¡å¼ListWidgetã€é€‰ä¸­çŠ¶æ€è®¾ç½®ä¸ºå›¾æ ‡æ¨¡å¼4.QTreeWidget æ¡†æ¶ã€è¡¨å¤´ã€æ ·å¼è¡¨ã€ä»£ç† Qt QTreeWidgetæ ‘å½¢æ§ä»¶ç”¨æ³•è¯¦è§£_qtreewidgetç”¨æ³•_ç¿ç§‘çŸ¥è¯†äº‘çš„åšå®¢-CSDNåšå®¢ 2. Qtå¤§æ¨¡å—1. Qt DPæŒ‡é’ˆ2. è§†å›¾æ¨¡å‹æœºåˆ¶3. è§†å›¾æ¡†æ¶4. QStyle é«˜åº¦è‡ªå®šä¹‰å®ç°5. å…ƒå¯¹è±¡ä¸ä¿¡å·æ§½æœºåˆ¶6.æ„å»ºç³»ç»Ÿ7.QInvokeMethod8.å›½é™…åŒ–3. Qtç»†èŠ‚1. åŸºç¡€æ§ä»¶2. Undoæ“ä½œ3. svgæ“ä½œ4. Qtä¸åœ¨å¯¹è±¡æ ‘çš„å·¥å…·æ±‡æ€»5.Qtä¸­æœ‰æœ‰ç”¨çš„å®ï¼šQ_LIKELY 6.paintåœ¨installä¸­ç»˜åˆ¶ 4. Qté”¦ä¸Šæ·»èŠ±1. åŠ¨ç”»çŸ¥è¯†2. æ‹–æ‹½3. æ’ä»¶æœºåˆ¶4.æ¨¡å—åŒ–æ„å»º5. Qtä¸­çš„è®¾è®¡æ¨¡å¼1. å•ä¾‹æ¨¡å¼2. è´£ä»»é“¾æ¨¡å¼3. æ¥å£æ¨¡å¼4. é€‚é…å™¨æ¨¡å¼5.è§‚å¯Ÿè€…æ¨¡å¼ï¼Œ çº¿ç¨‹è§‚å¯Ÿã€æ—¶é—´å‹ç¼© 6.å…¨å±€ä¿¡å·å•ä¾‹è½¬å‘ç±» MAINOPERATIONVIEW_EXPORT bool MainOperationView_Init(IISetWidget ** ppWidget, QWidget * parent) if (ppWidget == nullptr || parent == nullptr) return false; *ppWidget = new CMainOperationView(parent); return true; 6. C++çŸ¥è¯†c++11æ–°ç‰¹æ€§ï¼Œæ‰€æœ‰çŸ¥è¯†ç‚¹éƒ½åœ¨è¿™äº†ï¼ - çŸ¥ä¹ (zhihu.com) this_thread ++ lambdaçš„å‘ for(int id = enCoef9_Rr ; id = enCoef9_Bb ;id++) connect(m_spinBoxs[id],QOverloaddouble::of(QDoubleSpinBox::valueChanged),this,[](double value) OnCoefMatrixSlot(id,value); ); id æ’ç­‰äº 0 å¤šç»§æ‰¿ä¸QOBject private è™šç»§æ‰¿ class CBaseprivate:\tvirtual void virtualPrivateFuntion() std::coutbase virtualPrivateFuntion;\tï¼›class CSub :public CBase\tprivate:\tvirtual void virtualPrivateFuntion() override std::coutsub virtualPrivateFuntion;\tint main()\tCBase* pObject = new CSub();\tpObject-virtualPrivateFuntion();//ç»“æœï¼šsub virtualPrivateFuntionï¼Œ//ç»“è®ºï¼šå­ç±»ç»§æ‰¿çˆ¶ç±»çš„private virtualå¯ä»¥é‡å†™ å¯å˜å‚æ•°ã€å˜å‚æ¨¡æ¿ å‡½æ•°åŒ…è£…å™¨ std::shared_ptrresetã€make_shared å³å€¼å¼•ç”¨C++åå°„å…ƒç¼–ç¨‹Metaprogram is a program about a program. 7.æ‚é¡¹QStatusBaræ’ä»¶æœºåˆ¶è§£è€¦å¿«æ·é”®ISet7.0 æ¥å£è®¾è®¡ MVC8.è½®å­1.å•ä¾‹2.å·¥ä½œçº¿ç¨‹å°è£…3.stl è¿­ä»£å™¨æ¨¡å¼å’Œé€‚é…å™¨æ¨¡å¼æŠ¥é”™æ•´ç†ï¼š QMenu æ²¡æœ‰æ·»åŠ Actionæ—¶ï¼Œä¸èƒ½ç›´æ¥visibleæˆ–è¿™execï¼› setGeometry: Unable to set geometry çš„ä¸€ç§è§£å†³åŠæ³•æ˜¯é‡å†™sizehintï¼Œè€Œä¸æ˜¯ä½¿ç”¨setFixedSizeï¼› å·¥å…·ä½¿ç”¨AddressSanitizerï¼ˆä¸é€‚ç”¨ä¸MinGWï¼‰[AddressSanitizer å®šä½åµŒå…¥å¼cc++å†…å­˜é”™è¯¯ - çŸ¥ä¹ (zhihu.com)](https://zhuanlan.zhihu.com/p/436177229#:~:text=AddressSanitizer ï¼ˆåˆå ASanï¼‰æ˜¯ C%2FC%2B%2B çš„å†…å­˜é”™è¯¯æ£€æµ‹å™¨ã€‚ AddressSanitizer ç”± google,çš„ä¸€éƒ¨åˆ†ï¼Œè€Œä» 4.8 ç‰ˆå¼€å§‹é€æ¸æˆä¸º GCC çš„ä¸€éƒ¨åˆ†ã€‚ è¿™ä¹Ÿæ„å‘³ç€å¦‚æœäº¤å‰ç¼–è¯‘å™¨ç‰ˆæœ¬ä½äº 4.8 ï¼Œæ˜¯æ— æ³•ä½¿ç”¨çš„ã€‚) Qt æ‹¾é— 008 åœ¨ Qt ä¸­ä½¿ç”¨ Address Sanitizer - ç®€ä¹¦ (jianshu.com) åœ¨Qtä¸­ä½¿ç”¨gcc 4.8.0çš„åœ°å€æ¶ˆæ¯’å‰‚(Address Sanitizer) MTunerè½¯ä»¶ã€ç²¾é€‰ã€‘åŸºäºMTunerè½¯ä»¶è¿›è¡Œqtçš„mingwç¼–è¯‘ç¨‹åºçš„å†…å­˜æ³„æ¼æ£€æµ‹_mtuneræ€ä¹ˆä½¿ç”¨_yantuguiguziPGJçš„åšå®¢-CSDNåšå®¢","tags":[null]},{"title":"ai_hpc_cuda","path":"/notebooks/Interview/ai_hpc_cuda.html","content":"NvidiaGPUCUDAç›¸å…³ï¼š1.æè¿°ä¸€ä¸‹SMçš„ç»“æ„ï¼Œåœ¨å†™kernelçš„æ—¶å€™å…±äº«å†…å­˜å¤§å°å’Œå¯„å­˜å™¨æ–‡ä»¶æ•°é‡éœ€è¦æ³¨æ„å—ï¼Ÿ SMæ˜¯NVIDIA GPUçš„æ ¸å¿ƒè®¡ç®—å•å…ƒ,åŒ…å« CUDA coreï¼Œæœ€æ ¸å¿ƒçš„åŸºæœ¬è®¡ç®—å•å…ƒï¼Œå¤„ç†æ•´å½¢å’Œå•ç²¾åº¦æµ®ç‚¹è¿ç®—ã€‚ å¯„å­˜å™¨æ–‡ä»¶ã€ Warp Schedulerçº¿ç¨‹æ•°è°ƒåº¦å™¨ï¼Œ å…±äº«å†…å­˜ L1cache ç­‰ å†™kernelæ—¶å…±äº«å†…å­˜å¤§å°å’Œå¯„å­˜å™¨æ–‡ä»¶æ•°é‡ç›´æ¥å½±å“SMçš„æ´»è·ƒçº¿ç¨‹æŸæ•°é‡ï¼ˆOccupancyï¼‰â€”-å³SMä¸ŠåŒæ—¶å¯æ‰§è¡Œçš„çº¿ç¨‹æŸæ•°ä¸æœ€å¤§å¯æ”¯æŒçº¿ç¨‹æŸæ•°çš„æ¯”ç‡ã€‚ å…±äº«å†…å­˜å¤§å°ï¼š æ³¨æ„ï¼šå¿…é¡»æ³¨æ„ã€‚å…±äº«å†…å­˜æ˜¯æŒ‰å—åˆ†é…çš„æœ‰é™èµ„æºã€‚ å½±å“ï¼šæ¯ä¸ªå—ç”³è¯·çš„å…±äº«å†…å­˜è¶Šå¤§ï¼Œä¸€ä¸ªSMä¸Šèƒ½åŒæ—¶é©»ç•™çš„çº¿ç¨‹å—å°±è¶Šå°‘ï¼Œä¼šé™ä½å ç”¨ç‡ï¼ˆOccupancyï¼‰ï¼Œå¯èƒ½å½±å“æ€§èƒ½ã€‚ å¯„å­˜å™¨æ•°é‡ï¼š æ³¨æ„ï¼šå¿…é¡»æ³¨æ„ã€‚å¯„å­˜å™¨æ˜¯æŒ‰çº¿ç¨‹åˆ†é…çš„æœ‰é™èµ„æºã€‚ å½±å“ï¼š æ¯ä¸ªçº¿ç¨‹ä½¿ç”¨çš„å¯„å­˜å™¨è¶Šå¤šï¼Œä¸€ä¸ªSMä¸Šèƒ½åŒæ—¶é©»ç•™çš„çº¿ç¨‹å°±è¶Šå°‘ï¼ŒåŒæ ·ä¼šé™ä½å ç”¨ç‡ã€‚ å¯„å­˜å™¨ä½¿ç”¨è¿‡å¤šä¼šå¯¼è‡´å¯„å­˜å™¨æº¢å‡ºï¼ˆRegister Spillingï¼‰ï¼Œç¼–è¯‘å™¨è¢«è¿«å°†å˜é‡å­˜å‚¨åˆ°æ…¢é€Ÿçš„å…¨å±€å†…å­˜ä¸­ï¼Œä¸¥é‡æŸå®³æ€§èƒ½ã€‚ 2.å…±äº«å†…å­˜å’Œå¯„å­˜å™¨åˆ†åˆ«åº”è¯¥å­˜æ”¾å“ªäº›æ•°æ®ï¼Œå…¶ç”¨é‡ä¸SMä¸Šæ´»è·ƒçš„çº¿ç¨‹å—çš„å…³ç³»ã€‚å…±äº«å†…å­˜ ä»å…¨å±€å†…å­˜é¢„åŠ è½½çš„æ•°æ®å—ã€ä¸­é—´è®¡ç®—ç»“æœï¼ˆå¦‚è§„çº¦è¿ç®—çš„å±€éƒ¨å’Œï¼‰ ä½œç”¨ï¼šåä½œã€ç¼“å­˜ã€é€šä¿¡ å¯„å­˜å™¨ çº¿ç¨‹ç§æœ‰çš„å±€éƒ¨æ•°æ® ä½œç”¨ï¼šç§æœ‰æ€§ã€é«˜æ€§èƒ½ å…³ç³» SMä¸Šçš„æ´»è·ƒçº¿ç¨‹å—æ•°é‡åŒæ—¶å—å…±äº«å†…å­˜æ€»é‡å’Œå¯„å­˜å™¨æ€»é‡çš„ç¡¬æ€§çº¦æŸï¼Œæœ€ç»ˆçš„å®é™…æ•°é‡æ˜¯ä»¥ä¸‹ä¸‰ä¸ªè®¡ç®—ç»“æœä¸­çš„æœ€å°å€¼ï¼š SMæ”¯æŒçš„æœ€å¤§çº¿ç¨‹å—æ•°ï¼ˆæ¶æ„é™åˆ¶ï¼‰ã€‚ SMå…±äº«å†…å­˜æ€»é‡ / æ¯å—ç”³è¯·çš„å…±äº«å†…å­˜å¤§å°ã€‚ SMå¯„å­˜å™¨æ€»é‡ / (æ¯çº¿ç¨‹å¯„å­˜å™¨æ•°é‡ * æ¯å—çº¿ç¨‹æ•°)ã€‚ 3.bankå†²çªæ˜¯ä»€ä¹ˆï¼Ÿæè¿°å…·ä½“ç»“æ„ï¼Œå¦‚ä½•è§£å†³ï¼ŸBankå†²çªä¸ºäº†æä¾›é«˜å¸¦å®½ï¼Œå…±äº«å†…å­˜è¢«ç‰©ç†ä¸Šåˆ’åˆ†ä¸ºè‹¥å¹²ä¸ªï¼ˆé€šå¸¸æ˜¯32ä¸ªï¼Œä¸Warpå¤§å°å¯¹åº”ï¼‰åŒæ ·å¤§å°çš„ã€èƒ½åŒæ—¶è¢«è®¿é—®çš„å†…å­˜æ¨¡å—ï¼Œè¿™äº›æ¨¡å—ç§°ä¸º Bankã€‚ ç†æƒ³æƒ…å†µï¼ˆæ— å†²çªï¼‰ï¼š å¦‚æœä¸€ä¸ªWarpä¸­çš„32ä¸ªçº¿ç¨‹åˆ†åˆ«è®¿é—®32ä¸ªä¸åŒBankä¸­çš„åœ°å€ï¼ˆæˆ–è€…è®¿é—®åŒä¸€ä¸ªBankä¸­çš„å®Œå…¨ç›¸åŒçš„ä¸€ä¸ªåœ°å€ï¼Œå³å¹¿æ’­ï¼‰ï¼Œé‚£ä¹ˆæ‰€æœ‰è¿™äº›è®¿é—®éƒ½å¯ä»¥åœ¨ä¸€ä¸ªæ—¶é’Ÿå‘¨æœŸå†…ä¸€æ¬¡æ€§å®Œæˆã€‚ å†²çªæƒ…å†µï¼š å¦‚æœä¸€ä¸ªWarpä¸­çš„å¤šä¸ªçº¿ç¨‹è®¿é—®äº†åŒä¸€ä¸ªBankä¸­çš„ä¸åŒåœ°å€ï¼Œå°±ä¼šå‘ç”ŸBankå†²çªã€‚ç¡¬ä»¶å¿…é¡»å°†è¿™äº›å†²çªçš„è®¿é—®æ‹†åˆ†æˆå¤šä¸ªæ²¡æœ‰å†²çªçš„å‘¨æœŸä¾æ¬¡æ‰§è¡Œã€‚æœ‰nä¸ªçº¿ç¨‹è®¿é—®åŒä¸€ä¸ªBankçš„ä¸åŒåœ°å€ï¼Œå°±éœ€è¦nä¸ªæ—¶é’Ÿå‘¨æœŸæ¥å®ŒæˆåŸæœ¬ä¸€ä¸ªå‘¨æœŸå°±èƒ½å®Œæˆçš„å·¥ä½œã€‚ Bankç¼–å·Bankç¼–å· (åœ°å€å­—èŠ‚åç§»é‡ 4å­—èŠ‚) % 32 è§£å†³æ ¸å¿ƒæ€è·¯æ˜¯ï¼šæ”¹å˜æ•°æ®åœ¨å…±äº«å†…å­˜ä¸­çš„å¸ƒå±€æˆ–è®¿é—®æ¨¡å¼ï¼Œç¡®ä¿ä¸€ä¸ªWarpå†…çš„çº¿ç¨‹è®¿é—®ä¸åŒçš„Bankã€‚ æ–¹æ³•ä¸€ï¼šå†…å­˜å¡«å……ï¼ˆMemory Paddingï¼‰ é—®é¢˜ï¼š åœ¨æ“ä½œäºŒç»´æ•°ç»„ï¼ˆä¾‹å¦‚çŸ©é˜µï¼‰çš„Tileæ—¶ï¼Œå¦‚æœæ•°ç»„çš„å®½åº¦æ˜¯Bankæ•°é‡ï¼ˆ32ï¼‰çš„æ•´æ•°å€ï¼Œé‚£ä¹ˆåŒä¸€è¡Œä¸­ç›¸é‚»çš„å…ƒç´ ä¼šä½äºä¸åŒçš„Bankï¼Œä½†åŒä¸€åˆ—ä¸­ç›¸é‚»çš„å…ƒç´ ä¼šå› ä¸ºå›ºå®šçš„æ­¥é•¿è€Œè½åœ¨åŒä¸€ä¸ªBanké‡Œã€‚å½“çº¿ç¨‹æŒ‰åˆ—è¯»å–æ—¶ï¼Œå°±ä¼šå¯¼è‡´ä¸¥é‡çš„Bankå†²çªã€‚ è§£å†³æ–¹æ¡ˆï¼š åœ¨å£°æ˜å…±äº«å†…å­˜æ•°ç»„æ—¶ï¼Œäººä¸ºåœ°ç»™æ¯ä¸€è¡Œå¢åŠ ä¸€äº›å¤šä½™çš„â€œå¡«å……â€å…ƒç´ ï¼Œä½¿å®é™…çš„è¡Œé•¿ï¼ˆPitchï¼‰ä¸å†æ˜¯32çš„æ•´æ•°å€ã€‚ ç¤ºä¾‹ï¼šä¸€ä¸ª32x32çš„Tile cpp // å¯èƒ½äº§ç”ŸBankå†²çªçš„å£°æ˜__shared__ float tile[32][32];// ä½¿ç”¨å¡«å……é¿å…Bankå†²çªçš„å£°æ˜ï¼ˆä¾‹å¦‚ï¼Œå¤šåŠ 1ä¸ªå…ƒç´ ï¼‰__shared__ float tile_padded[32][33]; // 33ä¸å†æ˜¯32çš„å› æ•° è¿™æ ·ï¼ŒåŸæ¥åœ¨åŒä¸€åˆ—ä¸Šçš„å…ƒç´  tile[0][0], tile[1][0], tile[2][0]â€¦ ç°åœ¨å˜æˆäº† tile_padded[0][0], tile_padded[1][0], tile_padded[2][0]â€¦ã€‚è®¡ç®—å®ƒä»¬çš„Bankç¼–å·ï¼š (0 / 4) % 32 = 0 ( (1 * 33 * 4) / 4 ) % 32 = (33) % 32 = 1 ( (2 * 33 * 4) / 4 ) % 32 = (66) % 32 = 2å®ƒä»¬è¢«å·§å¦™åœ°åˆ†æ•£åˆ°äº†ä¸åŒçš„Bankä¸­ï¼Œä»è€Œé¿å…äº†å†²çªã€‚ æ–¹æ³•äºŒï¼šæ”¹å˜è®¿é—®æ¨¡å¼æˆ–ç®—æ³•è®¾è®¡æ ¸å‡½æ•°æ—¶ï¼Œå°½é‡è®©ä¸€ä¸ªWarpå†…çš„çº¿ç¨‹è®¿é—®è¿ç»­çš„å…±äº«å†…å­˜åœ°å€ã€‚å› ä¸ºè¿ç»­åœ°å€é€šå¸¸æ˜ å°„åˆ°ä¸åŒçš„Bankï¼Œè¿™æ˜¯æœ€å‹å¥½çš„è®¿é—®æ¨¡å¼ã€‚ æ–¹æ³•ä¸‰ï¼šä½¿ç”¨ä¸åŒçš„å¹¿æ’­æœºåˆ¶å¦‚æœç¡®å®éœ€è¦è®©å¤šä¸ªçº¿ç¨‹è¯»å–åŒä¸€ä¸ªå€¼ï¼Œåº”å°½é‡ç¡®ä¿å®ƒä»¬è®¿é—®çš„æ˜¯å®Œå…¨ç›¸åŒçš„åœ°å€ï¼Œè¿™ä¼šè§¦å‘å¹¿æ’­æœºåˆ¶ï¼Œåœ¨ä¸€ä¸ªå‘¨æœŸå†…å®Œæˆæ“ä½œï¼Œè€Œä¸æ˜¯äº§ç”Ÿå†²çªã€‚ 4.è¯´ä¸€ä¸‹åˆ†æ”¯å†²çªï¼ˆçº¿ç¨‹æŸåˆ†åŒ–ï¼‰ï¼Œå¦‚æœwarpå†…æœ‰å†²çªï¼Œéƒ¨åˆ†ç¬¦åˆifæ¡ä»¶ï¼Œéƒ¨åˆ†ç¬¦åˆelseæ¡ä»¶ï¼Œæ˜¯å¦éœ€è¦ç­‰å¾…ï¼Ÿåˆ†æ”¯å†²çªå‘ç”Ÿåœ¨åŒä¸€ä¸ªWarpå†…éƒ¨çš„çº¿ç¨‹æ‰§è¡Œäº†ä¸åŒçš„æ§åˆ¶æµè·¯å¾„æ—¶ã€‚ä¾‹å¦‚ï¼Œéƒ¨åˆ†çº¿ç¨‹æ»¡è¶³ifæ¡ä»¶ï¼Œè€Œå¦ä¸€éƒ¨åˆ†çº¿ç¨‹æ»¡è¶³elseæ¡ä»¶ã€‚ ä¸²è¡ŒåŒ–æ‰§è¡Œï¼š GPUçš„Warpè°ƒåº¦å™¨ä¼šè®©Warpå…ˆæ‰§è¡Œæ‰€æœ‰èµ°ifè·¯å¾„çš„çº¿ç¨‹ã€‚æ­¤æ—¶ï¼Œé‚£äº›æœ¬è¯¥èµ°elseè·¯å¾„çš„çº¿ç¨‹åœ¨è¿™ä¸ªé˜¶æ®µæ˜¯è¢«ç¦ç”¨ï¼ˆmasked outï¼‰ çš„ï¼Œå®ƒä»¬ä¸ä¼šæ‰§è¡Œä»»ä½•æ“ä½œï¼Œä½†å¿…é¡»ç­‰å¾…ã€‚ å†æ¬¡æ‰§è¡Œï¼š å½“ifè·¯å¾„æ‰§è¡Œå®Œæ¯•åï¼Œè°ƒåº¦å™¨ä¼šå†è®©Warpæ‰§è¡Œæ‰€æœ‰èµ°elseè·¯å¾„çš„çº¿ç¨‹ã€‚åŒæ ·ï¼Œæ­¤æ—¶èµ°ifè·¯å¾„çš„çº¿ç¨‹è¢«ç¦ç”¨å¹¶ç­‰å¾…ã€‚ æ±‡åˆåç»§ç»­ï¼š å½“æ‰€æœ‰ä¸åŒçš„æ§åˆ¶æµè·¯å¾„éƒ½æ‰§è¡Œå®Œæ¯•åï¼ŒWarpå†…çš„æ‰€æœ‰çº¿ç¨‹æ‰ä¼šåœ¨æ±‡åˆç‚¹ï¼ˆreconvergence pointï¼‰ é‡æ–°åŒæ­¥ï¼Œå¹¶ç»§ç»­ä¸€èµ·æ‰§è¡Œåç»­çš„ç›¸åŒæŒ‡ä»¤ã€‚ å› æ­¤ï¼Œåˆ†æ”¯å†²çªçš„æ€§èƒ½ä»£ä»·æ˜¯ï¼šæ‰§è¡Œæ—¶é—´å˜æˆäº†æ‰€æœ‰ä¸åŒè·¯å¾„æ‰§è¡Œæ—¶é—´çš„æ€»å’Œï¼Œè€Œä¸æ˜¯å…¶ä¸­æœ€é•¿è·¯å¾„çš„æ—¶é—´ã€‚ æ€æ ·é¿å…çº¿ç¨‹æŸåˆ†åŒ– æ ¸å¿ƒæ€æƒ³ï¼šåŒä¸€ä¸ªWarpå†…çš„æ•°æ®å…·æœ‰ç›¸åŒçš„ç‰¹æ€§ï¼Œä»è€Œæ‰§è¡Œç›¸åŒçš„æŒ‡ä»¤è·¯å¾„ã€‚ é¢„å¤„ç†æ•°æ®ï¼Œä½¿åŒä¸€Warpæ•°æ®ç‰¹å¾ä¸€è‡´ è°“è¯æ‰§è¡Œ ç”¨æ¡ä»¶èµ‹å€¼ ?: æ›¿ä»£çŸ­å°çš„ if-else 5.ç”¨è¿‡TensorCoreå—ï¼Ÿäº†è§£TensorCoreçš„åŸç†å—ï¼ŸTensor Coreæ˜¯ä¸€ç§ä¸“ä¸ºæ‰§è¡ŒçŸ©é˜µä¹˜ç´¯åŠ è¿ç®—è€Œè®¾è®¡çš„ä¸“ç”¨ç¡¬ä»¶å•å…ƒï¼Œä»Voltaæ¶æ„å¼€å§‹å¼•å…¥ã€‚å…¶æ ¸å¿ƒåŸç†å¯ä»¥æ¦‚æ‹¬ä¸ºï¼š 1. è®¡ç®—æ¨¡å¼ï¼šD A * B + Cå®ƒçš„æ ¸å¿ƒæ˜¯æ‰§è¡Œä¸€ä¸ªå›ºå®šçš„è®¡ç®—æ“ä½œï¼šæ¥æ”¶ä¸¤ä¸ªå°çŸ©é˜µAå’ŒBï¼Œä¸ä¸€ä¸ªç´¯åŠ çŸ©é˜µCç›¸ä¹˜åç›¸åŠ ï¼Œå¾—åˆ°ç»“æœçŸ©é˜µDã€‚ A, B, C, D éƒ½æ˜¯ç‰¹å®šç»´åº¦çš„å°çŸ©é˜µï¼ˆå¦‚ 16x16, 8x32, 32x8 ç­‰ï¼‰ã€‚ è®¡ç®—A * Bæ˜¯å®Œæ•´ç²¾åº¦çš„ï¼Œå…¶ç»“æœä¸Cç›¸åŠ åï¼Œå†ä»¥ç›®æ ‡ç²¾åº¦ï¼ˆå¦‚FP32FP16INT8ï¼‰å­˜å‚¨åˆ°Dã€‚ 2. æ··åˆç²¾åº¦è®¡ç®—ï¼šè¿™æ˜¯å…¶å®ç°æ€§èƒ½çªç ´çš„å…³é”®ã€‚å®ƒä½¿ç”¨ä½ç²¾åº¦è¾“å…¥æ¥å®ç°é«˜ååé‡å’Œä½åŠŸè€—ï¼Œä½†ä½¿ç”¨é«˜ç²¾åº¦è¿›è¡Œç´¯åŠ ä»¥ä¿æŒæ•°å€¼ç¨³å®šæ€§ã€‚ å¸¸è§æ¨¡å¼ï¼š FP16 è¾“å…¥ (A, B) + FP16 æˆ– FP32 çš„ç´¯åŠ å™¨ (C) - FP16 æˆ– FP32 è¾“å‡º (D)ã€‚ å…¶ä»–æ¨¡å¼ï¼š ä¹Ÿæ”¯æŒINT8ã€INT4ã€BF16ç­‰è¾“å…¥ç²¾åº¦ï¼Œä»¥åŠTF32ï¼ˆåœ¨AmpereåŠä»¥åæ¶æ„ä¸­ï¼‰ã€‚ 3. æé«˜çš„ååé‡ï¼šæ¯ä¸ªTensor Coreæ¯ä¸ªæ—¶é’Ÿå‘¨æœŸå¯ä»¥æ‰§è¡Œå¤§é‡çš„ä¹˜åŠ è¿ç®—ï¼ˆFMA operationsï¼‰ã€‚ä¾‹å¦‚ï¼Œä¸€ä¸ªV100çš„SMä¸­çš„æ¯ä¸ªTensor Coreæ¯å‘¨æœŸå¯ä»¥æ‰§è¡Œä¸€ä¸ª 8x4 * 4x8 - 8x8 çš„MMAæ“ä½œï¼Œè¿™ç›¸å½“äº 64 æ¬¡ä¹˜åŠ è¿ç®—ï¼ˆ128 FLOPSï¼‰ æ¯å‘¨æœŸã€‚è¿™ä¸ä¼ ç»Ÿçš„CUDA Coreï¼ˆæ¯å‘¨æœŸ1æ¬¡ä¹˜åŠ ï¼‰ç›¸æ¯”ï¼Œååé‡æå‡äº†ä¸¤ä¸ªæ•°é‡çº§ã€‚ 4. ç¼–ç¨‹æ¨¡å‹ï¼šWarp-Level OperationTensor Coreçš„æ“ä½œæ˜¯åœ¨çº¿ç¨‹æŸçº§åˆ«è¿›è¡Œçš„ã€‚ä¸€ä¸ªWarpå†…çš„çº¿ç¨‹éœ€è¦åä½œæ¥å…±åŒåŠ è½½ä¸€ä¸ªå¤§çš„è¾“å…¥çŸ©é˜µçš„å„ä¸ªå°å—ï¼ˆTileï¼‰åˆ°å¯„å­˜å™¨ä¸­ï¼Œç„¶åè°ƒç”¨ä¸€æ¡æŒ‡ä»¤ï¼ˆå¦‚wmma::mma_syncï¼‰æ¥è®©Tensor Coreç¡¬ä»¶æ‰§è¡Œæ•´ä¸ªå°çŸ©é˜µçš„è¿ç®—ã€‚ ä¸ºä»€ä¹ˆç”¨float4å‘é‡æ¥å­˜å–æ•°æ®ï¼Ÿæœ‰ä»€ä¹ˆå¥½å¤„ï¼Ÿ ä¸ºä»€ä¹ˆç”¨åŒç¼“å†²ä¼˜åŒ–ï¼Ÿäº†è§£cudaæµå’Œcuda graphå—ï¼Ÿ é™¤äº†MPIï¼Œæœ‰çŸ¥é“ç°åœ¨ç”¨çš„æ›´å¤šçš„GPUé€šä¿¡åº“å—ï¼Ÿ åœ¨Nsight Computingä¸­ï¼Œç»å¸¸å…³æ³¨çš„ä¸å†…å­˜ç›¸å…³çš„æŒ‡æ ‡ã€‚æœ‰å…³æ³¨L1 Cacheå‘½ä¸­ç‡å—ï¼Ÿ GPUæŒ‡ä»¤é›†ä¼˜åŒ–æ–¹é¢äº†è§£å—ï¼Ÿæœ‰åšè¿‡PTXç›¸å…³çš„ä¼˜åŒ–å—ï¼Ÿ GEMMæ˜¯è®¡ç®—å¯†é›†å‹è¿˜æ˜¯è®¿å­˜å¯†é›†å‹ç®—å­ï¼Ÿ çŸ¥é“cutlassä¸­å¦‚ä½•å¯¹GEMMè¿›è¡Œä¼˜åŒ–çš„å—ï¼Ÿ è®­ç»ƒæ¨ç†äº†è§£Transformerå—ï¼Ÿåº•å±‚æ˜¯ä»€ä¹ˆç»“æ„ï¼Ÿcudaä¸­å¦‚ä½•ä¼˜åŒ–ï¼Ÿè¯´ä¸€ä¸‹ä½ å¯¹å¤§æ¨¡å‹çš„ç†è§£ã€‚cudaä¸­å¦‚ä½•å†™Softmaxï¼ŸæŸä¸ªå‚æ•°è¿‡å¤§å¦‚ä½•è§£å†³ï¼ŸDropoutå’ŒBatchNormåœ¨è®­ç»ƒå’Œæ¨ç†æ—¶æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿè¯´ä¸€ä¸‹ä½ äº†è§£çš„æ— ç›‘ç£å­¦ä¹ ç®—æ³•ã€‚çŸ¥é“Faster Transformerå—ï¼Ÿæœ‰äº†è§£å¦‚ä½•å®ç°çš„å—ï¼ŸPaged Attentionæœ‰äº†è§£å—ï¼ŸçŸ¥é“TensorRTå—ï¼Ÿéƒ¨ç½²è¿‡æ¨ç†æ¨¡å‹å—ï¼Ÿ","tags":[null,null]},{"title":"ä¾¯æ·C++å†…å­˜ç®¡ç†æœºåˆ¶","path":"/notebooks/Interview/ä¾¯æ·C++å†…å­˜ç®¡ç†æœºåˆ¶.html","content":"C++å†…å­˜è°ƒç”¨ ç¬¬ä¸€èŠ‚ C++ primitives","tags":[null]},{"title":"åŠ›æ‰£åˆ·é¢˜ç¬”è®°ä¹±åº","path":"/notebooks/Interview/åŠ›æ‰£åˆ·é¢˜ç¬”è®°(ä¹±åº).html","content":"çŠ¶æ€è§„åˆ’ä¸“é¢˜119æ¨è¾‰ä¸‰è§’2 .bygbnffplspg{zoom:50%;} å…³é”®ç‚¹ ï¼š ç©ºé—´å¤æ‚åº¦O(row)","tags":[null]},{"title":"é¢ç»å¸¸è§é—®é¢˜ï¼šC++ç¯‡","path":"/notebooks/Interview/é¢ç»å¸¸è§é—®é¢˜ï¼šC++ç¯‡.html","content":"é—®é¢˜ ä¸‰ç§å¤šæ€çš„å®ç°æ–¹å¼åŠå…¶åŒºåˆ« STL å®¹å™¨åœ¨ for å¾ªç¯ä¸­ä½¿ç”¨ erase åˆ é™¤å…ƒç´ ä¼šå¯¼è‡´ä»€ä¹ˆé—®é¢˜ï¼Ÿ ä»€ä¹ˆæ˜¯Perfec t Forwardingï¼Ÿä¸ºä»€ä¹ˆè¦ä½¿ç”¨å®ƒï¼Œå®ƒè§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿå†™ä¸€ä¸‹ å®Œç¾è½¬å‘å’Œç§»åŠ¨è¯­ä¹‰çš„å®è·µåœºæ™¯ è™šå‡½æ•°è¡¨çš„å­˜å‚¨ä½ç½®å’Œå†…å­˜ç»“æ„ å•ç»§æ‰¿ã€å¤šç»§æ‰¿ã€è™šç»§æ‰¿çš„vptræ˜¯æ€æ ·çš„ï¼Ÿå¯¹åº”çš„C++å†…å­˜æ¨¡å‹æ˜¯æ€æ ·çš„ è™šå‡½æ•°èƒ½å¦æ˜¯æ¨¡æ¿å‡½æ•°ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ ææ„å‡½æ•°å£°æ˜ä¸ºè™šå‡½æ•°çš„åŸå› æ˜¯ä»€ä¹ˆï¼Ÿ C++ç±»é»˜è®¤ç”Ÿæˆçš„æˆå‘˜å‡½æ•°æœ‰å“ªäº›ï¼Ÿ å·¦å€¼å’Œå³å€¼çš„åŒºåˆ«ä¸åº”ç”¨åœºæ™¯ Name Manglingçš„ä½œç”¨åŠå…¶å¸¦æ¥çš„å…¼å®¹æ€§é—®é¢˜ åŠ¨æ€åº“å’Œé™æ€åº“çš„ä¼˜ç¼ºç‚¹å¯¹æ¯” å‚è€ƒå›ç­” ä¸‰ç§å¤šæ€çš„å®ç°æ–¹å¼åŠå…¶åŒºåˆ« é™æ€å¤šæ€å’ŒåŠ¨æ€å¤šæ€ï¼šå‡½æ•°é‡è½½ã€è¿ç®—ç¬¦é‡è½½ã€æ³›å‹ç¼–ç¨‹ä¸æ¨¡æ¿ï¼ˆç‰¹åˆ«çš„CRTPï¼‰ï¼ˆç¼–è¯‘æœŸå¤šæ€ï¼‰ï¼›è™šå‡½æ•° åŠ¨æ€å¤šæ€ STL å®¹å™¨åœ¨ for å¾ªç¯ä¸­ä½¿ç”¨ erase åˆ é™¤å…ƒç´ ä¼šå¯¼è‡´ä»€ä¹ˆé—®é¢˜ï¼Ÿ std::vectorint vec = 1, 2, 3, 4, 5;// é”™è¯¯æ–¹å¼ï¼šè¿­ä»£å™¨å¤±æ•ˆã€å˜æˆé‡æŒ‡é’ˆfor (auto it = vec.begin(); it != vec.end(); ++it) if (*it % 2 == 0) vec.erase(it); // it å¤±æ•ˆï¼Œåç»­ ++it æœªå®šä¹‰è¡Œä¸º // æ­£ç¡®æ–¹å¼1ï¼šåˆ©ç”¨è¿”å›å€¼for (auto it = vec.begin(); it != vec.end(); ) if (*it % 2 == 0) it = vec.erase(it); // eraseè¿”å›ä¸‹ä¸€ä¸ªæœ‰æ•ˆè¿­ä»£å™¨ else ++it; // æ­£ç¡®æ–¹å¼2ï¼šremove-eraseæƒ¯ç”¨æ³•vec.erase(std::remove_if(vec.begin(), vec.end(), [](int x) return x % 2 == 0; ), vec.end()); ä»€ä¹ˆæ˜¯Perfec t Forwardingï¼Ÿä¸ºä»€ä¹ˆè¦ä½¿ç”¨å®ƒï¼Œå®ƒè§£å†³äº†ä»€ä¹ˆé—®é¢˜ï¼Ÿå†™ä¸€ä¸‹åœ¨å‡½æ•°æ¨¡æ¿ä¸­ï¼Œä¿æŒå‚æ•°çš„åŸæœ‰ç±»å‹å’Œç‰¹æ€§ï¼ˆconstï¼‰è¿›è¡Œè½¬å‘ã€‚æ²¡æœ‰å®Œç¾è½¬å‘æ—¶ï¼Œæ³›å‹ç¼–ç¨‹ä¼šé‡åˆ°å‚æ•°ç±»åˆ«ä¸¢å¤±çš„é—®é¢˜ã€‚ä¼ å…¥å³å€¼æ—¶ï¼ŒTä¼šè¢«æ¨å¯¼æˆéå³å€¼ï¼Œconstå±æ€§ä¹Ÿä¼šæ¶ˆå¤±ï¼› templatetypename Tvoid wrapper(T arg)\tcallee(arg);\tcalleeï¼ˆstd::forwardT (arg)ï¼‰; å®Œç¾è½¬å‘å’Œç§»åŠ¨è¯­ä¹‰çš„å®è·µåœºæ™¯ æ—¥å¿—å‡½æ•°\\ è£…é¥°å™¨æ¨¡å¼ã€å®¹å™¨æ„é€ å™¨ templatetypename Tvoid log_and_call(T arg)\tstd::coutaaa;\tcall(std::forwardT arg); è™šå‡½æ•°è¡¨çš„å­˜å‚¨ä½ç½®å’Œå†…å­˜ç»“æ„ vtable åªè¯»æ•°æ®æ®µã€vptrå¯¹è±¡å†…éƒ¨ å•ç»§æ‰¿ã€å¤šç»§æ‰¿ã€è™šç»§æ‰¿çš„vptræ˜¯æ€æ ·çš„ï¼Ÿå¯¹åº”çš„C++å†…å­˜æ¨¡å‹æ˜¯æ€æ ·çš„ è™šå‡½æ•°èƒ½å¦æ˜¯æ¨¡æ¿å‡½æ•°ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ è™šå‡½æ•°ä¸èƒ½æ˜¯æ¨¡æ¿å‡½æ•°ã€‚è™šå‡½æ•°è¡¨è¦æ±‚åœ¨ç¼–è¯‘å™¨å›ºå®šå¸ƒå±€ï¼Œæ¨¡æ¿å‡½æ•°å®ä¾‹åŒ–åœ¨ç¼–è¯‘å™¨æŒ‰éœ€ç”Ÿæˆã€‚æ—¶æœºå†²çª ææ„å‡½æ•°å£°æ˜ä¸ºè™šå‡½æ•°çš„åŸå› æ˜¯ä»€ä¹ˆï¼Ÿ å½“ä¸€ä¸ªæ´¾ç”Ÿç±»å¯¹è±¡é€šè¿‡ åŸºç±»æŒ‡é’ˆ åˆ é™¤æ—¶ï¼Œå¦‚æœåŸºç±»çš„ææ„å‡½æ•° ä¸æ˜¯è™šçš„ï¼Œå°†åªä¼šè°ƒç”¨åŸºç±»ææ„å‡½æ•°ï¼Œè€Œæ´¾ç”Ÿç±»éƒ¨åˆ†ä¸ä¼šè¢«ææ„ï¼Œé€ æˆ èµ„æºæ³„æ¼ æˆ– æœªå®šä¹‰è¡Œä¸ºã€‚ C++ç±»é»˜è®¤ç”Ÿæˆçš„æˆå‘˜å‡½æ•°æœ‰å“ªäº›ï¼Ÿ é»˜è®¤æ„é€ ã€æ‹·è´ã€ææ„ã€ç§»åŠ¨ã€æ‹·è´èµ‹å€¼ä¸ç§»åŠ¨èµ‹å€¼ å·¦å€¼å’Œå³å€¼çš„åŒºåˆ«ä¸åº”ç”¨åœºæ™¯ Name Manglingçš„ä½œç”¨åŠå…¶å¸¦æ¥çš„å…¼å®¹æ€§é—®é¢˜ åŠ¨æ€åº“å’Œé™æ€åº“çš„ä¼˜ç¼ºç‚¹å¯¹æ¯” RAIIè®¾è®¡æ¨¡å¼çš„å®é™…åº”ç”¨æ¡ˆä¾‹"},{"title":"é¢ç»å¸¸è§é—®é¢˜ï¼šæ“ä½œç³»ç»Ÿä¸ä½“ç³»ç»“æ„ç¯‡","path":"/notebooks/Interview/é¢ç»å¸¸è§é—®é¢˜ï¼šæ“ä½œç³»ç»Ÿä¸ä½“ç³»ç»“æ„ç¯‡.html","content":"é—®é¢˜ è¯·æè¿°ä»ç”¨æˆ·æ€è°ƒç”¨ read å‡½æ•°è¯»å–æ–‡ä»¶æ•°æ®ï¼Œåˆ°è·å–æ•°æ®ï¼Œä¸­é—´å®Œæ•´çš„å†…æ ¸å¤„ç†è¿‡ç¨‹æ˜¯æ€æ ·çš„ï¼Ÿ Linux å†…æ ¸çš„å†…å­˜ç®¡ç†æœºåˆ¶æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿä¸ºä»€ä¹ˆè¦å¼•å…¥è™šæ‹Ÿå†…å­˜æ¦‚å¿µï¼Ÿ ä½ å¦‚ä½•è¿›è¡ŒLinuxå†…æ ¸çš„è£å‰ªï¼Ÿå…·ä½“æ­¥éª¤å’Œè€ƒé‡æ˜¯ä»€ä¹ˆï¼Ÿ ç®€è¦è¯´æ˜Linuxæ–‡ä»¶ç³»ç»Ÿçš„åº•å±‚åŸç†å’Œç®¡ç†æœºåˆ¶ã€‚ ç¼–è¯‘å™¨ï¼ˆCompilerï¼‰å’Œè¿æ¥å™¨ï¼ˆLinkerï¼‰åœ¨ç¨‹åºæ„å»ºè¿‡ç¨‹ä¸­åˆ†åˆ«èµ·ä»€ä¹ˆä½œç”¨ï¼Ÿ NUMAå’ŒéNUMAæ¶æ„çš„åŒºåˆ«ï¼Ÿä¼˜åŠ¿ ä»€ä¹ˆæ˜¯ç¼“å­˜ä¸€è‡´æ€§åè®®ï¼Œå¦‚ä½•å®ç°ç¼“å­˜ä¸€è‡´æ€§åè®®ï¼Ÿ ä¸‰ä¸ªå±‚çº§cacheå»¶è¿Ÿæ—¶é—´åˆ†åˆ«å¤§çº¦å¤šå°‘ï¼Ÿ è¿›ç¨‹é—´é€šä¿¡çš„å‡ ç§ä¸»è¦æ–¹å¼ newå’Œmallocçš„åº•å±‚æœºåˆ¶å·®å¼‚ è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„è½¬æ¢è¿‡ç¨‹ å¤§é¡µè¡¨æŠ€æœ¯çš„é€‚ç”¨åœºæ™¯ æ€è·¯1. è¯·æè¿°ä»ç”¨æˆ·æ€è°ƒç”¨ read å‡½æ•°è¯»å–æ–‡ä»¶æ•°æ®ï¼Œåˆ°è·å–æ•°æ®ï¼Œä¸­é—´å®Œæ•´çš„å†…æ ¸å¤„ç†è¿‡ç¨‹æ˜¯æ€æ ·çš„ï¼Ÿ2. Linux å†…æ ¸çš„å†…å­˜ç®¡ç†æœºåˆ¶æ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿä¸ºä»€ä¹ˆè¦å¼•å…¥è™šæ‹Ÿå†…å­˜æ¦‚å¿µï¼Ÿ3. ä½ å¦‚ä½•è¿›è¡ŒLinuxå†…æ ¸çš„è£å‰ªï¼Ÿå…·ä½“æ­¥éª¤å’Œè€ƒé‡æ˜¯ä»€ä¹ˆï¼Ÿ4. ç®€è¦è¯´æ˜Linuxæ–‡ä»¶ç³»ç»Ÿçš„åº•å±‚åŸç†å’Œç®¡ç†æœºåˆ¶ã€‚5. ç¼–è¯‘å™¨ï¼ˆCompilerï¼‰å’Œè¿æ¥å™¨ï¼ˆLinkerï¼‰åœ¨ç¨‹åºæ„å»ºè¿‡ç¨‹ä¸­åˆ†åˆ«èµ·ä»€ä¹ˆä½œç”¨ï¼Ÿ6. NUMAå’ŒéNUMAæ¶æ„çš„åŒºåˆ«ï¼Ÿä¼˜åŠ¿7. ä»€ä¹ˆæ˜¯ç¼“å­˜ä¸€è‡´æ€§åè®®ï¼Œå¦‚ä½•å®ç°ç¼“å­˜ä¸€è‡´æ€§åè®®ï¼Ÿ æœ€è‘—åã€æœ€åŸºç¡€çš„ç¼“å­˜ä¸€è‡´æ€§åè®®æ˜¯MESIï¼Œä¹Ÿç§°ä¸ºä¼Šåˆ©è¯ºä¼Šåè®®ã€‚å®ƒé€šè¿‡ä¸ºæ¯ä¸ªç¼“å­˜è¡Œï¼ˆCache Lineï¼Œç¼“å­˜çš„åŸºæœ¬å•ä½ï¼‰ç»´æŠ¤ä¸€ä¸ªçŠ¶æ€ä½ï¼Œå¹¶é€šè¿‡æ ¸å¿ƒä¹‹é—´çš„é€šä¿¡æ¥ç»´æŠ¤çŠ¶æ€ã€‚MESIæ˜¯å››ä¸ªçŠ¶æ€çš„ç¼©å†™ï¼š M - ä¿®æ”¹ï¼ˆModifiedï¼‰ çŠ¶æ€ï¼šè¯¥ç¼“å­˜è¡Œæ˜¯â€œè„çš„â€ï¼Œå³å®ƒçš„æ•°æ®å·²è¢«å½“å‰æ ¸å¿ƒä¿®æ”¹ï¼Œä¸ä¸»å†…å­˜ä¸­çš„æ•°æ®ä¸ä¸€è‡´ã€‚è¿™æ˜¯è¯¥æ•°æ®å”¯ä¸€çš„æœ€æ–°å‰¯æœ¬ã€‚ è´£ä»»ï¼šå½“è¿™ä¸ªç¼“å­˜è¡Œè¢«æ›¿æ¢æ—¶ï¼Œå¿…é¡»å°†å…¶å†™å›ä¸»å†…å­˜ã€‚ å¯¹åº”è¡Œï¼šå…¶ä»–æ ¸å¿ƒçš„ç¼“å­˜ä¸­æ²¡æœ‰è¯¥æ•°æ®çš„å‰¯æœ¬ã€‚ E - ç‹¬å ï¼ˆExclusiveï¼‰ çŠ¶æ€ï¼šè¯¥ç¼“å­˜è¡Œæ˜¯â€œå¹²å‡€çš„â€ï¼Œå…¶æ•°æ®ä¸ä¸»å†…å­˜ä¸€è‡´ã€‚ä½†åªæœ‰å½“å‰æ ¸å¿ƒæ‹¥æœ‰è¿™ä»½å‰¯æœ¬ã€‚ ç‰¹æƒï¼šå½“å‰æ ¸å¿ƒå¯ä»¥éšæ—¶å¯¹å…¶è¿›è¡Œä¿®æ”¹ï¼Œè€Œæ— éœ€é€šçŸ¥å…¶ä»–æ ¸å¿ƒã€‚ä¸€æ—¦ä¿®æ”¹ï¼ŒçŠ¶æ€ä¼šå˜ä¸ºÂ Mã€‚ å¯¹åº”è¡Œï¼šå…¶ä»–æ ¸å¿ƒçš„ç¼“å­˜ä¸­æ²¡æœ‰è¯¥æ•°æ®çš„å‰¯æœ¬ã€‚ S - å…±äº«ï¼ˆSharedï¼‰ çŠ¶æ€ï¼šè¯¥ç¼“å­˜è¡Œæ˜¯â€œå¹²å‡€çš„â€ï¼Œæ•°æ®ä¸ä¸»å†…å­˜ä¸€è‡´ã€‚ é™åˆ¶ï¼šå¯èƒ½æœ‰å¤šä¸ªæ ¸å¿ƒçš„ç¼“å­˜ä¸­éƒ½å­˜åœ¨è¯¥æ•°æ®çš„å‰¯æœ¬ã€‚å› æ­¤ï¼Œå½“å‰æ ¸å¿ƒä¸èƒ½ç›´æ¥ä¿®æ”¹å®ƒï¼Œå¿…é¡»å…ˆä¸å…¶ä»–æ ¸å¿ƒæ²Ÿé€šã€‚ å¯¹åº”è¡Œï¼šå…¶ä»–æ ¸å¿ƒçš„ç¼“å­˜ä¸­å¯èƒ½æœ‰è¯¥æ•°æ®çš„å‰¯æœ¬ã€‚ I - æ— æ•ˆï¼ˆInvalidï¼‰ çŠ¶æ€ï¼šè¯¥ç¼“å­˜è¡Œæ˜¯æ— æ•ˆçš„ï¼Œä¸èƒ½ä½¿ç”¨ã€‚å®ƒè¦ä¹ˆæ˜¯ç©ºçš„ï¼Œè¦ä¹ˆé‡Œé¢çš„æ•°æ®æ˜¯è¿‡æ—¶çš„ã€‚ è¦æ±‚ï¼šå¦‚æœæ ¸å¿ƒè¦è¯»å–æˆ–å†™å…¥ä¸€ä¸ªå¤„äºÂ IÂ çŠ¶æ€çš„ç¼“å­˜è¡Œï¼Œå®ƒå¿…é¡»å…ˆä»å…¶ä»–æ ¸å¿ƒæˆ–ä¸»å†…å­˜ä¸­è·å–æœ€æ–°æ•°æ®ã€‚ å‡è®¾æœ‰ä¸¤ä¸ªæ ¸å¿ƒï¼ŒCore A å’Œ Core Bã€‚ åˆå§‹ï¼šå†…å­˜åœ°å€Â XÂ çš„å€¼ä¸º 10ã€‚æ²¡æœ‰æ ¸å¿ƒç¼“å­˜å®ƒã€‚ Core A è¯»å– Xï¼š Core A ç¼“å­˜æœªå‘½ä¸­ï¼Œåœ¨æ€»çº¿ä¸Šå‘é€Â Bus Readã€‚ æ— äººå“åº”ï¼Œä»å†…å­˜è¯»å–å€¼ 10ã€‚ Core A çš„ç¼“å­˜è¡ŒçŠ¶æ€å˜ä¸ºÂ Eï¼ˆç‹¬å ï¼‰ã€‚ Core B è¯»å– Xï¼š Core B ç¼“å­˜æœªå‘½ä¸­ï¼Œåœ¨æ€»çº¿ä¸Šå‘é€Â Bus Readã€‚ Core A â€œå—…æ¢â€åˆ°è¿™ä¸ªè¯·æ±‚ï¼ŒçŸ¥é“è‡ªå·±æœ‰å‰¯æœ¬ã€‚ Core A å°†æ•°æ®æä¾›ç»™ Core Bï¼Œå¹¶å°†è‡ªå·±çš„çŠ¶æ€ä»Â EÂ å˜ä¸ºÂ Sã€‚ Core B æ¥æ”¶åˆ°æ•°æ®ï¼ŒçŠ¶æ€è®¾ç½®ä¸ºÂ Sã€‚ Core A è¦å†™å…¥ Xï¼ˆæ¯”å¦‚æ”¹ä¸º 20ï¼‰ï¼š Core A å‘ç°è‡ªå·±çš„çŠ¶æ€æ˜¯Â Sï¼Œä¸èƒ½ç›´æ¥å†™ã€‚ å®ƒåœ¨æ€»çº¿ä¸Šå‘é€Â Bus UpgradeÂ æˆ–Â Bus Read ExclusiveÂ æ¶ˆæ¯ã€‚ Core B â€œå—…æ¢â€åˆ°è¿™ä¸ªæ¶ˆæ¯ï¼ŒçŸ¥é“è‡ªå·±å‰¯æœ¬è¦å¤±æ•ˆäº†ï¼Œå°†è‡ªå·±çš„ç¼“å­˜è¡ŒçŠ¶æ€å˜ä¸ºÂ Iã€‚ Core A æ”¶åˆ°ç¡®è®¤åï¼Œæ‰§è¡Œå†™å…¥æ“ä½œï¼Œå¹¶å°†è‡ªå·±çš„çŠ¶æ€ä»Â SÂ å˜ä¸ºÂ Mã€‚æ­¤æ—¶ï¼ŒCore A çš„ç¼“å­˜æ˜¯æœ€æ–°å€¼ 20ï¼ŒCore B çš„ç¼“å­˜å·²æ— æ•ˆï¼Œå†…å­˜ä¸­çš„æ•°æ®ï¼ˆ10ï¼‰ä¹Ÿå·²è¿‡æ—¶ã€‚ Core B å†æ¬¡è¯»å– Xï¼š Core B ç¼“å­˜è¡ŒçŠ¶æ€æ˜¯Â Iï¼Œæœªå‘½ä¸­ã€‚å‘é€Â Bus Readã€‚ Core A â€œå—…æ¢â€åˆ°è¯·æ±‚ï¼Œå‘ç°è‡ªå·±çŠ¶æ€æ˜¯Â Mï¼ˆå·²ä¿®æ”¹ï¼‰ã€‚ Core A å°†æ•°æ®ï¼ˆ20ï¼‰å†™å›æ€»çº¿ï¼ˆæˆ–å…ˆå†™å›å†…å­˜å†æä¾›ï¼‰ï¼Œå¹¶å°†è‡ªå·±çš„çŠ¶æ€å˜ä¸ºÂ Sã€‚ Core B æ¥æ”¶åˆ°æœ€æ–°æ•°æ® 20ï¼ŒçŠ¶æ€å˜ä¸ºÂ Sã€‚ æ€»çº¿çª¥æ¢ï¼ˆSnoopingï¼‰ï¼šä¸Šè¿°æœºåˆ¶ä¾èµ–äºæ‰€æœ‰æ ¸å¿ƒç›‘å¬æ€»çº¿ä¸Šçš„æ‰€æœ‰æ¶ˆæ¯ï¼Œè¿™åœ¨å¤§è§„æ¨¡å¤šæ ¸ç³»ç»Ÿä¸­å¯èƒ½æˆä¸ºç“¶é¢ˆã€‚ ç›®å½•åè®®ï¼ˆDirectory Protocolï¼‰ï¼šä¸ºäº†è§£å†³çª¥æ¢çš„æ‰©å±•æ€§é—®é¢˜ï¼Œæ›´é«˜çº§çš„ç³»ç»Ÿä½¿ç”¨â€œç›®å½•â€ã€‚ç›®å½•ä½œä¸ºä¸€ä¸ªä¸­å¿ƒåŒ–çš„ç»„ä»¶ï¼Œè®°å½•æ¯ä¸ªç¼“å­˜è¡Œè¢«å“ªäº›æ ¸å¿ƒç¼“å­˜ã€‚å½“ä¸€ä¸ªæ ¸å¿ƒéœ€è¦ä¿®æ”¹æ•°æ®æ—¶ï¼Œå®ƒåªéœ€æŸ¥è¯¢ç›®å½•ï¼Œç„¶åç”±ç›®å½•ç›´æ¥é€šçŸ¥é‚£äº›æŒæœ‰å‰¯æœ¬çš„æ ¸å¿ƒä½¿å…¶å¤±æ•ˆï¼Œè€Œä¸æ˜¯å¹¿æ’­åˆ°æ‰€æœ‰æ ¸å¿ƒã€‚è¿™åœ¨NUMAæ¶æ„ä¸­éå¸¸å¸¸è§ã€‚ å­˜å‚¨ç¼“å†²åŒºï¼ˆStore Bufferï¼‰ï¼šä¸ºäº†ä¸è®©æ ¸å¿ƒåœ¨å†™æ“ä½œæ—¶æ€»æ˜¯ç­‰å¾…å…¶ä»–æ ¸å¿ƒçš„å“åº”ï¼ˆä¾‹å¦‚ï¼Œç­‰å¾…Â Bus UpgradeÂ çš„ç¡®è®¤ï¼‰ï¼ŒCPUå¼•å…¥äº†å­˜å‚¨ç¼“å†²åŒºã€‚æ ¸å¿ƒå¯ä»¥å…ˆæŠŠå†™æ“ä½œæ”¾å…¥å­˜å‚¨ç¼“å†²åŒºï¼Œç„¶åç»§ç»­æ‰§è¡Œåç»­æŒ‡ä»¤ã€‚è¿™è™½ç„¶æå‡äº†æ€§èƒ½ï¼Œä½†ä¹Ÿå¼•å…¥äº†æ›´å¤æ‚çš„å†…å­˜ä¸€è‡´æ€§æ¨¡å‹é—®é¢˜ï¼ˆå¦‚éœ€è¦å†…å­˜å±éšœæŒ‡ä»¤ï¼‰ã€‚ 8. ä¸‰ä¸ªå±‚çº§cacheå»¶è¿Ÿæ—¶é—´åˆ†åˆ«å¤§çº¦å¤šå°‘ï¼Ÿ9. è¿›ç¨‹é—´é€šä¿¡çš„å‡ ç§ä¸»è¦æ–¹å¼10. newå’Œmallocçš„åº•å±‚æœºåˆ¶å·®å¼‚11. è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†åœ°å€çš„è½¬æ¢è¿‡ç¨‹12. å¤§é¡µè¡¨æŠ€æœ¯çš„é€‚ç”¨åœºæ™¯"},{"title":"é¢ç»å¸¸è§é—®é¢˜ï¼šæ‰‹æ’•ç¯‡","path":"/notebooks/Interview/é¢ç»å¸¸è§é—®é¢˜ï¼šæ‰‹æ’•ç¯‡.html","content":"é—®é¢˜ å®ç°ä¸€ä¸ª shared_ptrï¼Œéœ€è¦æ³¨æ„å“ªäº›å…³é”®ç‚¹ï¼Ÿï¼ˆå¼•ç”¨è®¡æ•°ã€æ‹·è´æ„é€ ã€èµ‹å€¼æ“ä½œç¬¦ã€thread safeç­‰ï¼‰ æ— åºæ•°ç»„ä¸­æ‰¾åˆ°å‡ºç°æ¬¡æ•°è¶…è¿‡ n2 çš„å…ƒç´ ï¼Œè¦æ±‚å¸¸æ•°ç©ºé—´å¤æ‚åº¦ å‚è€ƒå›ç­” å®ç°ä¸€ä¸ª shared_ptrï¼Œéœ€è¦æ³¨æ„å“ªäº›å…³é”®ç‚¹ï¼Ÿï¼ˆå¼•ç”¨è®¡æ•°ã€æ‹·è´æ„é€ ã€èµ‹å€¼æ“ä½œç¬¦ã€thread safeç­‰ï¼‰ templatetypename Tclass SharedPtr private: T* ptr_; int* count_; std::mutex* mutex_; void release() bool should_delete = false; std::lock_guardstd::mutex lock(*mutex_); if (--(*count_) == 0) should_delete = true; if (should_delete) delete ptr_; delete count_; delete mutex_; public: // æ„é€ å‡½æ•° explicit SharedPtr(T* ptr = nullptr) : ptr_(ptr), count_(new int(1)), mutex_(new std::mutex) // æ‹·è´æ„é€ å‡½æ•° SharedPtr(const SharedPtr other) : ptr_(other.ptr_), count_(other.count_), mutex_(other.mutex_) std::lock_guardstd::mutex lock(*mutex_); ++(*count_); // èµ‹å€¼æ“ä½œç¬¦ SharedPtr operator=(const SharedPtr other) if (this != other) release(); // é‡Šæ”¾å½“å‰èµ„æº ptr_ = other.ptr_; count_ = other.count_; mutex_ = other.mutex_; std::lock_guardstd::mutex lock(*mutex_); ++(*count_); return *this; // ç§»åŠ¨è¯­ä¹‰ SharedPtr(SharedPtr other) noexcept : ptr_(other.ptr_), count_(other.count_), mutex_(other.mutex_) other.ptr_ = nullptr; other.count_ = nullptr; other.mutex_ = nullptr; ~SharedPtr() release(); T operator*() return *ptr_; T* operator-() return ptr_; T* get() return ptr_; int use_count() return count_ ? *count_ : 0; ;","tags":[null]},{"title":"é¢ç»å¸¸è§é—®é¢˜ï¼šè°ƒè¯•æ€§èƒ½è°ƒä¼˜ç¯‡","path":"/notebooks/Interview/é¢ç»å¸¸è§é—®é¢˜ï¼šè°ƒè¯•ä¸æ€§èƒ½è°ƒä¼˜ç¯‡.html","content":"é—®é¢˜ ç¨‹åºé€šå¸¸ä¼šåœ¨å“ªäº›æƒ…å†µä¸‹å‘ç”Ÿ Core Dumpï¼Ÿä½ æ˜¯å¦æœ‰è¿‡æ’æŸ¥ç»å†ï¼Ÿ å¦‚æœç¨‹åºå‘ç”Ÿ Core Dumpï¼Œä½ é€šå¸¸ä¼šå¦‚ä½•å®šä½å’Œåˆ†æé—®é¢˜ï¼Ÿ ä½ æ˜¯å¦æœ‰è¿‡æ€§èƒ½è°ƒä¼˜çš„ç»å†ï¼Ÿè¯·è®²è®²ä½ çš„æ€è·¯å’Œå¸¸ç”¨å·¥å…·ã€‚ å¦‚ä½•ä½¿ç”¨ GDB è°ƒè¯•å¤šçº¿ç¨‹ç¨‹åºï¼Ÿï¼ˆä¾‹å¦‚æŸ¥çœ‹æ‰€æœ‰çº¿ç¨‹ backtraceã€åˆ‡æ¢çº¿ç¨‹ç­‰ï¼‰ æ€è·¯"},{"title":"é¢ç»å¸¸è§é—®é¢˜ï¼šç½‘ç»œç¯‡","path":"/notebooks/Interview/é¢ç»å¸¸è§é—®é¢˜ï¼šç½‘ç»œç¯‡.html","content":"é—®é¢˜ARPåè®®çš„å·¥ä½œæµç¨‹TCPæ‹¥å¡æ§åˆ¶ä»URLè¾“å…¥åˆ°é¡µé¢æ¸²æŸ“çš„å®Œæ•´é“¾è·¯ å‚è€ƒæ€è·¯"},{"title":"ASPLOS-25 PIM Is All You Need A CXL-Enabled GPU-Free System  for Large Language Model Inference","path":"/notebooks/paper/ASPLOS-25-PIM Is All You Need_ A CXL-Enabled GPU-Free System  for Large Language Model Inference.html","content":"èƒŒæ™¯PIMå’ŒPNMPIM çš„è®¡ç®—å•å…ƒä¸å­˜å‚¨å•å…ƒç»“åˆç´§å¯†ï¼Œå¤„äºå†…å­˜èŠ¯ç‰‡å†…éƒ¨ã€‚åœ¨ä¼ ç»Ÿ PIM æ–¹æ³•é‡Œï¼Œè®¡ç®—å•å…ƒè¢«æ”¾ç½®åœ¨ä¸»å­˜å‚¨å™¨ï¼ˆDRAMï¼‰ä¸­ï¼Œä¸å­˜å‚¨å•å…ƒåœ¨ç‰©ç†ä¸Šç´§å¯†ç›¸è¿ã€‚åƒç¾å…‰çš„æ··åˆå­˜å‚¨ç«‹æ–¹ä½“ï¼ˆHMCï¼‰ï¼Œåœ¨ DRAM å±‚çš„å †æ ˆä¸‹è®¾ç½®é€»è¾‘å±‚ï¼ŒæœŸæœ›åœ¨é€»è¾‘å±‚å®ç°è‡ªå®šä¹‰é€»è¾‘ï¼›NM çš„è®¡ç®—å•å…ƒåœ¨ç‰©ç†ä¸Šé è¿‘å†…å­˜é˜µåˆ—ï¼Œä½†ä¸ PIM ç›¸æ¯”ç»“åˆç¨‹åº¦æ²¡é‚£ä¹ˆç´§å¯†ã€‚å…¶å¤„ç†å•å…ƒå¯éƒ¨ç½²åœ¨ä¸åŒä½ç½®ï¼Œå½¢æˆå¤šç§æ¶æ„å½¢æ€ã€‚å¸¸è§çš„ä½ç½®æœ‰ 3D å †å å†…å­˜çš„é€»è¾‘å±‚ï¼Œå¦‚ä¸‰æ˜Ÿ HBM-PIM åœ¨ HBM2 å†…å­˜å †æ ˆçš„æ¯ä¸ªå­˜å‚¨ä½“ä¸­é›†æˆå¯ç¼–ç¨‹è®¡ç®—å•å…ƒï¼ˆPCUï¼‰ï¼›PIMå†…å­˜å¯†åº¦ä½ï¼Œå®¹é‡å°ï¼›PNMå¸¦å®½æ²¡æœ‰ä¼˜åŠ¿ã€‚ GPUæ¨ç†ç‰¹ç‚¹å¸¦å®½åœ¨å†…å­˜ä¸è¶³æ—¶ä¼šè¶‹è¿‘é¥±å’Œï¼›decoder-onlyä¸ä¼ ç»Ÿå¤§æ¨¡å‹ç›¸æ¯”GPUç®—åŠ›åˆ©ç”¨ç‡æ›´ä½ PIMå…·æœ‰æå¤§çš„å†…éƒ¨å¸¦å®½ PIMå…·æœ‰æä½çš„å†…å­˜å¯†åº¦è¨€å¤–ä¹‹æ„å­˜å‚¨å®¹é‡ä¸å¤Ÿ ä¸ºä»€ä¹ˆéœ€è¦Hierarchical PIM-PNMæ¶æ„ï¼Ÿæœ‰ä¸¤ç§æ“ä½œï¼š\t1.åœ¨near-bankä½¿ç”¨é€šç”¨å¤„ç†PUï¼›2.ä½¿ç”¨ä¸“ç”¨çš„near-bank PUsè¿›è¡ŒDSAè®¡ç®—ï¼ŒåŒæ—¶åœ¨PIMä¸­è¿›è¡Œäº†å…¶ä»–æ“ä½œã€‚ CENTç¡¬ä»¶æ¶æ„ä¸€ä¸ªCPUè¿æ¥äº†CXL Switch è¿æ¥32ä¸ªCXL deviceã€‚æ¯ä¸ªdeviceåŒ…å«äº†CXLæ§åˆ¶å™¨ï¼›æ¯ä¸ªæ§åˆ¶å™¨åŒ…å«ä¸€ä¸ªPNMå’Œ16ä¸ªchipsï¼Œæ¯ä¸ªchipsåŒ…å«äº†ä¸¤ä¸ªPIMã€‚CXL switchæ”¯æŒCPUåˆ°CXLé€šä¿¡ã€ä»¥åŠCXLä¹‹é—´çš„ç‚¹å¯¹ç‚¹é€šä¿¡ï¼› CXL-based Network ArchitectureCENT ä»¥CXL 3.0ä¸ºæŠ€æœ¯åº•åº§ï¼Œå¤ç”¨ PCIe 6.0 ç‰©ç†å±‚å®ç°é«˜é€Ÿäº’è¿ï¼ŒåŒæ—¶é€šè¿‡åè®®å®šåˆ¶æ»¡è¶³ LLM æ¨ç†çš„ä½å»¶è¿Ÿä¸é«˜å¸¦å®½éœ€æ±‚ã€‚å¤ç”¨äº†ç‰©ç†å±‚ã€‚CXLäºhostä¹‹é—´é‡‡ç”¨x16é€šé“é“¾è·¯ï¼Œç†è®ºå¸¦å®½128GBsï¼›CXLäºswitchä¹‹é—´é‡‡ç”¨x4é€šé“ï¼Œç†è®ºå¸¦å®½32GBsï¼›ä½¿ç”¨äº†CXL.io. CXL.mem;æœªä½¿ç”¨CXL,cache; Inter-Device Communicationï¼ˆè®¾å¤‡é—´ï¼‰Figure 5å±•ç¤ºäº†å•ä¸ª CXLè®¾å¤‡çš„å†…éƒ¨ç»“æ„ã€‚CXLè®¾å¤‡ä¹‹é—´çš„é€šä¿¡ä¸»è¦ä½¿ç”¨äº†IDCCå’ŒShared Bufferè®¾å¤‡ä¹‹é—´é€šä¿¡é‡‡ç”¨äº†ä¸‰ä¸ªé€šä¿¡åŸè¯­ï¼š SEND_CXL ï¼šâ€œéé˜»å¡â€ æŒ‡ä»¤ï¼Œéœ€æ˜ç¡®æŒ‡å®šç›®æ ‡è®¾å¤‡ IDï¼ˆDVidï¼‰ã€æºè®¾å¤‡ä¸ç›®æ ‡è®¾å¤‡çš„å…±äº«ç¼“å†²åŒºåœ°å€ï¼›RECV_CXLï¼šÂ ä¸SEND_CXL ç›¸åï¼ŒRECV_CXL æ˜¯ â€œé˜»å¡å¼â€ æŒ‡ä»¤ï¼Œä¸”æ— éœ€æŒ‡å®šæºè®¾å¤‡ IDï¼›SENDå’ŒRECVæ„æˆä¸€æ¬¡å®Œæ•´çš„CXLå†™äº‹åŠ¡ï¼›äº‹åŠ¡æµç¨‹ï¼š æºè®¾å¤‡æ‰§è¡Œ SEND_CXLï¼Œå°†å…±äº«ç¼“å†²åŒºï¼ˆRsï¼‰ä¸­çš„æ•°æ®å°è£…ä¸º CXL å¸§ï¼ˆå« DVidã€Rd åœ°å€ï¼‰ï¼Œé€šè¿‡ CXL ç«¯å£å‘é€ç»™äº¤æ¢æœºï¼› CXL äº¤æ¢æœºè§£æå¸§å¤´çš„ DVidï¼Œå°†æ•°æ®è½¬å‘åˆ°ç›®æ ‡è®¾å¤‡çš„ CXL ç«¯å£ï¼› ç›®æ ‡è®¾å¤‡é€šè¿‡ RECV_CXL ç›‘æµ‹åˆ°ç«¯å£æ•°æ®ï¼ŒæŒ‰ Rd åœ°å€å†™å…¥æœ¬åœ°å…±äº«ç¼“å†²åŒºï¼Œå¹¶å‘æºè®¾å¤‡è¿”å› â€œæ— æ•°æ®å“åº”ï¼ˆNDRï¼‰â€ï¼› æºè®¾å¤‡æ”¶åˆ° NDR åï¼Œç¡®è®¤æ•°æ®ä¼ è¾“å®Œæˆï¼ˆéé˜»å¡æŒ‡ä»¤çš„ â€œå®Œæˆé€šçŸ¥â€ï¼‰ã€‚ BCAST_CXL ï¼šéé˜»å¡æŒ‡ä»¤ï¼Œé€šè¿‡ 8 ä½ DVcount å‚æ•°æŒ‡å®š â€œéœ€å¹¿æ’­æ•°æ®çš„åç»­ CXL è®¾å¤‡æ•°é‡â€ã€‚ å•ä¸ªCXLè®¾å¤‡é€šè¿‡ä¸€ä¸ªè¯·æ±‚å†™æ•°æ®åˆ°å¤šä¸ªè®¾å¤‡ï¼ŒåŸºäºPBR(åŸºäºç«¯å£çš„è·¯ç”±æœºåˆ¶)çš„filtçš„é¢„ç•™å­—æ®µå®ç°ï¼Œè®¾ç½®äº†ä¸€ä¸ªæ ‡è®°å¹¿æ’­ä½ã€‚æœ‰ä¸€ä¸ªç¡®è®¤æœºåˆ¶ï¼Œå¹¿æ’­å‡ºå»ä»¥åéœ€è¦ç›®æ ‡è®¾å¤‡æ¥æ”¶æ•°æ®å¹¶è¿”å›NDRåæ‰ä¼šæ‰§è¡Œï¼Œé¿å…æ•°æ®ä¸¢å¤± CXLç«¯å£çš„å®ç°å¦‚å›¾Figure6:ä¸»è¦å°±æ˜¯å‘é€é˜Ÿåˆ—å’Œæ¥æ”¶é˜Ÿåˆ—çš„å®ç° ç›¸åº”æœ¯è¯­ï¼šL2Rï¼›(local 2 remote).è¯»å†™äº‹åŠ¡å¯¹åº”çš„å„ç§åŒ… Hierarchical PIM-PNM Architectureå¦‚å›¾5.ä¹Ÿæ˜¯ä¸€ä¸ªå–æŒ‡è¯‘ç çš„è¿‡ç¨‹ï¼ŒæŒ‡ä»¤å…ˆè¢«æ”¾åˆ°ä¸€ä¸ªæŒ‡ä»¤ç¼“å†²åŒºï¼Œç„¶åè¯‘ç å™¨æ‰§è¡Œå¹¶åˆ†å‘åˆ°PNMå’ŒPIMã€‚ï¼ˆæ ‡å‡†çš„è¯»å†™äº‹åŠ¡è¢«ç›´æ¥åˆ†å‘ç»™PIMå¤„ç†ï¼Œå…¶ä»–çš„åˆ™è½¬åŒ–ä¸ºå¾®æ“ä½œåˆ†å‘åˆ°PIMå’ŒPNMï¼‰ PIMPIMæ¥æ”¶å¾®æ“ä½œç„¶åè½¬åŒ–ä¸ºç›¸å…³çš„DRAMæŒ‡ä»¤ï¼ŒFigure 7a å±•ç¤ºæ¯ä¸ªPIM channelç»“æ„ã€‚æ¯ä¸ªbankæœ‰32MBå®¹é‡å’Œä¸€ä¸ªnear-bank PUï¼› å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œnear-bankä¸­å®ç°äº†ä¸€ä¸ª16 MAC reduction treeï¼ˆ16è·¯MACè§„çº¦æ ‘ï¼‰ï¼Œä¸“é—¨ç”¨æ¥åšä¹˜åŠ è¿ç®—ã€‚å¦‚GEMVï¼Œæœ¬è´¨æ˜¯å‘é‡å…ƒç´ ä¸çŸ©é˜µå…ƒç´ åšä¹˜æ³•ï¼Œç„¶åç´¯åŠ æ±‚å’Œã€‚æ¥æ”¶16ç»„16bit*16bitçš„è¾“å…¥æ•°æ®ï¼Œç„¶åå¹¶è¡Œæ‰§è¡Œ16æ¬¡ä¹˜æ³•ï¼Œæœ€åè¾“å…¥ä¸€ä¸ª32bitçš„ç´¯åŠ ç»“æœã€‚è¿™äº›è¾“å…¥æ¥è‡ªä¸´è¿‘çš„bankæˆ–è€…æ˜¯å…¨å±€çš„bufferï¼Œè¿™ä¸€ç‚¹æœ‰ç‚¹ç±»ä¼¼CUDAç¼–ç¨‹ã€‚ å…¨å±€ç¼“å†²åŒºå¯ä»¥å‘é€šé“å†…ä¸å¾—16ä¸ªPUå…±äº«256bitçš„æ•°æ®ï¼Œå®ç°æ•°æ®å¤ç”¨ï¼Œé™ä½å†…å­˜è®¿é—®å»¶è¿Ÿã€‚ç±»ä¼¼CUDAä¸­çš„å…¨å±€å†…å­˜ã€‚æ¯ä¸ªPUå†…éƒ¨æœ‰ä¸€ä¸ª32bitçš„ç´¯åŠ å¯„å­˜å™¨å­˜å‚¨MAC çš„ç»“æœï¼Œè¿™ä¸ªå¯„å­˜å™¨çš„ç»“æœè®¿é—®å¯ä»¥ç”±å®šåˆ¶çš„ISAè®¿é—®ã€‚æ¿€æ´»å‡½æ•°åˆ©ç”¨DRAMä¸­çš„æŸ¥æ‰¾è¡¨LUTå’Œçº¿æ€§æ’å€¼å®ç°ï¼›é¿å…äº†å¤æ‚çš„ç”µè·¯ã€‚ åŒæ—¶ä»‹ç»äº†DRAMäºPUçš„åŒæ­¥ï¼ŒDRAMå­˜å‚¨ä½“æ¯2nså‘PUè¾“å‡º1æ¬¡16bitçš„è¾“å…¥ï¼ŒPUæ¯2nså®Œæˆä¸€æ¬¡16è·¯è§„çº¦æ ‘è®¡ç®—ï¼Œæœ€å¤§åŒ–PIMé€šé“çš„è®¡ç®—-å†…å­˜è®¿é—®overlapï¼›ç„¶åä»‹ç»äº†ä¸€äº›é€šè¿‡ä¸åŒPIMchannelçš„æŒ‡ä»¤å¦‚ACTabç­‰æŒ‡ä»¤ã€‚ PNMå•å…ƒPNMå¦‚Figure7bæ‰€ç¤ºã€‚åŒ…å«ï¼ˆ1ï¼‰.32ä¸ªç´¯åŠ å™¨ï¼Œè¾“å…¥ä»Shared Bufferä¸­å–å¾—ï¼Œæ‰§è¡Œæ®‹å·®è¿æ¥ç­‰ï¼›ï¼ˆ2ï¼‰32ä¸ªè§„çº¦æ ‘ï¼Œæ¯ä¸€è·¯ä»shared bufferä¸­è·å¾—ä¸€ä¸ª256bitçš„å€¼ï¼ˆ16ç»„BFï¼‰ï¼Œæ‰§è¡Œå¤šå…ƒç´ æ±‚å’Œï¼›ï¼ˆ3ï¼‰æŒ‡æ•°åŠ é€Ÿå™¨ï¼›ï¼ˆ4ï¼‰2å‘å°„è¶…æ ‡é‡æµæ°´çº¿RISCVæ ¸å¿ƒï¼Œæ‰§è¡Œä¸€äº›ä¸å¸¸è§æ“ä½œï¼› Intra-Device Communicationè®¾å¤‡å†…éƒ¨é€šä¿¡ï¼ŒWR_SBKã€RD_SBKç­‰å®ç°DRAM banksä¸Shared buffer ä¹‹é—´çš„ç§»åŠ¨; ISA æ€»ç»“åŸºäºè¿™äº›æ•°æ®ç§»åŠ¨æŒ‡ä»¤å’Œéƒ¨ä»¶ï¼Œå®ç°äº†ä¸€äº›å¯¹å¤–æš´éœ²çš„ç›¸å…³ISAæ“ä½œï¼Œè§Table2 æ¨¡å‹æ˜ å°„ ï¼ˆè½¯ä»¶æ¶æ„ï¼‰å¤§æ¨¡å‹é«˜å‚æ•°ä»¥åŠPIMçš„ä½å­˜å‚¨å¯†åº¦ï¼Œæ‰€ä»¥å¹¶è¡ŒåŒ–ç­–ç•¥å¾ˆé‡è¦ã€‚è¿™ä¸€èŠ‚ä¸»è¦è®²å¦‚ä½•åˆ©ç”¨è¿™äº›ç¡¬ä»¶ï¼Œé‡ç‚¹æ˜¯å¦‚ä½•åˆ©ç”¨è¿›è¡Œæ¨¡å‹å¹¶è¡ŒåŒ–ã€‚ Pipeline-Parallel Mapping (PP)äº‘æœåŠ¡å™¨æä¾›å•†æœåŠ¡æ•°ä¸‡åˆ°æ•°ç™¾ä¸‡ç”¨æˆ·çš„æŸ¥è¯¢ï¼Œååé‡ï¼ˆå•ä½æ—¶é—´å†…å¤„ç†çš„æŸ¥è¯¢æ•°ï¼‰è‡³å…³é‡è¦ã€‚ä¼ ç»ŸGPUå­˜å‚¨å› ä¸ºKV cacheå ç”¨å†…å­˜å¤§å¯¼è‡´ååé‡éš¾ä»¥æå‡ã€‚ ä»¥Transfomerå—æ‹†åˆ†ä¸ºæµæ°´çº¿é˜¶æ®µã€‚ä¸åŒæŸ¥è¯¢åœ¨æµæ°´çº¿çš„ä¸åŒé˜¶æ®µåŒæ—¶æ‰§è¡Œã€‚æ ¹æ®è´Ÿè½½å‡è¡¡è¿›è¡Œå—åœ¨CXLä¹‹é—´çš„åˆ’åˆ†ä¾æ®ï¼Œé¿å…å•ä¸ªå—å†…çš„é€šè¡Œï¼Œé¿å…æ‹†åˆ†æµæ°´çº¿æ”¾åˆ°ä¸åŒçš„CXLè®¾å¤‡çš„PIM channelsä¸­ï¼› ä¸Šä¸€ä¸ªå—æ‰§è¡Œå®Œä¼ åˆ°ä¸‹ä¸€ä¸ªå—è¿›è¡Œï¼Œå®ç°äº†è¯·æ±‚å¹¶è¡Œï¼Œæ¯æ¬¡ä¼ çš„å—æ˜¯16KBã€‚å—é™äºGlobal Bufferçš„å¤§å°ï¼Œä¸æ”¯æŒæ‰¹å¤„ç†è¯·æ±‚ï¼ˆä¸€æ¬¡è¯·æ±‚å¤šä¸ªè¯·æ±‚ï¼‰ï¼› è¨€å¤–ä¹‹æ„æµæ°´çº¿å¹¶è¡Œå°±æ˜¯æ¯ä¸ªCXLè®¾å¤‡å¤„ç†æ¯ä¸ªè¯·æ±‚çš„ä¸€éƒ¨åˆ†ï¼Œç„¶åæ”¾ç»™ä¸‹ä¸€ä¸ªCXLè®¾å¤‡ç»§ç»­å¤„ç†ï¼Œä½†æ˜¯æ¯æ¬¡åªèƒ½å¤„ç†ä¸€ä¸ªè¯·æ±‚ï¼Œä¸èƒ½åŒæ—¶å¤„ç†å¤šä¸ªè¯·æ±‚ã€‚ Tensor-Parallel Mapping (TP)æ‰€æœ‰èµ„æºåŒæ—¶å¤„ç†ä¸€ä¸ªè§£ç å™¨å—ï¼Œæœ‰æ•ˆé™ä½å»¶è¿Ÿã€‚ Figure 9å±•ç¤ºäº†åˆ†é…æ–¹æ¡ˆï¼Œ å…·ä½“æ¯ä¸ªå±‚æ˜¯æ”¾åœ¨ä¸€ä¸ªCXLè®¾å¤‡è¿˜æ˜¯å¤šä¸ªCXLè®¾å¤‡æ˜¯æŒ‰ç…§é€šä¿¡å¼€é”€æ¥å†³å®šï¼šè®¡ç®—å¯†é›†ä¸”é€šä¿¡å°‘çš„å±‚æ‹†åˆ†å¹¶è¡Œï¼Œé€šä¿¡å¯†é›†æˆ–è½»é‡çš„å±‚å•è®¾å¤‡æ‰§è¡Œã€‚ Hybrid Tensor-Pipeline Parallel Mappingå°†æ¯ä¸ª Transformer è§£ç å™¨åˆ†é…ç»™å¤šä¸ªè¿ç»­çš„ CXL è®¾å¤‡ã€‚ä¾‹å¦‚ï¼Œåœ¨ 32 ä¸ªè®¾å¤‡çš„æƒ…å†µä¸‹ï¼Œå°†æ¯ä¸ªè§£ç å™¨æ˜ å°„åˆ° 324 8 ä¸ªè®¾å¤‡ä¸Šï¼Œè¿™æ ·å°±å®ç°äº† TP8 å’Œ PP4ã€‚å…¶ä¸­ï¼Œå¼ é‡å¹¶è¡Œæ˜¯å°†å•ä¸ªå¼ é‡ï¼ˆå¦‚æƒé‡çŸ©é˜µï¼‰æŒ‰ç»´åº¦æ‹†åˆ†ï¼Œä¸åŒè®¾å¤‡è®¡ç®—å¼ é‡çš„éƒ¨åˆ†å­å—ï¼Œé€šè¿‡é€šä¿¡æ‹¼æ¥ç»“æœã€‚æµæ°´çº¿å¹¶è¡Œåˆ™æ˜¯å°†æ¨¡å‹æŒ‰å±‚æ‹†åˆ†ï¼Œä¸åŒè®¾å¤‡æŒ‰ â€œæµæ°´çº¿â€ é¡ºåºæ‰§è¡Œï¼Œå‰ä¸€è®¾å¤‡çš„è¾“å‡ºä½œä¸ºåä¸€è®¾å¤‡çš„è¾“å…¥ Transformer Block Mappingä¸€ä¸ªå±‚æ˜¯å¦‚ä½•åœ¨CXLè®¾å¤‡ä¸Šæ‰§è¡Œçš„ï¼šå¹¶ä¸”è¯¦ç»†è®²è§£äº†GEMVã€å‘é‡ç‚¹ç§¯ã€å…ƒç´ çº§ä¹˜æ³•ç­‰æ“ä½œçš„å¯¹åº”ä¼˜åŒ–ã€‚ End-to-End Model Mappingprefillç›´æ¥åœ¨CXLä¸ŠæŒ‰ç…§ä¸Šè¿°æ–¹æ³•æ˜ å°„Transformerï¼Œæ‰§è¡Œåtop-ké‡‡æ ·åœ¨CPUä¸Šæ‰§è¡Œ Programming Modelä¸ºäº†æ›´åŠ ç®€å•çš„ä½¿ç”¨ï¼Œåˆè¿›è¡Œäº†ä¸€æ¬¡å°è£…ï¼Œåªéœ€è¦é…ç½®å¹¶è¡Œç­–ç•¥ç­‰ï¼Œè‡ªç ”çš„ç¼–è¯‘å™¨ä¼šè¿›è¡Œè½¬æ¢ã€‚ä¿è¯æ‰§è¡Œçš„æ•ˆç‡ã€‚ åä¹‰ä¸Šçš„ç¼–è¯‘å™¨ï¼Œå…¶å®å°±æ˜¯äºŒæ¬¡å°è£…ï¼Œæ›´åƒæ˜¯ä¸€ä¸ªç®—å­åº“ï¼Œå°è£…äº†å¸¸è§çš„ç®—å­ã€‚ å®éªŒæ–¹æ³•è®ºåŠç»“æœè¿›è¡Œäº†å¹¶è¡Œç­–ç•¥å¯¹æ¯”ã€GPUä¸CENTè·¨å¹³å°æ€§èƒ½å¯¹æ¯”ã€åœºæ™¯é€‚é…æ€§æµ‹è¯•ã€æ•æ„Ÿæ€§æµ‹è¯•ååé‡æé«˜äº†ï¼Œæˆæœ¬é™ä½äº†ï¼Œèƒ½è€—é™ä½äº† ä¸ªäººè¯„ä»·1.PIMæ²¡æœ‰çœŸå®è®¾å¤‡å®ç°ï¼Œä½†æ˜¯å…¶ç¡¬ä»¶ç»“æ„è®¾è®¡ã€åˆ°ISAåˆ°å¤šç§å¹¶è¡Œæ–¹å¼ä»åº•å±‚åˆ°ä¸Šå±‚å‚ç›´æ‰“é€šï¼Œæœ€å¤§ä¼˜åŠ¿æ˜¯åˆ©ç”¨äº†PIMçš„å¸¦å®½ã€‚ 2.å¹¶è¡Œç­–ç•¥ä¸°å¯Œï¼Œå¸¸è§çš„å¹¶è¡Œç­–ç•¥éƒ½æœ‰æ‰€è€ƒè™‘ã€‚ 3.å®éªŒéƒ¨åˆ†æ²¡æœ‰ä»”ç»†çœ‹ï¼Œæ˜¯é‡‡ç”¨æ¨¡æ‹Ÿå™¨æ¨¡æ‹Ÿæ‰§è¡Œï¼ŒCXLé‡‡ç”¨è¿™ç§æ¨¡æ‹Ÿæ¡†æ¶åœ¨åç»­å®éªŒä¸­ä¹Ÿè®¸å¯ä»¥ä½¿ç”¨ã€‚ï¼ˆç±»ä¼¼çš„æ¨¡æ‹Ÿå™¨æ–¹æ³•åŒ…æ‹¬æ‘©å°”çº¿ç¨‹çš„SimuMax)ç»“åˆæ‘©å°”çº¿ç¨‹çš„è¿™ä¸ªæ¨¡æ‹Ÿåº“ä¿®æ”¹å¯ä»¥å®ç°GPU-CXLååŒè®¡ç®—çš„ä¸€äº›ç¯å¢ƒæ¨¡æ‹Ÿï¼Œåº”è¯¥å¯ä»¥å‘æ˜ä¸€äº›åœºæ™¯ï¼ŒCPU+GPUä¸è¡Œæˆ–è€…å…¨CXLä¸è¡Œï¼Œéœ€è¦GPU+CXLæˆ–è€…CPU+GPU+CXLã€‚æœ‰äº›äººå¯èƒ½æ¯”è¾ƒå®¹æ˜“æƒ³åˆ°è¿™æ ·ååŒçš„ç‚¹ï¼Œä½†æ˜¯å®ç°èµ·æ¥å¾ˆå›°éš¾ï¼Œå€ŸåŠ©è¿™ä¸ªæ¨¡æ‹Ÿå™¨å¯ä»¥å®ç°ã€‚","tags":[null,null]},{"title":"ASPLOS`25 Systematic CXL Memory Characterization and Performance Analysis at Scale","path":"/notebooks/paper/ASPLOS-25-Systematic-CXL-Memory-Characterization-and-Performance-Analysis-at-Scale.html","content":"Systematic CXL Memory Characterization and Performance Analysis at Scale Jinshu Liu Virginia Tech https://github.com/MoatLab/Melody 1.IntroductionCurrently, there is a significant gap in research that explores detailed CXL characteristics and their impact on memory-intensive workloads at scale, in depth, and across the full spectrum of sub-Î¼s latencies. In particular, how do CXL devices differ in detailed performance characteristics beyond average latency and bandwidth metrics? How (much) does CXLâ€™s long (and longer) latency affect CPU efficiency and workload performance? What are the underlying causes and how do we analyze it? Exsiting works focus on coarse-grained analysis and overlook several critical aspects: (i) CXL performance stability (i.e., tail latencies); (ii) CPU tolerance to prolonged CXL latencies across various workloads, and the architectural implications of CXL; and (iii) the lack of systematic approach to dissect workload performance and CPU inefficiency under CXL. So: introduce Melody, a comprehensive framework for detailed CXL performance characterization. The first analysis of CXL characteristics beyond average latency and bandwidth across 4 real CXL devices. An extensive evaluation of CXLâ€™s performance implications across diverse workloads. A systematic approach for workload performance analysis under CXL. contributions(in my view): â€‹\t1.MELODY,a framwork to measure CXL perfomence. â€‹\t2.An in-depth study of CXL tail latencies (like caption). â€‹\t3.Root-cause analysis approach 2.BackgroundHow CPU backend and CXL MC process Load and Store request? .sloifirtlpig{zoom:200%;} Request types: The CPU issues two types of load requests: Demand and Prefetch. Demand loads are memory reads that CPU requests from (CXL) MC only when it is needed for computation. Prefetch reads are predictive reads directed by prefetchers, e.g., â€œL1PFâ€ and â€œL2PFâ€ in Figure 2a. Stores are first queued in the â€œstore buffer.â€ Each store request triggers a Read-for-ownership (RFO) for cache coherence from CXLDRAM, followed by a Write upon cache eviction. MC ï¼š Memory requests to the CXL MC are encapsulated(compress) in a specific packet format, known as Flits , for transmission over CXLPCIe. Upon arrival, the CXL controller (â€œCXL Ctrlâ€) parses the request and places it in the request queue. The request scheduler then selects the next request to process based on the scheduling policy and other factors such as thermal management for low latency, high bandwidth, and reliability. Requests are then passed to the command scheduler, which issues appropriate low-level DDR commands to the DRAM chips. 3.CXL Device Characterization3.1 Testbed Concern: work load: cloud workloads (in-memory caching and databases such as Redis [13] and VoltDB [21], CloudSuite [1], and Phoronix [12]), graph processing (GAPBS [22], PBBS [19]), data analytics (Spark [30]), MLAI (GPT-2 [5], MLPerf [14], Llama [9]), SPEC CPU 2017 [18], and PARSEC [24]. 3.2 CXL latency stability and its relationship with bandwidth Terms distinction: Loaded latencies: memory access latency under high utilization Idle latency: occurs when the system experiences minimal load è¿™ä¸€éƒ¨åˆ†å®ç°äº†ä¸€ä¸ªMIOï¼Œé€šè¿‡å¤šæ¬¡æŒ‡é’ˆè¿½è¸ªè®°å½•ä¸€æ¬¡rdtscæ—¶é—´æˆ³æ¥è®¡ç®—average latencyï¼Œå¹¶é‡‡ç”¨MLCæ¥éªŒè¯MIOã€‚æµ‹è¯•äº†ä¸€äº›tail latency ä¸bandwidthä¹‹é—´çš„å…³ç³»ï¼Œç»“æœå‡å¯ä»¥æƒ³åˆ°ã€‚ ä¸€ä¸ªæµ‹é‡å†…å­˜å‹åŠ›çš„æ–¹æ³•ï¼šå°†æŒ‡é’ˆè¿½è¸ªè®¿é—®çº¿ç¨‹å’Œ32ä¸ªAVXè®¿å­˜çº¿ç¨‹ä¸€èµ·bindåˆ°ä¸€ä¸ªnuma nod(co-locate) CXL latency vs. bandwidth under various readwrite ratios. Local DRAM achieves the highest bandwidth under a read-only workload, whereas NUMA and all CXL devices (except CXL-C) achieve minimal bandwidth in read-only scenarios. This is because NUMA and CXL links are bidirectional, allowing them to sustain higher bandwidth under mixed readwrite workloads CXL devices demonstrate significant variability Impact of CPU prefetchers on (tail) latency. Prefetching does not fully mitigate CXL-induced tail latencies. Reasoning. æœ¬èŠ‚ä¸­æµ‹å‡ºçš„ç»“æœå‘ç°å°¾å»¶è¿Ÿç­‰æ€§èƒ½å·®è·å¾ˆå¤§ï¼Œè¿™æ ·çš„ç»“è®ºå…¶å®ä½œç”¨ä¸å¤§ã€‚ä½†æ˜¯æ€§èƒ½å·®å¼‚å¤§å¯ä»¥ä½œä¸ºå…¶ä»–æ€§èƒ½ç ”ç©¶çš„æŒ‘æˆ˜å’ŒåŠ¨æœº 1.CXLåè®®ä¼ è¾“å±‚ä¸è¿æ¥å±‚çš„å®ç°æœ¬èº«å¼•å…¥äº†æ€§èƒ½å¼€é”€ 2.MC æ§åˆ¶å™¨å®ç°æœ¬èº« 4 Workload Characterization è®¨è®ºäº†ä¸€äº›å·¥ä½œè´Ÿè½½çš„å»¶è¿Ÿæ•æ„Ÿæ€§ç­‰ï¼Œæ­¤å‰è®ºæ–‡å·²ç»æœ‰è¿‡ 5 Spa for CXL Slowdown Analysis5.2 Challenges and Limitations of State-of-the-ArtChallenge:1.Identifying the underlying CPU eventsmetrics that can correlate to the slowdowns is challenging. It is even more challenging to establish a precise correlation between workload performance and architecture-level performance metrics, Why not TMA? TMA does not provide a differential analysis to interpret pipeline differences resulting from varying backend memory (i.e., CXL vs. local DRAM). TMA is unable to precisely correlate architecture level metrics with workload slowdowns. 5.3 Spa: A Bottom-Up Approach DRAM (Demand Load) Slowdown:These misses denote demand read misses, excluding RFO and prefetch requests. Store Slowdown :Incoming store requests queued in the store buffer are dequeued upon completion. Some writes issue RFO requests before execution. If the store buffer fills up, these RFOs would hinder load efficiency, causing CPU stalls. Cache Slowdown:On SKX, most cache slowdown occurs in L2 due to a significant rise in stall cycles for L1 load misses with CXL. Conversely, on SPREMR, LLC experiences the bulk of slowdown, with a notable increase in stall cycles for L2 load misses with CXL. key finding: This reduces L2 prefetcherâ€™s coverage of both demand reads and L1 prefetch. L1 prefetches would either miss entirely in L2 or at best, they would hit on a pending L2 prefetch in L2. Consequently, CXL also negatively impacts L1 prefetcherâ€™s timeliness.Loads that would have otherwise hit in the cache if L1 prefetches were timely, now are delayed. Consequently, overall prefetch efficiency suffers and stalls on caches increase. ç”±äºCXLçš„é•¿å»¶è¿Ÿï¼ŒL2é¢„å–çš„ä¿¡æ¯æ—¶æ•ˆæ€§é™ä½ï¼Œå½“L1éœ€è¦ç›¸åº”æ•°æ®çš„æ—¶å€™ï¼ŒL2è¿˜æ²¡æœ‰é¢„å–å›æ¥ï¼Œå¯¼è‡´L1è®¤ä¸ºmissï¼Œäºæ˜¯è®¿é—®L2,å†æ¬¡å‘å‡ºè¯·æ±‚ã€‚åŸæœ¬å¯ä»¥å‘½ä¸­çš„Loadè¯·æ±‚å˜å¾—ä¸å‘½ä¸­ã€‚ intelæ²¡æœ‰è®¡æ•°å™¨ç›´æ¥è§‚æµ‹L1Pf-L2-hitä¸missçš„æƒ…å†µï¼Œå¯ä»¥é€šè¿‡ä¸€äº›å…¶ä»–çš„è®¡æ•°å™¨é—´æ¥çš„è§‚æµ‹æƒ…å†µã€‚ å‘ç°ï¼šL2PF-L3-misså‡å°‘ï¼ŒL1PF-L3-misså¢å¤šï¼ŒL2PFL3-hitä¸å˜ï¼Œå› æ­¤æ¨å¯¼å‡ºï¼šL2é¢„å–å™¨ä½æ•ˆé¢„å–ï¼ŒL1é¢„å–å¢å¤šã€‚ 5.5 5.6 Workload Slowdown Diversity Period-based Slowdown AnalysisAn approach to convert time-based sampling data into a period-based slowdown analysis. 5.7 Spa Use CasesPerformance tuning. For example, to mitigate the slowdown bursts observed in 605.mcf (Figure 16b), we first identify memory accesses during bursty periods (e.g., exceeding 10%) using binary instrumentation via Intel Pin. Next, we pinpoint the source code responsible for high slowdowns using addr2line. Our analysis reveals that two performance-critical objects, each 2GB in size, are contributing to the slowdown. ä½œè€…æåˆ°çš„ä¸¤ä¸ªcaseï¼Œä¸€ä¸ªæ˜¯ç”¨æ¥åšæ€§èƒ½ä¼˜åŒ–ï¼Œä¸€ä¸ªæ˜¯ä½œä¸ºæ€§èƒ½æŒ‡æ ‡æ¥è¿›è¡Œåˆ†å±‚ï¼Œè¿™ä¸¤ä¸ªç‚¹å…¶å®éƒ½æ˜¯å’Œåä¸€ç¯‡è®ºæ–‡æœ‰è”ç³»ï¼Œåšé“ºå«ã€‚ ä¸è¶³ä¸æœºä¼šï¼š ä½œè€…åœ¨éªŒè¯cache slow downçš„ä¸»è¦åŸå› çš„ æ–¹æ³•æ˜¯ï¼š To validate this, we disable all the hardware prefetchers (L1 and L2) and measure workload slowdowns. With prefetchers off, we found virtually no stall cycles on cacheã€‚è¿™æ ·çš„æ–¹æ³•å¹¶ä¸æ·±å…¥ï¼Œä¸ºä»€ä¹ˆé™ä½ï¼Ÿè¿™äº›å€¼å¾—æ·±æŒ–ï¼Œä½†æ˜¯éœ€è¦ä¸€äº›ç¡¬ä»¶æ¢ç´¢ã€‚ å…³äºé¢„å–ï¼Œå¯ä»¥å¢åŠ é¢„å–å™¨çš„æ·±åº¦(ä¹Ÿå°±æ˜¯å†å¤šé¢„å–å‡ ä¸ªå‘¨æœŸ)ç›´æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ 5.7ä¸­è®²åˆ°äº†ä¸€ä¸ªå…³äºSPAçš„ä½¿ç”¨æ¡ˆä¾‹ï¼Œé€šè¿‡å‰–æSPAä¸­çš„slowdownæ¥åˆ†æslowdownï¼Œç„¶åæŠŠslowdownä¸¥é‡çš„å˜é‡æ”¾ç½®åˆ°CXLï¼Œè¿™æ ·çš„æ–¹æ³•æˆ‘è§‰å¾—ååˆ†é€‚ç”¨ã€‚","tags":[null]},{"title":"ASPLOSÂ·23 '25 TPP","path":"/notebooks/paper/ASPLOS23ï¼š TPP.html","content":"TPPï¼šé¢å‘ CXL ä½¿èƒ½çš„åˆ†å±‚å†…å­˜é€æ˜é¡µæ”¾ç½®æŠ€æœ¯æ‘˜è¦è¶…å¤§è§„æ¨¡åº”ç”¨å¯¹å†…å­˜éœ€æ±‚çš„æŒç»­å¢é•¿ï¼Œä½¿å¾—å†…å­˜æˆä¸ºæ•°æ®ä¸­å¿ƒæ€»ä½“æ”¯å‡ºçš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚CXLï¼ˆCompute Express Linkï¼‰ç­‰ä¸€è‡´æ€§æ¥å£çš„å‡ºç°ï¼Œä¸ºå†…å­˜æ‰©å±•æä¾›äº†æœ‰æ•ˆè§£å†³æ–¹æ¡ˆï¼Œä½¿ä¸»å†…å­˜èƒ½å¤Ÿæ•´åˆå¤šç§ç‰¹æ€§å„å¼‚çš„å†…å­˜æŠ€æœ¯ã€‚æœ¬æ–‡é€šè¿‡åˆ†æ Meta æœåŠ¡å™¨é›†ç¾¤ä¸­å„ç±»æ•°æ®ä¸­å¿ƒåº”ç”¨çš„å†…å­˜ä½¿ç”¨æ¨¡å¼ï¼Œè¯å®äº†å°†å†·é¡µå¸è½½åˆ°ä½é€Ÿå†…å­˜å±‚çš„å¯è¡Œæ€§ã€‚ç„¶è€Œï¼Œè‹¥ç¼ºä¹é«˜æ•ˆçš„å†…å­˜ç®¡ç†æœºåˆ¶ï¼Œè¿™ç±»åˆ†å±‚å†…å­˜ç³»ç»Ÿä¼šä¸¥é‡é™ä½æ€§èƒ½ã€‚ ä¸ºæ­¤ï¼Œæœ¬æ–‡æå‡ºä¸€ç§é¢å‘ CXL å†…å­˜çš„æ“ä½œç³»ç»Ÿçº§é€æ˜é¡µæ”¾ç½®æœºåˆ¶ï¼ˆTPPï¼‰ã€‚TPP é‡‡ç”¨è½»é‡çº§æ–¹æ³•è¯†åˆ«çƒ­é¡µä¸å†·é¡µï¼Œå¹¶å°†å…¶æ”¾ç½®åˆ°åˆé€‚çš„å†…å­˜å±‚ï¼Œæ”¯æŒä¸»åŠ¨å°†æœ¬åœ°å†…å­˜ä¸­çš„é¡µé¢é™çº§åˆ° CXL å†…å­˜ï¼Œä¸ºæ–°é¡µé¢åˆ†é…é¢„ç•™ç©ºé—´ï¼ˆæ–°åˆ†é…é¡µé¢é€šå¸¸ä¸è¯·æ±‚å¤„ç†ç›¸å…³ï¼Œå…·æœ‰çŸ­ç”Ÿå‘½å‘¨æœŸå’Œé«˜çƒ­ç‰¹æ€§ï¼‰ã€‚åŒæ—¶ï¼ŒTPP èƒ½å¿«é€Ÿå°†æ»ç•™åœ¨ä½é€Ÿ CXL å†…å­˜ä¸­çš„æ€§èƒ½å…³é”®çƒ­é¡µæå‡åˆ°é«˜é€Ÿæœ¬åœ°å†…å­˜ï¼Œä¸”æœ€å°åŒ–é‡‡æ ·å¼€é”€ä¸ä¸å¿…è¦çš„é¡µé¢è¿ç§»ã€‚TPP æ— éœ€åº”ç”¨ç‰¹å®šçŸ¥è¯†ï¼Œå¯ä½œä¸ºå†…æ ¸ç‰ˆæœ¬å…¨å±€éƒ¨ç½²ã€‚ åœ¨æ”¯æŒ CXL 1.1 çš„æ–°å‹ x86 CPU ç”Ÿäº§æœåŠ¡å™¨é›†ç¾¤ä¸­ï¼Œé€šè¿‡å¤šç§å†…å­˜æ•æ„Ÿå‹å·¥ä½œè´Ÿè½½å¯¹ TPP è¿›è¡Œè¯„ä¼°ã€‚ç»“æœè¡¨æ˜ï¼ŒTPP ä½¿åˆ†å±‚å†…å­˜ç³»ç»Ÿæ€§èƒ½æ¥è¿‘ â€œå…¨æœ¬åœ°å†…å­˜â€ çš„ç†æƒ³åŸºå‡†ï¼ˆæ€§èƒ½å·®è· 1%ï¼‰ï¼Œç›¸æ¯”ç°æœ‰ Linux ç³»ç»Ÿæ€§èƒ½æå‡ 18%ï¼Œç›¸æ¯” NUMA Balancingã€AutoTiering ç­‰ç°æœ‰æ–¹æ¡ˆæ€§èƒ½æå‡ 5%-17%ã€‚ç›®å‰ï¼Œå¤§éƒ¨åˆ† TPP è¡¥ä¸å·²æ•´åˆåˆ° Linux v5.18 ç‰ˆæœ¬ï¼Œå‰©ä½™è¡¥ä¸æ­£å¤„äºè®¨è®ºé˜¶æ®µã€‚ 1 å¼•è¨€æ•°æ®ä¸­å¿ƒåº”ç”¨å¯¹å†…å­˜éœ€æ±‚çš„æ¿€å¢ï¼Œå åŠ  DRAM æˆæœ¬ä¸Šå‡ä¸æŠ€æœ¯ç¼©æ”¾æŒ‘æˆ˜ï¼Œä½¿å¾—å†…å­˜æˆä¸ºè¶…å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒåŸºç¡€è®¾æ–½æ”¯å‡ºçš„é‡è¦éƒ¨åˆ†ã€‚é DRAM å†…å­˜æŠ€æœ¯ä¸ºæ„å»ºåˆ†å±‚å†…å­˜å­ç³»ç»Ÿã€ä»¥æ›´ä½æ¯ GB æˆæœ¬æ‰©å±•å†…å­˜å®¹é‡æä¾›äº†å¯èƒ½ï¼Œä½†è¿™ç±»æŠ€æœ¯é€šå¸¸å»¶è¿Ÿè¿œé«˜äºä¸»å†…å­˜ï¼Œè‹¥é¡µé¢åœ¨å†…å­˜å±‚çº§ä¸­æ”¾ç½®ä¸å½“ï¼Œä¼šä¸¥é‡å½±å“æ€§èƒ½ã€‚æ­¤å¤–ï¼Œæœ‰æ•ˆåˆ©ç”¨è¿™äº›æŠ€æœ¯éœ€æå‰æŒæ¡åº”ç”¨è¡Œä¸ºå¹¶è¿›è¡Œç²¾ç»†è°ƒä¼˜ï¼Œè¿™åœ¨åº”ç”¨ç§ç±»ç¹å¤šä¸”å¿«é€Ÿè¿­ä»£çš„è¶…å¤§è§„æ¨¡ç¯å¢ƒä¸­ï¼Œèµ„æºæ¶ˆè€—æé«˜ã€‚ CXLï¼ˆCompute Express Linkï¼‰é€šè¿‡æä¾›ä»‹äº DRAM ä¸é DRAM ä¹‹é—´çš„å»¶è¿Ÿæ°´å¹³ã€ç±» DRAM å¸¦å®½å’Œç¼“å­˜è¡Œç²’åº¦è®¿é—®è¯­ä¹‰ï¼Œç¼“è§£äº†ä¸Šè¿°é—®é¢˜ã€‚CXL åè®®æ”¯æŒæ–°çš„å†…å­˜æ€»çº¿æ¥å£å°†å†…å­˜è¿æ¥åˆ° CPUï¼Œä»è½¯ä»¶è§†è§’çœ‹ï¼ŒCXL å†…å­˜è¡¨ç°ä¸ºæ—  CPU çš„ NUMA èŠ‚ç‚¹ï¼Œå…¶å†…å­˜ç‰¹æ€§ï¼ˆå¸¦å®½ã€å®¹é‡ã€æŠ€æœ¯ç±»å‹ç­‰ï¼‰ç‹¬ç«‹äºç›´æ¥è¿æ¥ CPU çš„æœ¬åœ°å†…å­˜ï¼Œä¸ºå†…å­˜å­ç³»ç»Ÿè®¾è®¡æä¾›çµæ´»æ€§ä¸ç»†ç²’åº¦æ§åˆ¶ã€‚åŒæ—¶ï¼ŒCXL å†…å­˜çš„ç±»ä¸»å†…å­˜ç‰¹æ€§ä¸ºé€æ˜é¡µæ”¾ç½®åˆ›é€ äº†æ¡ä»¶ã€‚ç„¶è€Œï¼ŒLinux å†…å­˜ç®¡ç†æœºåˆ¶åŸºäºåŒæ„ CPU è¿æ¥ DRAM è®¾è®¡ï¼Œåœ¨ CXL å†…å­˜ç³»ç»Ÿä¸­è¡¨ç°ä¸ä½³ â€”â€” ç”±äºä¸åŒå†…å­˜å±‚è®¿é—®å»¶è¿Ÿå­˜åœ¨å·®å¼‚ï¼Œåº”ç”¨æ€§èƒ½é«˜åº¦ä¾èµ–é«˜é€Ÿå†…å­˜æœåŠ¡çš„å†…å­˜è®¿é—®æ¯”ä¾‹ã€‚ ä¸ºéªŒè¯åˆ†å±‚å†…å­˜çš„æ”¶ç›Šï¼Œéœ€å…ˆåˆ†æç°æœ‰æ•°æ®ä¸­å¿ƒåº”ç”¨çš„å†…å­˜è®¿é—®è¡Œä¸ºï¼ŒåŒ…æ‹¬ç‰¹å®šæ—¶é—´æ®µå†…å†…å­˜çš„çƒ­ã€æ¸©ã€å†·çŠ¶æ€å æ¯”åŠé¡µé¢ç”Ÿå‘½å‘¨æœŸé•¿çŸ­ã€‚ç°æœ‰åŸºäºç©ºé—²é¡µè·Ÿè¸ªï¼ˆIPTï¼‰çš„ç‰¹æ€§åˆ†æå·¥å…·å­˜åœ¨æ˜æ˜¾ç¼ºé™·ï¼šéœ€ä¿®æ”¹å†…æ ¸ï¼ˆç”Ÿäº§ç¯å¢ƒä¸­é€šå¸¸ä¸å¯è¡Œï¼‰ã€æŒç»­çš„è®¿é—®ä½é‡‡æ ·ä¸åˆ†æä¼šå¸¦æ¥è¿‡é«˜ CPU å’Œå†…å­˜å¼€é”€ï¼ˆéš¾ä»¥æ”¯æŒå¤§è§„æ¨¡å·¥ä½œé›†ï¼‰ï¼Œä¸”æ— æ³•åŒºåˆ†åº”ç”¨å¯¹ä¸åŒç±»å‹é¡µé¢ï¼ˆåŒ¿åé¡µã€æ–‡ä»¶é¡µç¼“å­˜ã€å…±äº«å†…å­˜ç­‰ï¼‰çš„æ•æ„Ÿåº¦å·®å¼‚ã€‚ä¸ºæ­¤ï¼Œæœ¬æ–‡å¼€å‘è½»é‡çº§ç”¨æˆ·æ€å·¥å…· Chameleonï¼Œåˆ©ç”¨ CPU çš„ç²¾ç¡®äº‹ä»¶é‡‡æ ·ï¼ˆPEBSï¼‰æœºåˆ¶åˆ†æåº”ç”¨å†…å­˜è®¿é—®è¡Œä¸ºï¼Œç”Ÿæˆä¸åŒé¡µé¢ç±»å‹çš„å†…å­˜ä½¿ç”¨çƒ­åŠ›å›¾ï¼Œä¸ºå¤šå†…å­˜å±‚åº”ç”¨æ€§èƒ½é¢„æµ‹æä¾›ä¾æ®ã€‚ é€šè¿‡ Chameleon å¯¹ç”Ÿäº§ç¯å¢ƒä¸­ä¸åŒæœåŠ¡é¢†åŸŸçš„å¤§è§„æ¨¡å†…å­˜å¯†é›†å‹åº”ç”¨è¿›è¡Œåˆ†æï¼Œå¾—å‡ºä»¥ä¸‹å…³é”®å‘ç°ï¼šï¼ˆ1ï¼‰åº”ç”¨å·¥ä½œé›†ä¸­å­˜åœ¨å¤§é‡å¯å¸è½½åˆ°ä½é€Ÿå†…å­˜å±‚ä¸”ä¸å½±å“æ€§èƒ½çš„æ¸©é¡µä¸å†·é¡µï¼›ï¼ˆ2ï¼‰åŒ¿åé¡µï¼ˆç”¨äºç¨‹åºæ ˆã€å †ã€mmap è°ƒç”¨ï¼‰ä¸­çƒ­é¡µå æ¯”æ˜¾è‘—é«˜äºæ–‡ä»¶å¤‡ä»½é¡µï¼›ï¼ˆ3ï¼‰é¡µé¢è®¿é—®æ¨¡å¼åœ¨è¾ƒé•¿æ—¶é—´å†…ï¼ˆåˆ†é’Ÿè‡³å°æ—¶çº§ï¼‰ä¿æŒç¨³å®šï¼Œä¸ºå†…æ ¸å±‚é¡µæ”¾ç½®å†³ç­–æä¾›å……è¶³æ—¶é—´çª—å£ï¼›ï¼ˆ4ï¼‰é¡µé¢åˆ†é…ä¸å›æ”¶ä¼šå¯¼è‡´ç‰©ç†é¡µçƒ­åº¦å¿«é€Ÿå˜åŒ–ï¼Œé™æ€é¡µåˆ†é…ç­–ç•¥ä¼šä¸¥é‡é™ä½æ€§èƒ½ã€‚ åŸºäºä¸Šè¿°å‘ç°ï¼Œæœ¬æ–‡è®¾è®¡æ“ä½œç³»ç»Ÿçº§é€æ˜é¡µæ”¾ç½®æœºåˆ¶ TPPï¼Œå®ç°çƒ­é¡µåœ¨é«˜é€Ÿå†…å­˜å±‚ã€å†·é¡µåœ¨ä½é€Ÿå†…å­˜å±‚çš„é«˜æ•ˆæ”¾ç½®ã€‚TPP åŒ…å«ä¸‰å¤§æ ¸å¿ƒç»„ä»¶ï¼šï¼ˆaï¼‰è½»é‡çº§å›æ”¶æœºåˆ¶ï¼Œå°†å†·é¡µé™çº§åˆ°ä½é€Ÿ CXL èŠ‚ç‚¹ï¼›ï¼ˆbï¼‰è§£è€¦å¤š NUMA ç³»ç»Ÿçš„åˆ†é…ä¸å›æ”¶é€»è¾‘ï¼Œåœ¨é«˜é€Ÿå±‚é¢„ç•™ç©ºé—²é¡µç©ºé—´ï¼›ï¼ˆcï¼‰ååº”å¼é¡µæå‡æœºåˆ¶ï¼Œè¯†åˆ« CXL å†…å­˜ä¸­çš„çƒ­é¡µå¹¶æå‡åˆ°æœ¬åœ°å†…å­˜ã€‚æ­¤å¤–ï¼ŒTPP æ”¯æŒåŸºäºé¡µé¢ç±»å‹çš„åˆ†é…ç­–ç•¥ â€”â€” ä¼˜å…ˆå°†æ•æ„ŸåŒ¿åé¡µåˆ†é…åˆ°æœ¬åœ°å†…å­˜ï¼Œæ–‡ä»¶ç¼“å­˜åˆ†é…åˆ° CXL å†…å­˜ï¼Œè¯¥ç­–ç•¥èƒ½ä¸ºç‰¹å®šè®¿é—®æ¨¡å¼çš„åº”ç”¨æä¾›æ›´ä¼˜åˆå§‹çŠ¶æ€ï¼ŒåŠ é€Ÿæ€§èƒ½æ”¶æ•›ã€‚ åœ¨æ”¯æŒ CXL 1.1 çš„ç³»ç»Ÿä¸­ï¼Œå¯¹å æœåŠ¡å™¨é›†ç¾¤ä¸»è¦ä»½é¢çš„å››ç±»ç”Ÿäº§å·¥ä½œè´Ÿè½½è¿›è¡Œæµ‹è¯•ã€‚ç»“æœæ˜¾ç¤ºï¼ŒTPP ä½¿åˆ†å±‚å†…å­˜ç³»ç»Ÿæ€§èƒ½æ¥è¿‘å…¨æœ¬åœ°å†…å­˜æ°´å¹³ï¼Œå³ä½¿æœ¬åœ° DRAM ä»…ä¸ºç³»ç»Ÿæ€»å†…å­˜çš„ 20%ï¼Œéƒ¨åˆ†å·¥ä½œè´Ÿè½½ä»èƒ½ä¿æŒè¿™ä¸€æ€§èƒ½ã€‚TPP å°†æœ‰æ•ˆçƒ­å†…å­˜å…¨éƒ¨è¿ç§»åˆ°æœ¬åœ°å†…å­˜ï¼Œç›¸æ¯”é»˜è®¤ Linux ç³»ç»Ÿæ€§èƒ½æå‡æœ€é«˜ 18%ï¼Œç›¸æ¯” NUMA Balancingã€AutoTiering ç­‰ä¸»æµåˆ†å±‚å†…å­˜æ–¹æ¡ˆæ€§èƒ½æå‡ 5%-17%ã€‚ æœ¬æ–‡çš„ä¸»è¦è´¡çŒ®å¦‚ä¸‹ï¼š å¼€å‘è½»é‡çº§ç”¨æˆ·æ€å†…å­˜ç‰¹æ€§åˆ†æå·¥å…· Chameleonï¼Œç”¨äºç†è§£å·¥ä½œè´Ÿè½½å†…å­˜æ¶ˆè€—è¡Œä¸ºå¹¶è¯„ä¼°è¶…å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒåˆ†å±‚å†…å­˜çš„åº”ç”¨å‰æ™¯ï¼Œå·²å¼€æºï¼› æå‡ºé¢å‘åˆ†å±‚å†…å­˜ç³»ç»Ÿçš„é«˜æ•ˆå†…å­˜ç®¡ç†æœºåˆ¶ TPPï¼Œå·²å¼€æºï¼Œå¤§éƒ¨åˆ†ä»£ç å·²æ•´åˆåˆ° Linux å†…æ ¸ v5.18ï¼Œå‰©ä½™ä»£ç æ­£å¤„äºä¸Šæ¸¸è®¨è®ºé˜¶æ®µï¼› åœ¨æ”¯æŒ CXL çš„åˆ†å±‚å†…å­˜ç³»ç»Ÿä¸­ï¼Œé€šè¿‡çœŸå®ç”Ÿäº§å·¥ä½œè´Ÿè½½å¯¹ TPP è¿›è¡Œé•¿æœŸè¯„ä¼°ï¼Œè¯å® TPP ä½¿åˆ†å±‚å†…å­˜æ€§èƒ½æ¥è¿‘å…¨æœ¬åœ°å†…å­˜æ°´å¹³ï¼Œç›¸æ¯”é»˜è®¤ Linux æå‡æœ€é«˜ 18%ï¼Œç›¸æ¯” NUMA Balancingã€AutoTiering æå‡ 5%-17%ï¼› é¦–æ¬¡å®ç°å¹¶è¯„ä¼°å¯ç›´æ¥éƒ¨ç½²äºè¶…å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒçš„ç«¯åˆ°ç«¯ CXL å†…å­˜ç³»ç»Ÿã€‚ 2 ç ”ç©¶èƒŒæ™¯ä¸åŠ¨æœº2.1 æ•°æ®ä¸­å¿ƒåº”ç”¨å†…å­˜éœ€æ±‚å¢é•¿ä¸ºæ„å»ºä½å»¶è¿ŸæœåŠ¡ï¼Œå†…å­˜è®¡ç®—å·²æˆä¸ºæ•°æ®ä¸­å¿ƒåº”ç”¨çš„å¸¸æ€ï¼Œå¯¼è‡´æœåŠ¡å™¨é›†ç¾¤å†…å­˜éœ€æ±‚å¿«é€Ÿå¢é•¿ã€‚éšç€ CPU ä¸ DRAM æŠ€æœ¯è¿­ä»£ï¼Œå†…å­˜åœ¨æœºæ¶çº§åŠŸè€—ä¸æ€»æ‹¥æœ‰æˆæœ¬ï¼ˆTCOï¼‰ä¸­çš„å æ¯”æŒç»­ä¸Šå‡ï¼ˆå¦‚å›¾ 3 æ‰€ç¤ºï¼‰ï¼Œå†…å­˜æˆæœ¬ä¸åŠŸè€—ä¼˜åŒ–æˆä¸ºæ•°æ®ä¸­å¿ƒé™æœ¬å¢æ•ˆçš„å…³é”®ã€‚ 2.2 åŒæ„æœåŠ¡å™¨è®¾è®¡çš„æ‰©å±•æ€§æŒ‘æˆ˜å½“å‰æœåŠ¡å™¨æ¶æ„ä¸­ï¼Œå†…å­˜å­ç³»ç»Ÿè®¾è®¡å®Œå…¨ä¾èµ– CPU æ”¯æŒçš„å†…å­˜æŠ€æœ¯ï¼Œå­˜åœ¨è¯¸å¤šé™åˆ¶ï¼šï¼ˆ1ï¼‰å†…å­˜æ§åˆ¶å™¨ä»…æ”¯æŒå•ä¸€ä»£é™…å†…å­˜æŠ€æœ¯ï¼Œæ— æ³•æ··åˆæ­é…ä¸åŒæˆæœ¬ã€å¸¦å®½ä¸å»¶è¿Ÿç‰¹æ€§çš„å†…å­˜ï¼›ï¼ˆ2ï¼‰å†…å­˜å®¹é‡éœ€æŒ‰ 2 çš„å¹‚æ¬¡æ‰©å±•ï¼Œéš¾ä»¥å®ç°ç»†ç²’åº¦å®¹é‡é…ç½®ï¼›ï¼ˆ3ï¼‰æ¯ä»£ DRAM çš„å¸¦å®½ - å®¹é‡ç»„åˆæœ‰é™ï¼Œä¸ºè·å–æ›´é«˜å¸¦å®½å¸¸éœ€è¿‡åº¦é…ç½®å†…å­˜å®¹é‡ã€‚è¿™ç§ CPU ä¸å†…å­˜çš„å¼ºè€¦åˆé™åˆ¶äº†é«˜æ•ˆå†…å­˜å±‚çº§çš„è®¾è®¡ï¼Œå¯¼è‡´è®¡ç®—ã€ç½‘ç»œã€å†…å­˜èµ„æºåˆ©ç”¨ç‡ä½ä¸‹ã€‚æ­¤å¤–ï¼Œç°æœ‰æ”¯æŒå†…å­˜æ‰©å±•çš„æ€»çº¿æ¥å£å¤šä¸ºå‚å•†ä¸“æœ‰ï¼Œè·¨ CPU å…¼å®¹æ€§å·®ï¼Œä¸”å»¶è¿Ÿé«˜ã€ç¼ºä¹ä¸€è‡´æ€§ï¼Œéš¾ä»¥æ»¡è¶³è¶…å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒéœ€æ±‚ã€‚ 2.3 CXL å¯¹åˆ†å±‚å†…å­˜ç³»ç»Ÿçš„æ”¯æ’‘ä½œç”¨CXL æ˜¯åŸºäº PCIe çš„å¼€æ”¾è¡Œä¸šäº’è”æ ‡å‡†ï¼Œæ”¯æŒä¸»æœºå¤„ç†å™¨ä¸è®¾å¤‡ï¼ˆåŠ é€Ÿå™¨ã€å†…å­˜ç¼“å†²å™¨ã€æ™ºèƒ½ IO è®¾å¤‡ç­‰ï¼‰ä¹‹é—´çš„é«˜é€Ÿä½å»¶è¿Ÿé€šä¿¡ï¼ŒåŒæ—¶æ‰©å±•å†…å­˜å®¹é‡ä¸å¸¦å®½ã€‚CXL æä¾›å­—èŠ‚å¯å¯»å€å†…å­˜ç©ºé—´ï¼Œæ”¯æŒé€šè¿‡æ ‡å‡†å†…å­˜åˆ†é… API è¿›è¡Œé€æ˜åˆ†é…ï¼Œå®ç°ç¼“å­˜è¡Œç²’åº¦è®¿é—®ä¸ç¡¬ä»¶ç»´æŠ¤çš„ä¸€è‡´æ€§ã€‚éšç€ PCIe 5.0 çš„æ™®åŠï¼ŒCPU ä¸ CXL äº’è”å¸¦å®½å°†æ¥è¿‘åŒè·¯æœåŠ¡å™¨è·¨æ’æ§½äº’è”å¸¦å®½ï¼ŒCXL å†…å­˜è®¿é—®å»¶è¿Ÿä¸ NUMA è¿œç¨‹è®¿é—®å»¶è¿Ÿç›¸å½“ï¼ˆä»…æ¯”æ™®é€š DRAM é«˜ 50-100 çº³ç§’ï¼‰ã€‚è¿™ç§ç±» NUMA ç‰¹æ€§ä¸ç±»ä¸»å†…å­˜è®¿é—®è¯­ä¹‰ï¼Œä½¿ CXL å†…å­˜æˆä¸ºæ•°æ®ä¸­å¿ƒåˆ†å±‚å†…å­˜ç³»ç»Ÿä¸­ä½é€Ÿå±‚çš„ç†æƒ³é€‰æ‹©ã€‚ ç›®å‰ï¼Œä¸»æµèŠ¯ç‰‡å‚å•†å‡åœ¨å¼€å‘å¹¶é›†æˆ CXL è§£å†³æ–¹æ¡ˆï¼Œæ”¯æŒ CXL æ‰€éœ€çš„å·¥å…·ã€é©±åŠ¨ä¸æ“ä½œç³»ç»Ÿä¿®æ”¹å·²å¼€æºï¼Œé¿å…äº†å¯¹å•ä¸€ä¾›åº”å•†çš„ä¾èµ–ã€‚CXL çªç ´äº†ä¼ ç»Ÿå†…å­˜å­ç³»ç»Ÿçš„é™åˆ¶ï¼Œå…è®¸æ ¹æ®å·¥ä½œè´Ÿè½½éœ€æ±‚çµæ´»è®¾è®¡å†…å­˜å­ç³»ç»Ÿçš„å¸¦å®½ã€å®¹é‡ä¸æˆæœ¬ç»„åˆï¼Œå®ç°è®¡ç®—ä¸å†…å­˜èµ„æºçš„ç‹¬ç«‹æ‰©å±•ï¼Œæå‡é—²ç½®èµ„æºåˆ©ç”¨ç‡ã€‚ 2.4 CXL åˆ†å±‚å†…å­˜ç³»ç»Ÿçš„åº”ç”¨å‰æ™¯æ•°æ®ä¸­å¿ƒå·¥ä½œè´Ÿè½½æå°‘æŒç»­ä½¿ç”¨å…¨éƒ¨å†…å­˜ï¼Œåº”ç”¨å¸¸åˆ†é…å¤§é‡å†…å­˜ä½†è®¿é—®é¢‘ç‡ä½ã€‚æœ¬æ–‡å¯¹ Meta ç”Ÿäº§æœåŠ¡å™¨é›†ç¾¤ä¸­å››ç±»å…¸å‹åº”ç”¨çš„åˆ†ææ˜¾ç¤ºï¼Œä»»æ„ä¸¤åˆ†é’Ÿå†…ï¼Œåº”ç”¨å·²åˆ†é…å†…å­˜ä¸­ 55%-80% å¤„äºç©ºé—²çŠ¶æ€ã€‚å°†è¿™äº›å†·é¡µè¿ç§»åˆ°ä½é€Ÿå†…å­˜å±‚ï¼Œå¯ä¸ºä¸»å†…å­˜é‡Šæ”¾ç©ºé—´ä»¥å®¹çº³æ›´å¤šçƒ­é¡µï¼Œæå‡åº”ç”¨æ€§èƒ½ï¼ŒåŒæ—¶é€šè¿‡ â€œå°å®¹é‡é«˜é€Ÿæœ¬åœ°å†…å­˜ + å¤§å®¹é‡ä½æˆæœ¬ CXL å†…å­˜â€ çš„çµæ´»æœåŠ¡å™¨è®¾è®¡ï¼Œé™ä½æ€»æ‹¥æœ‰æˆæœ¬ï¼ˆTCOï¼‰ã€‚ ä¸ºç®€åŒ–è¡¨è¿°ï¼Œæœ¬æ–‡å°†ç›´æ¥è¿æ¥ CPU çš„å†…å­˜ç§°ä¸º â€œæœ¬åœ°å†…å­˜â€ï¼ŒCXL è¿æ¥çš„å†…å­˜ç§°ä¸º â€œCXL å†…å­˜â€ï¼ˆCXL å†…å­˜å¯é‡‡ç”¨ DRAMã€NVMã€LPDRAM ç­‰ä»»æ„æŠ€æœ¯ï¼‰ã€‚ 3 æ•°æ®ä¸­å¿ƒåº”ç”¨å†…å­˜ç‰¹æ€§åˆ†æä¸ºæ˜ç¡®åˆ†å±‚å†…å­˜ç³»ç»Ÿåœ¨è¶…å¤§è§„æ¨¡åº”ç”¨ä¸­çš„é€‚ç”¨åœºæ™¯ï¼Œæœ¬æ–‡å¼€å‘è½»é‡çº§ç”¨æˆ·æ€å†…å­˜è®¿é—®è¡Œä¸ºåˆ†æå·¥å…· Chameleonã€‚è¯¥å·¥å…·éœ€æ»¡è¶³ä»¥ä¸‹éœ€æ±‚ï¼šå¯åœ¨ç°æœ‰ç”Ÿäº§æœåŠ¡å™¨ä¸Šéƒ¨ç½²ï¼Œä¸å¹²æ‰°è¿è¡Œä¸­åº”ç”¨ï¼Œæ— éœ€ä¿®æ”¹å†…æ ¸ï¼›æ€§èƒ½å¼€é”€ä½ï¼Œä¸å½±å“ç”Ÿäº§åº”ç”¨è¡Œä¸ºï¼›èƒ½åˆ†æåº”ç”¨å†…å­˜è®¿é—®çš„å…³é”®ç‰¹å¾ï¼ˆçƒ­ æ¸© å†·é¡µå æ¯”ã€é¡µé¢åœ¨å„çƒ­åº¦å±‚çš„åœç•™æ—¶é—´ã€è®¿é—®é¢‘ç‡ç­‰ï¼‰ã€‚å®é™…ä½¿ç”¨ä¸­ï¼Œä»…éœ€åœ¨å°‘é‡æœåŠ¡å™¨ä¸Šè¿è¡Œæ•°å°æ—¶ï¼Œå³å¯å®Œæˆå¯¹æŸç±»åº”ç”¨çš„ç‰¹æ€§åˆ†æã€‚ 3.1 Chameleon å·¥å…·è®¾è®¡Chameleon åŒ…å« Collectorï¼ˆæ”¶é›†å™¨ï¼‰ä¸ Workerï¼ˆåˆ†æå™¨ï¼‰ä¸¤ä¸ªç»„ä»¶ï¼Œåˆ†åˆ«è¿è¡Œäºç‹¬ç«‹çº¿ç¨‹ï¼š Collectorï¼ˆæ”¶é›†å™¨ï¼‰ï¼šåˆ©ç”¨ç°ä»£ CPU çš„ PEBS æœºåˆ¶ï¼Œé‡‡é›†ä¸å†…å­˜è®¿é—®ç›¸å…³çš„ç¡¬ä»¶æ€§èƒ½äº‹ä»¶ï¼ŒåŒ…æ‹¬éœ€æ±‚åŠ è½½çš„æœ«çº§ç¼“å­˜ï¼ˆLLCï¼‰ç¼ºå¤±äº‹ä»¶ï¼ˆMEM_LOAD_RETIRED.L3_MISSï¼‰ä¸éœ€æ±‚å­˜å‚¨çš„ TLB ç¼ºå¤±äº‹ä»¶ï¼ˆMEM_INST_RETIRED.STLB_MISS_STORESï¼Œå—ç¡¬ä»¶é™åˆ¶ï¼Œæ— ç²¾ç¡®çš„å­˜å‚¨ LLC ç¼ºå¤±äº‹ä»¶ï¼‰ã€‚é‡‡æ ·è®°å½•åŒ…å«å†…å­˜è®¿é—®äº‹ä»¶å¯¹åº”çš„è¿›ç¨‹ IDï¼ˆPIDï¼‰ä¸è™šæ‹Ÿå†…å­˜åœ°å€ã€‚ é‡‡æ ·ç‡éœ€åœ¨å‡†ç¡®æ€§ä¸æ€§èƒ½å¼€é”€é—´æƒè¡¡ï¼šé«˜é¢‘é‡‡æ ·æå‡å‡†ç¡®æ€§ï¼Œä½†ä¼šå¢åŠ åº”ç”¨çº¿ç¨‹å¼€é”€ä¸ Worker çº¿ç¨‹ CPU æ¶ˆè€—ã€‚åœ¨ Meta é›†ç¾¤ä¸­ï¼Œé»˜è®¤é…ç½®ä¸ºæ¯ 200 ä¸ªäº‹ä»¶é‡‡æ · 1 æ¬¡ï¼Œå®ç°å¼€é”€ä¸å‡†ç¡®æ€§çš„å¹³è¡¡ã€‚ ä¸ºæå‡çµæ´»æ€§ï¼ŒCollector å°†æ‰€æœ‰ CPU æ ¸å¿ƒåˆ’åˆ†ä¸ºå¤šä¸ªç»„ï¼Œæ¯æ¬¡ä»…å¯¹ä¸€ä¸ªæˆ–å¤šä¸ªæ ¸å¿ƒç»„å¯ç”¨é‡‡æ ·ï¼Œæ¯ 5 ç§’ï¼ˆé»˜è®¤ mini_intervalï¼‰è½®æ¢æ ¸å¿ƒç»„ã€‚è¿™ç§ â€œè½®å¾ªé‡‡æ ·â€ æœºåˆ¶å¯è¿›ä¸€æ­¥è°ƒèŠ‚å¼€é”€ä¸å‡†ç¡®æ€§ï¼Œè¿˜æ”¯æŒä¸ºä¸åŒæ ¸å¿ƒç»„é…ç½®ä¸åŒé‡‡æ ·äº‹ä»¶ï¼ˆå¦‚å¯¹å»¶è¿Ÿæ•æ„Ÿåº”ç”¨é‡‡æ ·åŠæ•°æ ¸å¿ƒï¼Œå¯¹å­˜å‚¨å¯†é›†å‹åº”ç”¨åˆ†æ ¸å¿ƒç»„åˆ†åˆ«é‡‡æ ·åŠ è½½ä¸å­˜å‚¨äº‹ä»¶ï¼‰ã€‚ Collector å°†é‡‡æ ·æ•°æ®å†™å…¥ä¸¤ä¸ªå“ˆå¸Œè¡¨ä¹‹ä¸€ï¼Œæ¯ 1 åˆ†é’Ÿï¼ˆé»˜è®¤ intervalï¼‰å”¤é†’ Worker å¤„ç†å½“å‰å“ˆå¸Œè¡¨æ•°æ®ï¼Œå¹¶åˆ‡æ¢åˆ°å¦ä¸€ä¸ªå“ˆå¸Œè¡¨å­˜å‚¨ä¸‹ä¸€æ—¶æ®µé‡‡æ ·æ•°æ®ã€‚ Workerï¼ˆåˆ†æå™¨ï¼‰ï¼šè¿è¡Œäºç‹¬ç«‹çº¿ç¨‹ï¼Œè¯»å–é¡µé¢è®¿é—®ä¿¡æ¯å¹¶ç”Ÿæˆå†…å­˜è®¿é—®è¡Œä¸ºåˆ†æç»“æœã€‚å°†é‡‡æ ·è®°å½•ä¸­çš„åœ°å€è§†ä¸ºè™šæ‹Ÿé¡µè®¿é—®ï¼ˆé¡µé¢å¤§å°ç”±æ“ä½œç³»ç»Ÿå®šä¹‰ï¼Œæ”¯æŒ 4KB æ™®é€šé¡µã€2MB1GB å¤§é¡µç­‰ï¼‰ã€‚ä¸ºåŒæ—¶åˆ†æè™šæ‹Ÿåœ°å€ç©ºé—´ä¸ç‰©ç†åœ°å€ç©ºé—´çš„ç‰¹æ€§ï¼ŒWorker ä¼šå°†é‡‡æ ·è™šæ‹Ÿé¡µæ˜ å°„åˆ°å¯¹åº”çš„ç‰©ç†é¡µï¼›è‹¥åº”ç”¨å·¥ä½œé›†æå¤§ï¼ˆå¦‚ TB çº§ï¼‰ï¼Œå¯ç¦ç”¨ç‰©ç†åœ°å€è½¬æ¢ï¼Œä»…åˆ†æè™šæ‹Ÿåœ°å€ç©ºé—´è®¿é—®æ¨¡å¼ã€‚ å¯¹äºæ¯ä¸ªé¡µé¢ï¼ŒWorker ç”¨ 64 ä½ä½å›¾è®°å½•å…¶åœ¨å„æ—¶é—´é—´éš”å†…çš„æ´»è·ƒçŠ¶æ€ï¼ˆæ´»è·ƒåˆ™ç½®ä½ï¼‰ï¼Œæ¯ä¸ªæ—¶é—´é—´éš”ç»“æŸåä½å›¾å·¦ç§» 1 ä½ä»¥è®°å½•æ–°é—´éš”çŠ¶æ€ã€‚è‹¥éœ€æ•æ‰é¡µé¢è®¿é—®é¢‘ç‡ï¼Œå¯é…ç½®æ¯ä¸ªæ—¶é—´é—´éš”å ç”¨å¤šä½ï¼Œä½†ä¼šç¼©çŸ­å†å²è®°å½•é•¿åº¦ã€‚ç”Ÿæˆç»Ÿè®¡ç»“æœå¹¶æŠ¥å‘Šåï¼ŒWorker è¿›å…¥ä¼‘çœ çŠ¶æ€ã€‚ åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼ŒChameleon ä»…åœ¨ CPU ä¸å†…å­˜ä½¿ç”¨ç‡ä½äº 80% çš„æœåŠ¡å™¨ä¸Šè¿è¡Œï¼Œæœªè§‚å¯Ÿåˆ°å¯¹æœåŠ¡æ€§èƒ½çš„å½±å“ï¼ŒCPU å¼€é”€æ§åˆ¶åœ¨å•ä¸ªæ ¸å¿ƒçš„ 3%-5% ä»¥å†…ã€‚ä»…åœ¨å†…å­˜å¸¦å®½æ•æ„Ÿä¸” CPU æ ¸å¿ƒé¥±å’Œçš„åˆæˆå·¥ä½œè´Ÿè½½ä¸­ï¼Œå›  Chameleon ä¸åº”ç”¨ç«äº‰ CPU èµ„æºï¼Œæ€§èƒ½æŸå¤±çº¦ 7%ã€‚ 3.2 ç”Ÿäº§å·¥ä½œè´Ÿè½½æ¦‚è¿°åˆ©ç”¨ Chameleon å¯¹ Meta ç”Ÿäº§æœåŠ¡å™¨é›†ç¾¤ä¸­å››ç±»é•¿æœŸè¿è¡Œã€å¤„ç†çœŸå®æµé‡çš„å†…å­˜å¯†é›†å‹åº”ç”¨è¿›è¡Œåˆ†æï¼Œè¿™äº›åº”ç”¨è¦†ç›–ä¸åŒæœåŠ¡é¢†åŸŸï¼Œå æœåŠ¡å™¨é›†ç¾¤ä»½é¢è¾ƒå¤§ï¼Œå…·æœ‰ä»£è¡¨æ€§ï¼š Web æœåŠ¡ï¼šè¿è¡Œè™šæ‹Ÿæœºå¤„ç† Web è¯·æ±‚ï¼ŒåŒ…æ‹¬åŸºäº HHVM çš„ Web1 å’ŒåŸºäº Python çš„ Web2ï¼› ç¼“å­˜æœåŠ¡ï¼ˆCacheï¼‰ï¼šåˆ†å¸ƒå¼å†…å­˜å¯¹è±¡ç¼“å­˜æœåŠ¡ï¼Œä½äº Web å±‚ä¸æ•°æ®åº“å±‚ä¹‹é—´ï¼Œæä¾›ä½å»¶è¿Ÿæ•°æ®æŸ¥è¯¢ï¼› æ•°æ®ä»“åº“ï¼ˆData Warehouseï¼‰ï¼šç»Ÿä¸€è®¡ç®—å¼•æ“ï¼Œåœ¨è®¡ç®—é›†ç¾¤ä¸Šå¹¶è¡Œå¤„ç†æ•°æ®ï¼Œåè°ƒæ‰§è¡Œé•¿æ—¶é—´è¿è¡Œçš„å¤æ‚æ‰¹å¤„ç†æŸ¥è¯¢ï¼› å¹¿å‘ŠæœåŠ¡ï¼ˆAdsï¼‰ï¼šè®¡ç®—å¯†é›†å‹å·¥ä½œè´Ÿè½½ï¼Œè¯»å–å†…å­˜æ•°æ®å¹¶æ‰§è¡Œæœºå™¨å­¦ä¹ è®¡ç®—ã€‚ 3.3 é¡µé¢çƒ­åº¦ç‰¹å¾æ•°æ®ä¸­å¿ƒåº”ç”¨çš„å·²åˆ†é…å†…å­˜ä¸­ï¼Œå¤§é‡é¡µé¢åœ¨æ•°åˆ†é’Ÿå†…ä¿æŒå†·æ€ï¼ˆå¦‚å›¾ 7 æ‰€ç¤ºï¼‰ã€‚Webã€Cacheã€Ads æœåŠ¡è™½å ç”¨ç³»ç»Ÿ 95%-98% çš„å†…å­˜å®¹é‡ï¼Œä½†åœ¨ä»»æ„ä¸¤åˆ†é’Ÿå†…ï¼Œå¹³å‡ä»…ä½¿ç”¨ 22%-80% çš„å·²åˆ†é…å†…å­˜ï¼›æ•°æ®ä»“åº“ä½œä¸ºè®¡ç®—å¯†é›†å‹å·¥ä½œè´Ÿè½½ï¼Œè™½å ç”¨æœåŠ¡å™¨å‡ ä¹å…¨éƒ¨å†…å­˜ï¼Œä½†ä¸¤åˆ†é’Ÿå†…ä»… 20% çš„è¢«è®¿é—®å†…å­˜ä¸ºçƒ­é¡µã€‚ ç»“è®ºï¼šæ•°æ®ä¸­å¿ƒåº”ç”¨çš„è¢«è®¿é—®å†…å­˜ä¸­ï¼Œå¤§é‡é¡µé¢åœ¨åˆ†é’Ÿçº§æ—¶é—´å†…ä¿æŒå†·æ€ï¼Œè‹¥é¡µæ”¾ç½®æœºåˆ¶èƒ½å°†è¿™äº›å†·é¡µè¿ç§»åˆ°ä½é€Ÿå†…å­˜å±‚ï¼Œåˆ†å±‚å†…å­˜ç³»ç»Ÿå°†æ˜¾è‘—å—ç›Šã€‚ 3.4 ä¸åŒé¡µé¢ç±»å‹çš„çƒ­åº¦å·®å¼‚åº”ç”¨æ ¹æ®é€»è¾‘ä¸æ‰§è¡Œéœ€æ±‚ä½¿ç”¨ä¸åŒç±»å‹é¡µé¢ï¼Œä½†åŒ¿åé¡µï¼ˆanonï¼‰çš„çƒ­é¡µå æ¯”æ˜¾è‘—é«˜äºæ–‡ä»¶é¡µï¼ˆfileï¼‰ï¼ˆå¦‚å›¾ 8 æ‰€ç¤ºï¼‰ã€‚ä»¥ Web æœåŠ¡ä¸ºä¾‹ï¼Œä¸¤åˆ†é’Ÿå†…åŒ¿åé¡µçƒ­é¡µå æ¯”ä¸º 35%-60%ï¼Œè€Œæ–‡ä»¶é¡µçƒ­é¡µå æ¯”ä»…ä¸º 3%-14%ã€‚ ç¼“å­˜æœåŠ¡ä½¿ç”¨ tmpfs å®ç°é«˜é€Ÿå†…å­˜æŸ¥è¯¢ï¼ŒåŒ¿åé¡µä¸»è¦ç”¨äºæŸ¥è¯¢å¤„ç†ï¼Œæ–‡ä»¶é¡µå çƒ­å†…å­˜æ¯”ä¾‹è¾ƒé«˜ï¼Œä½† Cache1 çš„åŒ¿åé¡µä¸¤åˆ†é’Ÿå†…è®¿é—®å æ¯”ä¸º 40%ï¼Œæ–‡ä»¶é¡µä»…ä¸º 25%ï¼›Cache2 åœ¨ä¸¤åˆ†é’Ÿå†…åŒ¿åé¡µä¸æ–‡ä»¶é¡µè®¿é—®å æ¯”æ¥è¿‘ï¼Œä½†ä¸€åˆ†é’Ÿå†…åŒ¿åé¡µçƒ­é¡µå æ¯”ï¼ˆ43%ï¼‰ä»é«˜äºæ–‡ä»¶é¡µï¼ˆ30%ï¼‰ã€‚ æ•°æ®ä»“åº“ä¸å¹¿å‘ŠæœåŠ¡çš„åŒ¿åé¡µç”¨äºè®¡ç®—ï¼Œæ–‡ä»¶é¡µç”¨äºå­˜å‚¨ä¸­é—´è®¡ç®—ç»“æœï¼Œå› æ­¤çƒ­å†…å­˜å‡ ä¹å…¨éƒ¨ä¸ºåŒ¿åé¡µï¼Œæ–‡ä»¶é¡µå¤šä¸ºå†·é¡µã€‚ ç»“è®ºï¼šçŸ­æ—¶é—´é—´éš”å†…ï¼ŒåŒ¿åé¡µä¸­çƒ­é¡µå æ¯”æ˜¾è‘—é«˜äºæ–‡ä»¶é¡µï¼Œé¡µæ”¾ç½®æœºåˆ¶éœ€è€ƒè™‘é¡µé¢ç±»å‹å·®å¼‚ã€‚ 3.5 é¡µé¢ç±»å‹ä½¿ç”¨çš„æ—¶é—´ç¨³å®šæ€§Web æœåŠ¡å¯åŠ¨æ—¶ï¼Œéœ€å°†è™šæ‹ŸæœºäºŒè¿›åˆ¶æ–‡ä»¶ä¸å­—èŠ‚ç åŠ è½½åˆ°å†…å­˜ï¼Œæ­¤æ—¶æ–‡ä»¶ç¼“å­˜å å†…å­˜æ¯”ä¾‹è¾ƒé«˜ï¼›éšç€è¿è¡Œæ—¶é—´å¢åŠ ï¼ŒåŒ¿åé¡µå æ¯”é€æ¸ä¸Šå‡ï¼Œæ–‡ä»¶ç¼“å­˜è¢«å›æ”¶ä»¥é‡Šæ”¾ç©ºé—´ï¼ˆå¦‚å›¾ 9a æ‰€ç¤ºï¼‰ã€‚ ç¼“å­˜æœåŠ¡ä¸»è¦ä½¿ç”¨æ–‡ä»¶ç¼“å­˜è¿›è¡Œå†…å­˜æŸ¥è¯¢ï¼Œæ–‡ä»¶é¡µå å·²åˆ†é…å†…å­˜çš„ 70%-82%ï¼›è‹¥åŒ¿åé¡µéœ€æ±‚å¢é•¿ï¼Œæ–‡ä»¶é¡µä¼šè¢«å›æ”¶ä»¥å®¹çº³æ–°åŒ¿åé¡µï¼ˆå¦‚å›¾ 9bã€9c æ‰€ç¤ºï¼‰ã€‚ æ•°æ®ä»“åº“çš„åŒ¿åé¡µå å·²åˆ†é…å†…å­˜çš„ 85%ï¼Œæ–‡ä»¶é¡µå  15%ï¼Œä¸”ä¸¤ç±»é¡µé¢å æ¯”åœ¨è¿è¡ŒæœŸé—´ä¿æŒç¨³å®šï¼ˆå¦‚å›¾ 9d æ‰€ç¤ºï¼‰ã€‚ ç»“è®ºï¼šå°½ç®¡åŒ¿åé¡µä¸æ–‡ä»¶é¡µå æ¯”å¯èƒ½éšæ—¶é—´å˜åŒ–ï¼Œä½†åº”ç”¨çš„é¡µé¢ç±»å‹ä½¿ç”¨æ¨¡å¼æ€»ä½“ç¨³å®šï¼Œé¡µæ”¾ç½®æœºåˆ¶éœ€ç»“åˆé¡µé¢ç±»å‹åŠ¨æ€è°ƒæ•´ç­–ç•¥ã€‚ 3.6 é¡µé¢ç±»å‹å¯¹æ€§èƒ½çš„å½±å“å†…å­˜å¯†é›†å‹åº”ç”¨çš„ååé‡éšå†…å­˜åˆ©ç”¨ç‡æå‡è€Œå¢åŠ ï¼Œä½†ä¸åŒå·¥ä½œè´Ÿè½½å¯¹é¡µé¢ç±»å‹çš„æ•æ„Ÿåº¦å­˜åœ¨å·®å¼‚ï¼ˆå¦‚å›¾ 10 æ‰€ç¤ºï¼‰ã€‚ä¾‹å¦‚ï¼ŒWeb æœåŠ¡ååé‡éšåŒ¿åé¡µåˆ©ç”¨ç‡æå‡è€Œæ˜¾è‘—å¢é•¿ï¼›Cache1 çš„åŒ¿åé¡µä½¿ç”¨é‡åœ¨ç”Ÿå‘½å‘¨æœŸå†…å›ºå®šï¼Œå› æ­¤åŒ¿åé¡µä¸æ–‡ä»¶é¡µåˆ©ç”¨ç‡å¯¹ååé‡æ— æ˜æ˜¾å½±å“ï¼›Cache2 çš„é«˜ååé‡å¯¹åº”è¾ƒé«˜çš„åŒ¿åé¡µåˆ©ç”¨ç‡ï¼›æ•°æ®ä»“åº“çš„æ–‡ä»¶é¡µä½¿ç”¨é‡å›ºå®šï¼ŒåŒ¿åé¡µåˆ©ç”¨ç‡è¾¾åˆ°å³°å€¼æ—¶ååé‡æœ€é«˜ã€‚ ç»“è®ºï¼šå·¥ä½œè´Ÿè½½å¯¹ä¸åŒé¡µé¢ç±»å‹çš„æ•æ„Ÿåº¦å­˜åœ¨å·®å¼‚ï¼Œä¸”éšæ—¶é—´å˜åŒ–ï¼Œé¡µæ”¾ç½®æœºåˆ¶éœ€åŠ¨æ€é€‚é…è¿™ç§æ•æ„Ÿåº¦å·®å¼‚ã€‚ 3.7 å†·é¡µé‡è®¿é—®æ—¶é—´ç‰¹å¾å†·é¡µå¯èƒ½åœ¨åç»­æ—¶é—´è¢«é‡æ–°è®¿é—®ï¼Œä¸åŒå·¥ä½œè´Ÿè½½çš„å†·é¡µé‡è®¿é—®æ—¶é—´å·®å¼‚æ˜¾è‘—ï¼ˆå¦‚å›¾ 11 æ‰€ç¤ºï¼‰ã€‚Web æœåŠ¡çš„å†·é¡µä¸­ï¼Œ80% åœ¨ååˆ†é’Ÿå†…è¢«é‡æ–°è®¿é—®ï¼Œè¡¨æ˜ Web æœåŠ¡å¸¸å¤ç”¨æ—©æœŸåˆ†é…çš„é¡µé¢ï¼›ç¼“å­˜æœåŠ¡çš„å†·é¡µä¹Ÿæœ‰å¤§é‡åœ¨ååˆ†é’Ÿå†…é‡è®¿é—®ï¼Œéšæœºå¸è½½å†·é¡µä¼šå½±å“æ€§èƒ½ï¼›æ•°æ®ä»“åº“çš„çƒ­æ–‡ä»¶é¡µä¸­ï¼Œä»… 20% åœ¨ååˆ†é’Ÿå†…è¢«é‡æ–°è®¿é—®ï¼Œå…¶ä½™ä¸ºæ–°åˆ†é…é¡µé¢ã€‚ ç»“è®ºï¼šä¸åŒå·¥ä½œè´Ÿè½½çš„å†·é¡µé‡è®¿é—®æ—¶é—´å·®å¼‚å¤§ï¼Œé¡µæ”¾ç½®æœºåˆ¶éœ€ä¸»åŠ¨å°†é‡è®¿é—®çš„å†·é¡µï¼ˆå˜ä¸ºçƒ­é¡µï¼‰è¿ç§»åˆ°é«˜é€Ÿå†…å­˜å±‚ï¼Œé¿å…é«˜è®¿é—®å»¶è¿Ÿã€‚ ç»¼ä¸Šï¼Œæ•°æ®ä¸­å¿ƒåº”ç”¨å­˜åœ¨å¤§é‡å†·é¡µä¸”è®¿é—®æ¨¡å¼ç¨³å®šï¼Œåˆ†å±‚å†…å­˜ç³»ç»Ÿå…·æœ‰å¹¿é˜”åº”ç”¨å‰æ™¯ï¼Œè€Œé«˜æ•ˆçš„é¡µæ”¾ç½®æœºåˆ¶æ˜¯å‘æŒ¥åˆ†å±‚å†…å­˜ä¼˜åŠ¿çš„å…³é”®ã€‚ 4 TPP è®¾è®¡åŸåˆ™éšç€ CXL æŠ€æœ¯çš„æ™®åŠï¼Œè¶…å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒå¼€å§‹é‡‡ç”¨ CXL ä½¿èƒ½çš„å¼‚æ„åˆ†å±‚å†…å­˜ç³»ç»Ÿï¼Œä¸åŒå†…å­˜å±‚æ€§èƒ½ç‰¹æ€§å·®å¼‚æ˜¾è‘—ã€‚ä¸ºä¼˜åŒ–è¿™ç±»ç³»ç»Ÿæ€§èƒ½ï¼Œéœ€è®¾è®¡é€æ˜é¡µæ”¾ç½®æœºåˆ¶ï¼ˆTPPï¼‰ï¼Œå®ç°ä¸åŒçƒ­åº¦é¡µé¢åœ¨å¯¹åº”å†…å­˜å±‚çš„é«˜æ•ˆæ”¾ç½®ã€‚è®¾è®¡ TPP éœ€è§£å†³ä¸‰ä¸ªæ ¸å¿ƒé—®é¢˜ï¼šTPP çš„å®ç°å±‚çº§ã€é¡µé¢çƒ­åº¦æ£€æµ‹æ–¹æ³•ã€CXL å†…å­˜çš„æŠ½è±¡æ–¹å¼ã€‚æœ¬èŠ‚å°†é˜è¿°è¿™äº›è®¾è®¡é€‰æ‹©çš„ä¾æ®ä¸æƒè¡¡ã€‚ 4.1 å®ç°å±‚çº§é€‰æ‹©é€æ˜é¡µæ”¾ç½®æœºåˆ¶å¯åœ¨ç”¨æˆ·æ€æˆ–å†…æ ¸æ€å®ç°ï¼š ç”¨æˆ·æ€å®ç°ï¼šå¯åŸºäº Chameleon ç±»å·¥å…·æ£€æµ‹é¡µé¢çƒ­åº¦ï¼Œé€šè¿‡move_pages()ç­‰ç”¨æˆ·æ€ API å®ç° NUMA è¿ç§»ã€‚ä½†è¯¥æ–¹å¼å­˜åœ¨æ˜æ˜¾ç¼ºé™·ï¼šç”¨æˆ·æ€ä¸å†…æ ¸æ€ä¸Šä¸‹æ–‡åˆ‡æ¢å¸¦æ¥é¢å¤–å¼€é”€ï¼›éœ€åœ¨ç”¨æˆ·æ€ç®¡ç†é¡µé¢å†å²ä¿¡æ¯ï¼Œå¢åŠ å¤„ç†å¼€é”€ï¼›é¡µé¢ä¿¡æ¯å­˜å‚¨çš„å†…å­˜å¼€é”€éšå·¥ä½œé›†è§„æ¨¡å¢é•¿è€Œæ‰©å¤§ï¼Œéš¾ä»¥æ”¯æŒå¤§è§„æ¨¡åœºæ™¯ã€‚å› æ­¤ï¼Œç”¨æˆ·æ€å®ç°ä»…é€‚ç”¨äºçŸ­æ—¶é—´ã€å°èŒƒå›´çš„æ€§èƒ½åˆ†æï¼Œæ— æ³•æ»¡è¶³å…¨ç”Ÿäº§é›†ç¾¤çš„æŒç»­è¿è¡Œéœ€æ±‚ã€‚ å†…æ ¸æ€å®ç°ï¼šå†…æ ¸æ€å®ç°æ— éœ€ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå¯ç›´æ¥åˆ©ç”¨å†…æ ¸ç°æœ‰å†…å­˜ç®¡ç†ç»„ä»¶ï¼ˆå¦‚ LRU é“¾è¡¨ï¼‰ï¼Œå¼€é”€æ›´ä½ã€å¤æ‚åº¦æ›´å°ã€æ€§èƒ½æ›´ä¼˜ã€‚å› æ­¤ï¼ŒTPP é€‰æ‹©åœ¨å†…æ ¸æ€å®ç°ã€‚ 4.2 é¡µé¢çƒ­åº¦æ£€æµ‹æ–¹æ³•é¡µé¢çƒ­åº¦æ£€æµ‹æœ‰å¤šç§å€™é€‰æŠ€æœ¯ï¼Œéœ€ç»“åˆå¯è¡Œæ€§ã€å¼€é”€ä¸å…¼å®¹æ€§ç»¼åˆé€‰æ‹©ï¼š PEBSï¼ˆç²¾ç¡®äº‹ä»¶é‡‡æ ·ï¼‰ï¼šPEBS å¯åœ¨ç¡¬ä»¶å±‚é¢é‡‡é›†å†…å­˜è®¿é—®äº‹ä»¶ï¼Œä½†å­˜åœ¨æ˜æ˜¾å±€é™ï¼šä¸åŒ CPU å‚å•†çš„ PEBS è®¡æ•°å™¨ä¸å…¼å®¹ï¼Œéš¾ä»¥å®ç°è·¨ç¡¬ä»¶å¹³å°çš„é€šç”¨å†…æ ¸çº§çƒ­åº¦æ£€æµ‹ï¼›CPU æ”¯æŒçš„æ€§èƒ½è®¡æ•°å™¨æ•°é‡æœ‰é™ï¼Œä¸”é€šå¸¸éœ€æš´éœ²ç»™ç”¨æˆ·æ€ï¼›å³ä½¿ä¼˜åŒ–åï¼ŒPEBS é‡‡æ ·åœ¨é«˜å‹åŠ›å·¥ä½œè´Ÿè½½ä¸­ä»å­˜åœ¨è¾ƒé«˜å¼€é”€ï¼Œä¸é€‚åˆä½œä¸º TPP çš„å¸¸é©»ç»„ä»¶ã€‚ é¡µé¢ä¸­æ¯’ï¼ˆPage Poisoningï¼‰ï¼šé€šè¿‡å¯¹å†…å­˜åŒºåŸŸä¸­çš„éƒ¨åˆ†é¡µé¢è¿›è¡Œé‡‡æ ·ä¸ â€œä¸­æ¯’â€ è·Ÿè¸ªè®¿é—®äº‹ä»¶ï¼Œæ˜¯æ£€æµ‹çƒ­é¡µ å†·é¡µçš„å¸¸ç”¨æ–¹æ³•ã€‚åŸºäº IPTï¼ˆç©ºé—²é¡µè·Ÿè¸ªï¼‰çš„é¡µé¢ä¸­æ¯’æŠ€æœ¯éœ€é¢‘ç¹æ¸…é™¤é¡µé¢è®¿é—®ä½å¹¶åˆ·æ–° TLBï¼Œå¯¼è‡´ä¸¥é‡æ€§èƒ½ä¸‹é™ï¼›Thermostat é€šè¿‡ 2MB å¤§é¡µç²’åº¦é‡‡æ ·ä¼˜åŒ–æ€§èƒ½ï¼Œä½†ä»…é€‚ç”¨äºå¤§é¡µåœºæ™¯ï¼Œè€Œ TPP éœ€æ”¯æŒä»»æ„é¡µé¢å¤§å°ï¼ˆç”Ÿäº§ç¯å¢ƒä¸­åº”ç”¨å¸¸ä½¿ç”¨ 2MB1GB å¤§é¡µå­˜å‚¨ä»£ç ã€é™æ€æ•°æ®ç­‰çƒ­æ•°æ®ï¼Œéœ€é¿å…å…¶è¢«é™çº§åˆ° CXL å†…å­˜ï¼‰ã€‚ NUMA Balancingï¼ˆAutoNUMAï¼‰ï¼šNUMA Balancing æ”¯æŒä»»æ„é¡µé¢å¤§å°ï¼Œé€šè¿‡é‡‡æ ·é¡µé¢è®¿é—®ç”Ÿæˆæ¬¡è¦é¡µé”™è¯¯æ¥åˆ¤æ–­é¡µé¢çƒ­åº¦ã€‚ä½†å¯¹é«˜é¢‘è®¿é—®é¡µé¢é¢‘ç¹è§¦å‘é¡µé”™è¯¯ä¼šå¸¦æ¥è¿‡é«˜å¼€é”€ã€‚TPP å¯¹è¯¥æŠ€æœ¯è¿›è¡Œä¼˜åŒ–ï¼šä»…å°†æ¬¡è¦é¡µé”™è¯¯ä½œä¸º CXL å†…å­˜çš„çƒ­åº¦æ£€æµ‹æœºåˆ¶ï¼ˆCXL å†…å­˜ä¸»è¦å­˜å‚¨æ¸©é¡µä¸å†·é¡µï¼Œé‡‡æ ·å¼€é”€ä½ï¼‰ï¼›æœ¬åœ°å†…å­˜çš„å†·é¡µæ£€æµ‹åˆ™å¤ç”¨ Linux ç°æœ‰ LRU è€åŒ–æœºåˆ¶ï¼ˆè½»é‡çº§ä¸”é«˜æ•ˆï¼‰ã€‚ å®éªŒè¯å®ï¼Œç»“åˆ LRU ä¸ NUMA Balancing çš„çƒ­åº¦æ£€æµ‹æ–¹æ³•å¯æœ‰æ•ˆè¯†åˆ« CXL å†…å­˜ä¸­çš„çƒ­é¡µï¼Œä¸”å¼€é”€æ¥è¿‘é›¶ã€‚ 4.3 CXL å†…å­˜çš„æŠ½è±¡æ–¹å¼CXL å†…å­˜å¯é€šè¿‡ç°æœ‰å†…å­˜äº¤æ¢æœºåˆ¶ï¼ˆå¦‚ zswapï¼‰ä½œä¸ºäº¤æ¢ç©ºé—´å­˜å‚¨å†·é¡µï¼Œä½†è¯¥æ–¹å¼å­˜åœ¨å…³é”®ç¼ºé™·ï¼šä¼šä¸§å¤± CXL çš„æ ¸å¿ƒä¼˜åŠ¿ â€”â€” ç¼“å­˜è¡Œç²’åº¦çš„åŠ è½½ å­˜å‚¨è®¿é—®è¯­ä¹‰ã€‚äº¤æ¢ç©ºé—´æŠ½è±¡ä¸‹ï¼Œè®¿é—®äº¤æ¢é¡µé¢éœ€è§¦å‘ä¸»è¦é¡µé”™è¯¯å¹¶è¯»å–æ•´ä¸ªé¡µé¢ï¼Œå¯¼è‡´æœ‰æ•ˆå»¶è¿Ÿè¿œè¶… 200 çº³ç§’ï¼Œä½¿ CXL å†…å­˜å¤±å»ç«äº‰åŠ›ã€‚ å› æ­¤ï¼ŒTPP é€‰æ‹©å°† CXL å†…å­˜è§†ä¸ºå¸¸è§„å†…å­˜è€Œéäº¤æ¢ç©ºé—´ï¼Œåº”ç”¨å¯é€šè¿‡åŠ è½½ å­˜å‚¨æŒ‡ä»¤ç›´æ¥è®¿é—® CXL å†…å­˜ä¸­çš„æ¸©é¡µä¸å†·é¡µï¼Œé¿å…é¡µé”™è¯¯å¼€é”€ã€‚éœ€æ³¨æ„çš„æ˜¯ï¼ŒåŸºäºäº¤æ¢çš„å†…å­˜ç®¡ç†æœºåˆ¶ï¼ˆå¦‚ TMOï¼‰ä¸ TPP å¹¶éç«äº‰å…³ç³»ï¼Œè€Œæ˜¯äº’è¡¥ï¼šTMO è¿è¡Œäºç”¨æˆ·æ€ï¼Œé€šè¿‡åé¦ˆé©±åŠ¨å›æ”¶å†…å­˜ï¼›TPP è¿è¡Œäºå†…æ ¸æ€ï¼Œä¼˜åŒ–æœ¬åœ°å†…å­˜ä¸ CXL å†…å­˜é—´çš„é¡µæ”¾ç½®ï¼ŒäºŒè€…å¯ååŒå·¥ä½œã€‚ 5 TPP æœºåˆ¶è®¾è®¡é«˜æ•ˆçš„é¡µæ”¾ç½®æœºåˆ¶éœ€å®ç°ï¼šå°†å†·é¡µå¸è½½åˆ° CXL å†…å­˜ï¼Œå°† CXL å†…å­˜ä¸­çš„çƒ­é¡µæå‡åˆ°æœ¬åœ°å†…å­˜ï¼›æ”¯æŒå¼‚æ„å†…å­˜æŠ€æœ¯ï¼Œé€‚åº” CXL å†…å­˜çš„æ—  CPU NUMA èŠ‚ç‚¹ç‰¹æ€§ï¼›é¿å…åˆ†é…å› å›æ”¶ç¼“æ…¢è€Œåœæ»ï¼ŒåŒæ—¶è€ƒè™‘åº”ç”¨å¯¹é¡µé¢ç±»å‹çš„æ•æ„Ÿåº¦ã€‚åŸºäºæ­¤ï¼ŒTPP è®¾è®¡åŒ…å«å››å¤§æ ¸å¿ƒæ¨¡å—ï¼šè½»é‡çº§ CXL é™çº§æœºåˆ¶ã€åˆ†é… - å›æ”¶è§£è€¦ã€CXL çƒ­é¡µæå‡ã€é¡µé¢ç±»å‹æ„ŸçŸ¥åˆ†é…ã€‚ 5.1 è½»é‡çº§ CXL é™çº§æœºåˆ¶Linux é»˜è®¤å°†é¡µé¢åˆ†é…åˆ°è¿›ç¨‹è¿è¡Œ CPU çš„æœ¬åœ°å†…å­˜èŠ‚ç‚¹ï¼Œå½“æœ¬åœ°å†…å­˜èŠ‚ç‚¹æ»¡æ—¶ï¼Œé€šè¿‡äº¤æ¢ï¼ˆswapï¼‰å›æ”¶é¡µé¢ã€‚åœ¨ NUMA ç³»ç»Ÿä¸­ï¼Œè‹¥æœ¬åœ°å†…å­˜å›æ”¶ç¼“æ…¢ï¼Œæ–°åˆ†é…é¡µé¢ä¼šè¢«åˆ†é…åˆ° CXL èŠ‚ç‚¹ï¼Œå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚ TPP çš„é™çº§æœºåˆ¶ä¼˜åŒ–ï¼šæœ¬åœ°å†…å­˜è§¦å‘å›æ”¶æ—¶ï¼Œä¸æ‰§è¡Œäº¤æ¢ï¼Œè€Œæ˜¯å°†å›æ”¶å€™é€‰é¡µé¢åŠ å…¥ç‹¬ç«‹é™çº§åˆ—è¡¨ï¼Œå¼‚æ­¥è¿ç§»åˆ° CXL èŠ‚ç‚¹ï¼ˆè¿ç§»é€Ÿåº¦è¿œå¿«äºäº¤æ¢ï¼‰ã€‚é™çº§å€™é€‰é¡µé¢é€šè¿‡ Linux ç°æœ‰ LRU æœºåˆ¶é€‰æ‹©ï¼Œä¼˜å…ˆé€‰æ‹©éæ´»è·ƒé¡µé¢ï¼Œé™ä½çƒ­é¡µè¯¯é™çº§é£é™©ã€‚è‹¥ CXL èŠ‚ç‚¹å†…å­˜ä¸è¶³å¯¼è‡´è¿ç§»å¤±è´¥ï¼Œå† fallback åˆ°é»˜è®¤äº¤æ¢å›æ”¶æœºåˆ¶ï¼›CXL èŠ‚ç‚¹æœ¬èº«ä»ä½¿ç”¨é»˜è®¤äº¤æ¢å›æ”¶ï¼ˆCXL èŠ‚ç‚¹æ€§èƒ½æ•æ„Ÿåº¦ä½ï¼‰ã€‚ è‹¥ç³»ç»Ÿå­˜åœ¨å¤šä¸ª CXL èŠ‚ç‚¹ï¼Œæ ¹æ® CPU åˆ°å„ CXL èŠ‚ç‚¹çš„è·ç¦»é€‰æ‹©é™çº§ç›®æ ‡ï¼ˆè·ç¦»è¶Šè¿‘å»¶è¿Ÿè¶Šä½ï¼‰ã€‚è¯¥é™æ€è·ç¦»ç­–ç•¥è™½ç®€å•ï¼Œä½†åœ¨å®éªŒä¸­è¡¨ç°å‡ºè‰¯å¥½æœ‰æ•ˆæ€§ã€‚ 5.2 åˆ†é…ä¸å›æ”¶è§£è€¦Linux ä¸ºæ¯ä¸ªå†…å­˜èŠ‚ç‚¹çš„å†…å­˜åŸŸç»´æŠ¤ä¸‰ä¸ªæ°´ä½çº¿ï¼ˆminã€lowã€highï¼‰ï¼šå½“ç©ºé—²é¡µä½äº low æ°´ä½çº¿æ—¶ï¼Œè§¦å‘å›æ”¶ï¼›ç›´åˆ°ç©ºé—²é¡µå›å‡åˆ° high æ°´ä½çº¿ï¼Œæ‰å…è®¸æ–°åˆ†é…ã€‚åœ¨é«˜åˆ†é…é€Ÿç‡åœºæ™¯ä¸‹ï¼Œå›æ”¶é€Ÿåº¦éš¾ä»¥è·Ÿä¸Šåˆ†é…é€Ÿåº¦ï¼Œå¯¼è‡´æœ¬åœ°å†…å­˜é¢‘ç¹åœæ­¢åˆ†é…ï¼Œæ–°é¡µé¢è¢«åˆ†é…åˆ° CXL èŠ‚ç‚¹ï¼Œæ€§èƒ½ä¸‹é™ã€‚ TPP é€šè¿‡è§£è€¦ â€œå›æ”¶åœæ­¢æ¡ä»¶â€ ä¸ â€œåˆ†é…å…è®¸æ¡ä»¶â€ï¼Œåœ¨æœ¬åœ°èŠ‚ç‚¹ä¸»åŠ¨ç»´æŒç©ºé—²é¡µä½™é‡ï¼š å›æ”¶é€»è¾‘ï¼šæœ¬åœ°èŠ‚ç‚¹çš„å›æ”¶æŒç»­è¿è¡Œï¼Œç›´åˆ°ç©ºé—²é¡µè¾¾åˆ° â€œé™çº§æ°´ä½çº¿â€ï¼ˆdemotion_watermarkï¼‰ï¼› åˆ†é…é€»è¾‘ï¼šåªè¦ç©ºé—²é¡µè¾¾åˆ° â€œåˆ†é…æ°´ä½çº¿â€ï¼ˆallocation_watermarkï¼‰ï¼Œå³å¯å…è®¸æ–°åˆ†é…ã€‚ å…¶ä¸­ï¼Œé™çº§æ°´ä½çº¿å§‹ç»ˆé«˜äºåˆ†é…æ°´ä½çº¿ä¸ low æ°´ä½çº¿ï¼Œç¡®ä¿æœ¬åœ°èŠ‚ç‚¹é¢„ç•™å……è¶³ç©ºé—²é¡µã€‚è¯¥è®¾è®¡çš„ä¼˜åŠ¿åœ¨äºï¼šï¼ˆ1ï¼‰çªå‘åˆ†é…ï¼ˆé€šå¸¸ä¸è¯·æ±‚å¤„ç†ç›¸å…³ï¼ŒçŸ­ç”Ÿå‘½å‘¨æœŸã€é«˜çƒ­ï¼‰å¯ç›´æ¥åˆ†é…åˆ°æœ¬åœ°å†…å­˜ï¼›ï¼ˆ2ï¼‰æœ¬åœ°å†…å­˜æœ‰å……è¶³ç©ºé—´æ¥æ”¶ä» CXL èŠ‚ç‚¹æå‡çš„çƒ­é¡µã€‚ ä¸ºé€‚åº”ä¸åŒåº”ç”¨ç‰¹æ€§ï¼ŒTPP æä¾›ç”¨æˆ·æ€ sysctl æ¥å£ï¼ˆ/proc/sys/vm/demote_scale_factorï¼‰ï¼Œæ§åˆ¶æœ¬åœ°èŠ‚ç‚¹è§¦å‘å›æ”¶çš„ç©ºé—²é¡µé˜ˆå€¼ï¼Œé»˜è®¤å€¼ä¸º 2%ï¼ˆå³ç©ºé—²é¡µä½äºæœ¬åœ°èŠ‚ç‚¹å®¹é‡çš„ 2% æ—¶å¯åŠ¨å›æ”¶ï¼‰ã€‚ç®¡ç†å‘˜å¯ç»“åˆå·¥ä½œè´Ÿè½½ç›‘æ§å·¥å…·åŠ¨æ€è°ƒæ•´è¯¥å€¼ï¼šè‹¥åº”ç”¨åˆ†é…éœ€æ±‚é«˜ä¸”å†·é¡µå æ¯”å¤§ï¼Œå¯æé«˜é˜ˆå€¼ä»¥å¢å¼ºå›æ”¶ç§¯ææ€§ï¼›è‹¥åº”ç”¨çƒ­é¡µå æ¯”è¶…è¿‡æœ¬åœ°èŠ‚ç‚¹å®¹é‡ï¼Œéœ€é™ä½é˜ˆå€¼é¿å…çƒ­é¡µé¢‘ç¹è¿ç§»ã€‚ 5.3 CXL çƒ­é¡µæå‡æœºåˆ¶æœ¬åœ°å†…å­˜å‹åŠ›å¯èƒ½å¯¼è‡´æ–°é¡µé¢è¢«åˆ†é…åˆ° CXL èŠ‚ç‚¹ï¼Œä¸”é™çº§åˆ° CXL èŠ‚ç‚¹çš„é¡µé¢å¯èƒ½é‡æ–°å˜ä¸ºçƒ­é¡µã€‚è‹¥ç¼ºä¹æå‡æœºåˆ¶ï¼Œè¿™äº›çƒ­é¡µä¼šé•¿æœŸæ»ç•™ CXL èŠ‚ç‚¹ï¼Œä¸¥é‡å½±å“æ€§èƒ½ã€‚TPP é€šè¿‡å¢å¼º Linux NUMA Balancing å®ç°é«˜æ•ˆçƒ­é¡µæå‡ã€‚ 5.3.1 é¢å‘ CXL çš„ NUMA Balancing ä¼˜åŒ–åŸç”Ÿ NUMA Balancing ä¼šé‡‡æ ·æ‰€æœ‰å†…å­˜èŠ‚ç‚¹çš„é¡µé¢ï¼Œå¯¹è¿œç¨‹è®¿é—®é¡µé¢è¿›è¡Œæå‡ï¼Œä½†è¯¥æœºåˆ¶åœ¨ CXL ç³»ç»Ÿä¸­å­˜åœ¨å†—ä½™ï¼šï¼ˆ1ï¼‰æœ¬åœ°å†…å­˜çš„çƒ­é¡µæ— éœ€é‡‡æ ·ï¼Œé‡‡æ ·ä¼šå¢åŠ ä¸å¿…è¦çš„é¡µé”™è¯¯å¼€é”€ï¼›ï¼ˆ2ï¼‰æ— éœ€å°†æœ¬åœ°å†…å­˜çƒ­é¡µæå‡åˆ°å…¶ä»–èŠ‚ç‚¹ã€‚å› æ­¤ï¼ŒTPP å°† NUMA Balancing é‡‡æ ·èŒƒå›´é™åˆ¶ä¸º CXL èŠ‚ç‚¹ï¼Œä»…åˆ†æ CXL èŠ‚ç‚¹é¡µé¢çš„è®¿é—®æƒ…å†µã€‚ æå‡ CXL èŠ‚ç‚¹çƒ­é¡µæ—¶ï¼ŒTPP å¿½ç•¥æœ¬åœ°èŠ‚ç‚¹çš„åˆ†é…æ°´ä½çº¿æ£€æŸ¥ï¼Œé€šè¿‡å¢åŠ æœ¬åœ°èŠ‚ç‚¹å†…å­˜å‹åŠ›ï¼Œè§¦å‘å†·é¡µå›æ”¶ä»¥å®¹çº³æå‡çš„çƒ­é¡µã€‚è‹¥ç³»ç»Ÿå­˜åœ¨å¤šä¸ªæœ¬åœ°èŠ‚ç‚¹ï¼Œä¼˜å…ˆé€‰æ‹©è¿›ç¨‹å½“å‰è¿è¡Œçš„æœ¬åœ°èŠ‚ç‚¹ï¼›è‹¥åº”ç”¨è·¨å¤šä¸ªæœ¬åœ°èŠ‚ç‚¹ï¼Œé€‰æ‹©å†…å­˜å‹åŠ›æœ€ä½çš„èŠ‚ç‚¹ä½œä¸ºæå‡ç›®æ ‡ã€‚ 5.3.2 é¿å… â€œä¹’ä¹“æ•ˆåº”â€ çš„çƒ­é¡µè¯†åˆ«åŸç”Ÿ NUMA Balancing åœ¨æ£€æµ‹åˆ°é¡µé¢è®¿é—®æ—¶ç«‹å³æå‡ï¼Œæœªè€ƒè™‘é¡µé¢æ´»è·ƒçŠ¶æ€ï¼Œå¯¼è‡´ä½é¢‘è®¿é—®é¡µé¢è¢«è¯¯æå‡åˆ°æœ¬åœ°èŠ‚ç‚¹ã€‚è¿™äº›é¡µé¢éšåå¯èƒ½å› æœ¬åœ°å†…å­˜å‹åŠ›è¢«é™çº§å› CXL èŠ‚ç‚¹ï¼Œå½¢æˆ â€œä¹’ä¹“æ•ˆåº”â€ï¼Œæµªè´¹å¸¦å®½ä¸ CPU èµ„æºã€‚ TPP é€šè¿‡é¡µé¢ LRU çŠ¶æ€åˆ¤æ–­é¡µé¢æ´»è·ƒåº¦ï¼Œé¿å…è¯¯æå‡ï¼š è‹¥ CXL èŠ‚ç‚¹çš„é‡‡æ ·é¡µé¢å¤„äºéæ´»è·ƒ LRU é“¾è¡¨ï¼Œä¸ç«‹å³æå‡ï¼ˆå¯èƒ½ä¸ºä½é¢‘è®¿é—®é¡µï¼‰ï¼› ä»…å½“é¡µé¢å¤„äºæ´»è·ƒ LRU é“¾è¡¨æ—¶ï¼Œæ‰å°†å…¶è§†ä¸ºæå‡å€™é€‰ã€‚ ä½† CXL èŠ‚ç‚¹é€šå¸¸å†…å­˜å‹åŠ›è¾ƒä½ï¼Œå›æ”¶ä¸é¢‘ç¹ï¼Œéæ´»è·ƒ LRU é“¾è¡¨ä¸­çš„é¡µé¢å¯èƒ½æ— æ³•è‡ªåŠ¨è¿ç§»åˆ°æ´»è·ƒé“¾è¡¨ï¼Œå¯¼è‡´çƒ­é¡µè¢«é—æ¼ã€‚ä¸ºæ­¤ï¼ŒTPP è¡¥å……ä¼˜åŒ–ï¼šå½“é‡‡æ ·åˆ°éæ´»è·ƒ LRU é“¾è¡¨ä¸­çš„é¡µé¢è®¿é—®æ—¶ï¼Œç«‹å³å°†é¡µé¢æ ‡è®°ä¸º â€œå·²è®¿é—®â€ å¹¶è¿ç§»åˆ°æ´»è·ƒ LRU é“¾è¡¨ï¼›è‹¥è¯¥é¡µé¢åœ¨åç»­é‡‡æ ·ä¸­å†æ¬¡è¢«è®¿é—®ï¼ˆæ­¤æ—¶å·²å¤„äºæ´»è·ƒé“¾è¡¨ï¼‰ï¼Œåˆ™æ‰§è¡Œæå‡ã€‚ è¯¥è®¾è®¡ä¸ºé¡µé¢æå‡å¢åŠ  â€œæ»åæ€§â€ï¼Œç»“åˆ Linux ä¸ºåŒ¿åé¡µä¸æ–‡ä»¶é¡µç»´æŠ¤ç‹¬ç«‹ LRU é“¾è¡¨çš„ç‰¹æ€§ï¼Œä½¿ä¸åŒç±»å‹é¡µé¢æŒ‰è‡ªèº«æ´»è·ƒåº¦ç‹¬ç«‹è°ƒæ•´æå‡é€Ÿç‡ï¼ŒåŠ é€Ÿçƒ­é¡µåœ¨å†…å­˜å±‚é—´çš„æ”¶æ•›ã€‚ 5.4 é¡µé¢ç±»å‹æ„ŸçŸ¥åˆ†é…ä¸Šè¿°é¡µæ”¾ç½®æœºåˆ¶å¯¹é¡µé¢ç±»å‹æ— å·®åˆ«å¤„ç†ï¼Œä½†éƒ¨åˆ†åº”ç”¨å¯é€šè¿‡ç±»å‹æ„ŸçŸ¥åˆ†é…è¿›ä¸€æ­¥ä¼˜åŒ–æ€§èƒ½ã€‚ä¾‹å¦‚ï¼Œåº”ç”¨é¢„çƒ­é˜¶æ®µå¸¸è¿›è¡Œå¤§é‡æ–‡ä»¶ IOï¼Œç”Ÿæˆçš„æ–‡ä»¶ç¼“å­˜å¤šä¸ºå†·é¡µï¼Œè‹¥è¿™äº›æ–‡ä»¶ç¼“å­˜å æ®æœ¬åœ°å†…å­˜ï¼Œä¼šå¯¼è‡´åŒ¿åé¡µè¢«åˆ†é…åˆ° CXL èŠ‚ç‚¹ï¼Œåç»­éœ€é¢‘ç¹æå‡ï¼Œå¢åŠ è¿ç§»å¼€é”€ã€‚ TPP æ”¯æŒå¯é€‰çš„ â€œé¡µé¢ç±»å‹æ„ŸçŸ¥åˆ†é…â€ ç­–ç•¥ï¼š åŒ¿åé¡µï¼šä¼˜å…ˆåˆ†é…åˆ°æœ¬åœ°å†…å­˜ï¼ˆåŒ¿åé¡µé€šå¸¸ä¸ºçƒ­é¡µï¼Œå¯¹æ€§èƒ½æ•æ„Ÿï¼‰ï¼› æ–‡ä»¶ç¼“å­˜ï¼ˆå« tmpfsï¼‰ï¼šä¼˜å…ˆåˆ†é…åˆ° CXL èŠ‚ç‚¹ï¼ˆæ–‡ä»¶ç¼“å­˜å¤šä¸ºå†·é¡µï¼Œå¯¹å»¶è¿Ÿæ•æ„Ÿåº¦ä½ï¼‰ã€‚ å½“è¯¥ç­–ç•¥å¯ç”¨æ—¶ï¼Œåº”ç”¨ç”Ÿå‘½å‘¨æœŸå†…ç”Ÿæˆçš„æ–‡ä»¶ç¼“å­˜åˆå§‹åˆ†é…åˆ° CXL èŠ‚ç‚¹ï¼›è‹¥æ–‡ä»¶ç¼“å­˜å˜ä¸ºçƒ­é¡µå¹¶è¢« NUMA Balancing é‡‡æ ·åˆ°ï¼Œå†æå‡åˆ°æœ¬åœ°å†…å­˜ã€‚è¯¥ç­–ç•¥ä½¿å°å®¹é‡æœ¬åœ°å†…å­˜ + å¤§å®¹é‡ CXL å†…å­˜çš„ç³»ç»Ÿèƒ½é«˜æ•ˆæ”¯æŒæ–‡ä»¶ç¼“å­˜å¯†é›†å‹åº”ç”¨ï¼ŒåŒæ—¶ä¿æŒé«˜æ€§èƒ½ã€‚ 5.5 TPP å¯è§‚æµ‹æ€§è®¾è®¡ä¸ºè¯„ä¼° TPP æœ‰æ•ˆæ€§å¹¶æ’æŸ¥ç”Ÿäº§ç¯å¢ƒé—®é¢˜ï¼ŒTPP å¼•å…¥å¤šç»„ç»Ÿè®¡è®¡æ•°å™¨ï¼Œé€šè¿‡/proc/vmstatæ¥å£æš´éœ²ç»™ç”¨æˆ·æ€ï¼Œä¸»è¦åŒ…æ‹¬ï¼š é™çº§ç»Ÿè®¡ï¼šæˆåŠŸé™çº§çš„åŒ¿åé¡µä¸æ–‡ä»¶é¡µæ•°é‡ã€é™çº§å¤±è´¥æ¬¡æ•°åŠåŸå› ï¼› æå‡ç»Ÿè®¡ï¼šCXL èŠ‚ç‚¹é¡µé¢é‡‡æ ·æ•°ã€æå‡å°è¯•æ¬¡æ•°ã€æˆåŠŸæå‡çš„åŒ¿åé¡µä¸æ–‡ä»¶é¡µæ•°é‡ï¼› ä¹’ä¹“æ•ˆåº”è·Ÿè¸ªï¼šé€šè¿‡é¡µé¢æ ‡å¿—ä½ï¼ˆPG_demotedï¼‰æ ‡è®°é™çº§é¡µé¢ï¼Œç»Ÿè®¡é™çº§åè¢«æå‡çš„é¡µé¢æ•°é‡ï¼ˆè¯¥å€¼è¿‡é«˜è¡¨æ˜å­˜åœ¨ä¹’ä¹“æ•ˆåº”ï¼‰ï¼› æå‡å¤±è´¥åˆ†ç±»ï¼šæŒ‰å¤±è´¥åŸå› ï¼ˆæœ¬åœ°èŠ‚ç‚¹å†…å­˜ä¸è¶³ã€é¡µé¢å¼•ç”¨å¼‚å¸¸ã€ç³»ç»Ÿçº§å†…å­˜ç´§å¼ ç­‰ï¼‰ç»Ÿè®¡æå‡å¤±è´¥æ¬¡æ•°ï¼Œè¾…åŠ©å®šä½é—®é¢˜ã€‚ 6 è¯„ä¼°æœ¬èŠ‚é€šè¿‡ç”Ÿäº§ç¯å¢ƒå·¥ä½œè´Ÿè½½å¯¹ TPP è¿›è¡Œå…¨é¢è¯„ä¼°ï¼ŒéªŒè¯å…¶åœ¨ CXL åˆ†å±‚å†…å­˜ç³»ç»Ÿä¸­çš„æ€§èƒ½è¡¨ç°ï¼Œä¸»è¦å›ç­”ä¸‰ä¸ªé—®é¢˜ï¼šï¼ˆ1ï¼‰TPP åœ¨å†…å­˜å±‚é—´é¡µé¢åˆ†å¸ƒä¸æ€§èƒ½æå‡æ–¹é¢çš„æœ‰æ•ˆæ€§ï¼›ï¼ˆ2ï¼‰TPP å„ç»„ä»¶çš„è´¡çŒ®ï¼›ï¼ˆ3ï¼‰TPP ä¸ç°æœ‰ä¸»æµæ–¹æ¡ˆçš„æ€§èƒ½å¯¹æ¯”ã€‚ 6.1 å®éªŒç¯å¢ƒ ç¡¬ä»¶å¹³å°ï¼šé‡‡ç”¨æ”¯æŒ CXL 1.1 çš„é¢„ç”Ÿäº§ x86 CPUï¼Œæ­é… FPGA-based CXL å†…å­˜æ‰©å±•å¡ï¼ŒCXL å†…å­˜ä»¥æ—  CPU NUMA èŠ‚ç‚¹å½¢å¼å‘ˆç°ã€‚å½“å‰ FPGA å¡çš„å»¶è¿Ÿæ¯”ç›®æ ‡äº§å“é«˜çº¦ 250nsï¼Œç”¨äºåŠŸèƒ½éªŒè¯ï¼›ä¸»æµ x86 CPU å‚å•†ç¡®è®¤ï¼Œæœ€ç»ˆäº§å“çš„ CXL å†…å­˜è®¿é—®å»¶è¿Ÿå°†æ¥è¿‘åŒè·¯æœåŠ¡å™¨çš„è¿œç¨‹ NUMA è®¿é—®å»¶è¿Ÿã€‚ ç³»ç»Ÿé…ç½®ï¼šåŸºäºåŒè·¯æœåŠ¡å™¨æ„å»ºæ¨¡æ‹Ÿ CXL ç³»ç»Ÿï¼Œé…ç½® 1 ä¸ªå«æ´»è·ƒ CPU æ ¸å¿ƒçš„æœ¬åœ°å†…å­˜èŠ‚ç‚¹ä¸ 1 ä¸ª CXL èŠ‚ç‚¹ï¼›åŸºå‡†ç¯å¢ƒï¼ˆå…¨æœ¬åœ°å†…å­˜ï¼‰é€šè¿‡ç¦ç”¨ä¸€ä¸ª CPU æ’æ§½çš„å†…å­˜ä¸æ ¸å¿ƒï¼Œä»…ä¿ç•™å•ä¸ªæœ¬åœ°èŠ‚ç‚¹å®ç°ã€‚ å†…å­˜é…ç½®ï¼šé‡‡ç”¨ä¸¤ç§å†…å­˜å®¹é‡æ¯”ä¾‹ï¼šï¼ˆ1ï¼‰2:1ï¼ˆæœ¬åœ°å†…å­˜ï¼šCXL å†…å­˜ï¼‰ï¼šæ¨¡æ‹Ÿå½“å‰ç”Ÿäº§ç¯å¢ƒï¼Œæœ¬åœ°å†…å­˜å¯å®¹çº³å…¨éƒ¨çƒ­é¡µï¼›ï¼ˆ2ï¼‰1:4ï¼šæ¨¡æ‹Ÿå†…å­˜å—é™åœºæ™¯ï¼Œæœ¬åœ°å†…å­˜ä»…èƒ½å®¹çº³éƒ¨åˆ†çƒ­é¡µï¼Œæµ‹è¯• TPP çš„æé™æ€§èƒ½ã€‚ å·¥ä½œè´Ÿè½½ï¼šé€‰æ‹© Web1ã€Cache1ã€Cache2ã€Data Warehouse å››ç±»ç”Ÿäº§å·¥ä½œè´Ÿè½½ï¼Œè¦†ç›–ä¸åŒæœåŠ¡é¢†åŸŸï¼Œå‡å¤„ç†çœŸå®æµé‡ã€‚ å¯¹æ¯”æ–¹æ¡ˆï¼šé»˜è®¤ Linux ç³»ç»Ÿã€NUMA Balancingã€AutoTieringã€TMOï¼ˆTransparent Memory Offloadingï¼‰ã€‚ æ€§èƒ½æŒ‡æ ‡ï¼šåº”ç”¨ååé‡ï¼ˆæ ¸å¿ƒæŒ‡æ ‡ï¼‰ã€æœ¬åœ°å†…å­˜è®¿é—®å æ¯”ï¼ˆåº•å±‚æ”¯æ’‘æŒ‡æ ‡ï¼‰ï¼Œå®éªŒä¸­å‡å…³é—­ç£ç›˜äº¤æ¢ï¼Œç³»ç»Ÿå†…å­˜å……è¶³ã€‚ 6.2 TPP æœ‰æ•ˆæ€§è¯„ä¼°6.2.1 é»˜è®¤ç”Ÿäº§ç¯å¢ƒï¼ˆ2:1 é…ç½®ï¼‰ Web1ï¼šWeb1 å¯åŠ¨æ—¶éœ€åŠ è½½å¤§é‡æ–‡ä»¶åˆ°å†…å­˜ï¼Œé»˜è®¤ Linux çš„å›æ”¶é€Ÿåº¦æ¯” TPP æ…¢ 44 å€ï¼Œå¯¼è‡´æœ¬åœ°å†…å­˜å¾ˆå¿«è¢«æ–‡ä»¶ç¼“å­˜å æ»¡ï¼Œæ–°åŒ¿åé¡µè¢«åˆ†é…åˆ° CXL èŠ‚ç‚¹ä¸”æ— æ³•æå‡ã€‚é»˜è®¤ Linux çš„æœ¬åœ°å†…å­˜è®¿é—®å æ¯”ä»… 22%ï¼Œååé‡æ¯”åŸºå‡†ä½ 16.5%ã€‚TPP é€šè¿‡ä¸»åŠ¨é™çº§å†·æ–‡ä»¶é¡µï¼Œé‡Šæ”¾æœ¬åœ°å†…å­˜ç©ºé—´ï¼Œä½¿ 92% çš„åŒ¿åé¡µåˆ†é…åˆ°æœ¬åœ°å†…å­˜ï¼Œæœ¬åœ°è®¿é—®å æ¯”æå‡è‡³ 90%ï¼Œååé‡ä»…æ¯”åŸºå‡†ä½ 0.5%ï¼ˆå¦‚å›¾ 14a æ‰€ç¤ºï¼‰ã€‚ Cache1ï¼šCache1 çš„åŒ¿åé¡µä¸æ–‡ä»¶é¡µå æ¯”ç¨³å®šï¼ŒåŒ¿åé¡µåˆå§‹åˆ†é…åˆ°æœ¬åœ°å†…å­˜ã€‚é»˜è®¤ Linux ä¸­ï¼Œä»… 8% çš„çƒ­é¡µæ»ç•™ CXL èŠ‚ç‚¹ï¼Œæ€§èƒ½æ¥è¿‘åŸºå‡†ï¼ˆååé‡æŸå¤± 3%ï¼‰ï¼›TPP é€šè¿‡æå‡æ‰€æœ‰æ»ç•™çƒ­é¡µï¼Œä½¿æœ¬åœ°è®¿é—®å æ¯”è¿›ä¸€æ­¥æé«˜ï¼Œååé‡æŸå¤±é™è‡³ 0.1%ï¼ˆå¦‚å›¾ 14b æ‰€ç¤ºï¼‰ã€‚ Cache2ï¼šCache2 çš„åŒ¿åé¡µè™½å¤šåˆ†é…åˆ°æœ¬åœ°å†…å­˜ï¼Œä½†ä¸¤åˆ†é’Ÿå†…ä»… 75% çš„åŒ¿åé¡µä¸ºçƒ­é¡µã€‚TPP å¯è¯†åˆ«å¹¶é™çº§å†·åŒ¿åé¡µï¼Œé‡Šæ”¾ç©ºé—´ä»¥æå‡çƒ­æ–‡ä»¶é¡µï¼Œæœ¬åœ°è®¿é—®å æ¯”ä»é»˜è®¤ Linux çš„ 78% æå‡è‡³ 91%ï¼Œååé‡æŸå¤±ä» 2% é™è‡³ 0.4%ï¼ˆå¦‚å›¾ 14c æ‰€ç¤ºï¼‰ã€‚ Data Warehouseï¼šæ•°æ®ä»“åº“çš„æ–‡ä»¶é¡µå¤šä¸ºå†·é¡µï¼Œä»… 13 åŒ¿åé¡µä¸ºçƒ­é¡µï¼Œé»˜è®¤ Linux å·²èƒ½å°†å¤§éƒ¨åˆ†çƒ­é¡µä¿ç•™åœ¨æœ¬åœ°å†…å­˜ï¼Œå› æ­¤ TPP ä¸é»˜è®¤ Linux æ€§èƒ½æ¥è¿‘ï¼ˆååé‡æŸå¤±å‡ä¸º 0.5%-0.7%ï¼‰ã€‚ä½† TPP é€šè¿‡ä¼˜åŒ–åŒ¿åé¡µä¸æ–‡ä»¶é¡µåˆ†å¸ƒï¼Œä½¿æœ¬åœ°åŒ¿åé¡µå æ¯”ä» 67% æå‡è‡³ 94%ï¼Œæœ¬åœ°è®¿é—®å æ¯”æé«˜ 4%ï¼ˆå¦‚å›¾ 14d æ‰€ç¤ºï¼‰ã€‚ 6.2.2 å¤§è§„æ¨¡ CXL æ‰©å±•ï¼ˆ1:4 é…ç½®ï¼‰è¯¥é…ç½®æ¨¡æ‹Ÿ â€œå°æœ¬åœ°å†…å­˜ + å¤§ CXL å†…å­˜â€ çš„ä½æˆæœ¬åœºæ™¯ï¼Œä»…å¯¹ Cache æœåŠ¡è¿›è¡Œè¯„ä¼°ï¼ˆWeb ä¸æ•°æ®ä»“åº“åœ¨è¯¥é…ç½®ä¸‹ä¸å…·ç”Ÿäº§å®ç”¨æ€§ï¼Œä½† TPP ä»èƒ½ä½¿å…¶æ€§èƒ½æ¥è¿‘åŸºå‡†ï¼‰ã€‚ Cache1ï¼šé»˜è®¤ Linux ä¸­ï¼Œæ–‡ä»¶é¡µå æ®å‡ ä¹å…¨éƒ¨æœ¬åœ°å†…å­˜ï¼Œ85% çš„åŒ¿åé¡µæ»ç•™ CXL èŠ‚ç‚¹ï¼Œååé‡æ¯”åŸºå‡†ä½ 14%ã€‚TPP é€šè¿‡é«˜æ•ˆæå‡ï¼Œå°† 97% çš„ CXL åŒ¿åçƒ­é¡µï¼ˆä¸€åˆ†é’Ÿå†…è®¿é—®ï¼‰è¿ç§»åˆ°æœ¬åœ°å†…å­˜ï¼ŒåŒæ—¶é™çº§å†·æ–‡ä»¶é¡µï¼Œä½¿æœ¬åœ°è®¿é—®å æ¯”ç¨³å®šåœ¨ 85%ï¼Œååé‡æŸå¤±ä»… 0.5%ï¼ˆå¦‚å›¾ 15a æ‰€ç¤ºï¼‰ã€‚ Cache2ï¼šé»˜è®¤ Linux çš„ååé‡æŸå¤±è¾¾ 18%ï¼Œæœ¬åœ°åŒ¿åé¡µå æ¯”ä»… 14%ã€‚TPP å°† 80% çš„ CXL åŒ¿åçƒ­é¡µæå‡åˆ°æœ¬åœ°å†…å­˜ï¼Œå°½ç®¡ 41% çš„å†…å­˜è®¿é—®ä»æ¥è‡ª CXL èŠ‚ç‚¹ï¼ˆæ–‡ä»¶ç¼“å­˜ï¼‰ï¼Œä½†ååé‡æŸå¤±é™è‡³ 5%ï¼ˆå¦‚å›¾ 15b æ‰€ç¤ºï¼‰ã€‚ 6.2.3 ä¸åŒ CXL å»¶è¿Ÿä¸‹çš„ TPP è¡¨ç°ä¸ºéªŒè¯ TPP å¯¹ CXL å»¶è¿Ÿå˜åŒ–çš„é€‚åº”æ€§ï¼Œåœ¨ 2:1 é…ç½®ä¸‹ï¼Œä¸º Cache2 è®¾ç½®ä¸åŒ CXL å»¶è¿Ÿï¼ˆ220ns-300nsï¼‰ã€‚ç»“æœæ˜¾ç¤ºï¼ˆå¦‚å›¾ 16 æ‰€ç¤ºï¼‰ï¼š æ— è®º CXL å»¶è¿Ÿå¦‚ä½•ï¼ŒTPP ä»…å…è®¸ 4%-5% çš„çƒ­é¡µç•™åœ¨ CXL èŠ‚ç‚¹ï¼Œè€Œé»˜è®¤ Linux çš„ CXL çƒ­é¡µå æ¯”ä¸º 22%-25%ï¼› é»˜è®¤ Linux çš„å¹³å‡å†…å­˜è®¿é—®å»¶è¿Ÿæ¯” TPP é«˜ 7 å€ï¼Œååé‡æŸå¤±æ˜¯ TPP çš„ 2.2-2.8 å€ã€‚ è¿™è¡¨æ˜ TPP çš„çƒ­é¡µè¯†åˆ«ä¸æå‡æœºåˆ¶ä¸å— CXL å»¶è¿Ÿå˜åŒ–å½±å“ï¼Œå§‹ç»ˆèƒ½å°†çƒ­é¡µé«˜æ•ˆè¿ç§»åˆ°æœ¬åœ°å†…å­˜ã€‚ 6.3 TPP ç»„ä»¶è´¡çŒ®è¯„ä¼°ä»¥ Cache1 çš„ 1:4 é…ç½®ä¸ºä¾‹ï¼Œåˆ†æ TPP å„æ ¸å¿ƒç»„ä»¶çš„ä½œç”¨ã€‚ 6.3.1 åˆ†é… - å›æ”¶è§£è€¦çš„å½±å“è‹¥å…³é—­è¯¥ç‰¹æ€§ï¼Œæœ¬åœ°èŠ‚ç‚¹çš„å›æ”¶è§¦å‘å»¶è¿Ÿï¼Œé«˜å†…å­˜å‹åŠ›ä¸‹ï¼ŒTPP æ— æ³•åŠæ—¶ä¸ºæå‡é¡µé¢é¢„ç•™ç©ºé—´ï¼Œæ–°åˆ†é…é¡µé¢ä¹Ÿåªèƒ½è¢«åˆ†é…åˆ° CXL èŠ‚ç‚¹ï¼š åˆ†é…é€Ÿç‡ï¼šæ—  decoupling æ—¶ï¼Œæœ¬åœ°èŠ‚ç‚¹åˆ†é…é€Ÿç‡å—å›æ”¶é€Ÿç‡é™åˆ¶ï¼Œæ³¢åŠ¨è¾ƒå¤§ï¼›æœ‰ decoupling æ—¶ï¼Œæœ¬åœ°èŠ‚ç‚¹åˆ†é…é€Ÿç‡åœ¨ 95 ç™¾åˆ†ä½æå‡ 1.6 å€ï¼ˆå¦‚å›¾ 17a æ‰€ç¤ºï¼‰ï¼› æå‡é€Ÿç‡ï¼šæ—  decoupling æ—¶ï¼Œæœ¬åœ°èŠ‚ç‚¹å†…å­˜é¢‘ç¹ä¸è¶³ï¼Œæå‡å‡ ä¹åœæ»ï¼›æœ‰ decoupling æ—¶ï¼Œæå‡é€Ÿç‡ç¨³å®šåœ¨ 50KBsï¼Œå³°å€¼è¾¾ 1.2MBsï¼ˆ99 ç™¾åˆ†ä½ï¼‰ï¼Œç¡®ä¿ CXL çƒ­é¡µåŠæ—¶è¿ç§»ï¼Œååé‡æŸå¤±ä» 12% é™è‡³ 0.5%ï¼ˆå¦‚å›¾ 17b æ‰€ç¤ºï¼‰ã€‚ 6.3.2 æ´»è·ƒ LRU çƒ­é¡µè¯†åˆ«çš„å½±å“ä»…å°†æ´»è·ƒ LRU é¡µé¢ä½œä¸ºæå‡å€™é€‰ï¼Œå¯æœ‰æ•ˆå‡å°‘ä¸å¿…è¦çš„æå‡ï¼š æå‡é€Ÿç‡é™ä½ 11 å€ï¼Œé™çº§åå†æå‡çš„é¡µé¢æ•°é‡å‡å°‘ 50%ï¼› å°½ç®¡é™çº§é€Ÿç‡é™ä½ 4%ï¼Œä½†æœ¬åœ°èŠ‚ç‚¹ç©ºé—²é¡µåˆ©ç”¨ç‡æå‡ï¼Œæå‡æˆåŠŸç‡æé«˜ 48%ï¼› æœ¬åœ°å†…å­˜è®¿é—®å æ¯”æé«˜ 4%ï¼Œååé‡æå‡ 2.4%ï¼› æ€§èƒ½æ”¶æ•›æ—¶é—´ä»…å¢åŠ  5 åˆ†é’Ÿï¼Œå¯¹æ•´ä½“æ€§èƒ½å½±å“å¯å¿½ç•¥ï¼ˆå¦‚å›¾ 18 æ‰€ç¤ºï¼‰ã€‚ 6.3.3 é¡µé¢ç±»å‹æ„ŸçŸ¥åˆ†é…çš„å½±å“å¯ç”¨è¯¥ç­–ç•¥åï¼ŒWeb ä¸ Cache æœåŠ¡åœ¨å°æœ¬åœ°å†…å­˜é…ç½®ä¸‹ä»èƒ½æ¥è¿‘å…¨æœ¬åœ°æ€§èƒ½ï¼ˆå¦‚è¡¨ 2 æ‰€ç¤ºï¼‰ï¼š Web1ï¼ˆ2:1ï¼‰ï¼šæœ¬åœ°è®¿é—®å æ¯” 97%ï¼Œååé‡æŸå¤± 0.5%ï¼› Cache1ï¼ˆ1:4ï¼‰ï¼šæœ¬åœ°è®¿é—®å æ¯” 85%ï¼Œååé‡æŸå¤± 0.2%ï¼› Cache2ï¼ˆ1:4ï¼‰ï¼šæœ¬åœ°è®¿é—®å æ¯” 72%ï¼Œååé‡æŸå¤± 1.5%ã€‚ è¯¥ç­–ç•¥é€šè¿‡åˆå§‹åˆ†é…ä¼˜åŒ–ï¼Œå‡å°‘åç»­è¿ç§»å¼€é”€ï¼Œä¸ºç‰¹å®šåº”ç”¨æä¾›æ›´ä¼˜æ€§èƒ½åŸºçº¿ã€‚ 6.4 ä¸ç°æœ‰æ–¹æ¡ˆçš„æ€§èƒ½å¯¹æ¯”6.4.1 TPP vs. NUMA Balancing AutoTiering Web1ï¼ˆ2:1 é…ç½®ï¼‰ï¼š NUMA Balancingï¼šå›æ”¶é€Ÿåº¦æ¯” TPP æ…¢ 42 å€ï¼Œæå‡é€Ÿç‡æ…¢ 11 å€ï¼Œæœ¬åœ°è®¿é—®å æ¯”ä»… 20%ï¼Œååé‡æŸå¤± 17.2%ï¼Œä¸”å› å†—ä½™é‡‡æ ·ï¼ŒCPU å¼€é”€æ¯” TPP é«˜ 2%ï¼› AutoTieringï¼šè™½å›æ”¶é€Ÿåº¦è¾ƒå¿«ï¼Œä½†åˆ†é… - å›æ”¶è€¦åˆå¯¼è‡´é¢„ç•™ç¼“å­˜å¾ˆå¿«è€—å°½ï¼ŒCXL è®¿é—®å æ¯”è¾¾ 70%ï¼Œååé‡æŸå¤± 13%ï¼› TPPï¼šååé‡æŸå¤±ä»… 0.5%ï¼Œæ˜¾è‘—ä¼˜äºä¸¤ç§æ–¹æ¡ˆï¼ˆå¦‚å›¾ 19a æ‰€ç¤ºï¼‰ã€‚ Cache1ï¼ˆ1:4 é…ç½®ï¼‰ï¼š NUMA Balancingï¼šæœ¬åœ°å†…å­˜å‹åŠ›ä¸‹åœæ­¢æå‡ï¼Œæœ¬åœ°è®¿é—®å æ¯”ä»… 46%ï¼Œååé‡æŸå¤± 10%ï¼› AutoTieringï¼šæ— æ³•åœ¨ 1:4 é…ç½®ä¸‹è¿è¡Œï¼ˆé¢„çƒ­åæŸ¥è¯¢é˜¶æ®µé¢‘ç¹å´©æºƒï¼‰ï¼›åœ¨ 2:1 é…ç½®ä¸‹ï¼ŒTPP çš„æœ¬åœ°è®¿é—®å æ¯”æ¯” AutoTiering é«˜ 10%ï¼Œååé‡æå‡ 7%ï¼ˆå¦‚å›¾ 19b æ‰€ç¤ºï¼‰ã€‚ 6.4.2 TPP vs. TMOTMO é€šè¿‡ç›‘æ§åº”ç”¨èµ„æº stall æƒ…å†µï¼ŒåŸºäºå‹åŠ› stall ä¿¡æ¯ï¼ˆPSIï¼‰å°†å†·é¡µå¸è½½åˆ°äº¤æ¢ç©ºé—´ï¼Œä½†è¯¥æœºåˆ¶åœ¨ CXL ç³»ç»Ÿä¸­å­˜åœ¨å±€é™ï¼š å†…å­˜åˆ©ç”¨ç‡ï¼šTMO ä»…èƒ½åˆ©ç”¨ CXL å†…å­˜çš„ 45%ï¼ˆWeb1ï¼‰ã€61%ï¼ˆCache1ï¼‰ã€7%ï¼ˆData Warehouseï¼‰ï¼Œè€Œ TPP èƒ½åˆ©ç”¨ 83%ã€92%ã€87%ï¼› æ€§èƒ½å¼€é”€ï¼šTMO çš„äº¤æ¢æœºåˆ¶éœ€é¡µé”™è¯¯è§¦å‘é¡µé¢åŠ è½½ï¼Œå¯¼è‡´é¢‘ç¹ stallï¼Œè€Œ TPP æ— æ­¤å¼€é”€ã€‚ TPP ä¸ TMO å¯ååŒå·¥ä½œï¼šTMO é€šè¿‡äº¤æ¢é‡Šæ”¾ç³»ç»Ÿçº§å†…å­˜ï¼Œä¸º TPP çš„é¡µé¢è¿ç§»æä¾›æ›´å¤šç©ºé—´ï¼Œé™ä½è¿ç§»å¤±è´¥ç‡ã€‚ä¾‹å¦‚ï¼ŒWeb1ï¼ˆ2:1 é…ç½®ï¼‰ä¸­ï¼ŒTPP+TMO çš„è¿ç§»å¤±è´¥ç‡ä» 20 é¡µ ç§’é™è‡³ 5 é¡µ ç§’ï¼ŒCXL è®¿é—®å æ¯”ä» 3.1% é™è‡³ 2.7%ï¼ˆå¦‚è¡¨ 3 æ‰€ç¤ºï¼‰ï¼›åŒæ—¶ï¼ŒTPP å°† TMO çš„äº¤æ¢è½¬åŒ–ä¸º â€œé™çº§ - äº¤æ¢â€ ä¸¤é˜¶æ®µè¿‡ç¨‹ï¼Œå‡å°‘ TMO çš„è¿›ç¨‹ stallï¼ˆä» 70% é™è‡³ 40%ï¼‰ï¼Œå†…å­˜èŠ‚çœæå‡ 3%ï¼ˆå¦‚è¡¨ 4 æ‰€ç¤ºï¼‰ã€‚ 7 è®¨è®ºä¸æœªæ¥å·¥ä½œTPP ä¸ºç¬¬ä¸€ä»£ CXL åˆ†å±‚å†…å­˜ç³»ç»Ÿçš„ç”Ÿäº§éƒ¨ç½²æä¾›äº†å¯è¡Œæ–¹æ¡ˆï¼Œä½†éšç€æŠ€æœ¯å‘å±•ï¼Œä»æœ‰ä»¥ä¸‹æ–¹å‘å€¼å¾—æ¢ç´¢ï¼š 7.1 å¤šç§Ÿæˆ·äº‘ç¯å¢ƒçš„åˆ†å±‚å†…å­˜åœ¨å¤šç§Ÿæˆ·äº‘ç¯å¢ƒä¸­ï¼ŒTPP éœ€æ”¯æŒä¸åŒç§Ÿæˆ·å¯¹å†…å­˜å±‚çš„ç«äº‰æ€§å…±äº«ã€‚è‹¥æœ¬åœ°å†…å­˜å æ¯”é«˜ï¼Œç°æœ‰æœºåˆ¶å¯æ»¡è¶³éœ€æ±‚ï¼›ä½†å½“ç§Ÿæˆ·å…·æœ‰ä¸åŒä¼˜å…ˆçº§ä¸ QoS éœ€æ±‚æ—¶ï¼ŒTPP çš„æ— å·®åˆ«ç­–ç•¥å¯èƒ½å¯¼è‡´æ€§èƒ½æ¬¡ä¼˜ã€‚æœªæ¥éœ€åœ¨ TPP åŸºç¡€ä¸Šé›†æˆ QoS æ„ŸçŸ¥çš„å†…å­˜ç®¡ç†ï¼Œæ ¹æ®ç§Ÿæˆ·ä¼˜å…ˆçº§åˆ†é…æœ¬åœ°å†…å­˜èµ„æºï¼Œç¡®ä¿é«˜ä¼˜å…ˆçº§ç§Ÿæˆ·çš„æ€§èƒ½ä¿éšœã€‚ 7.2 é¢å‘å¸¦å®½æ‰©å±•çš„åˆ†é…ç­–ç•¥å¯¹äºå†…å­˜å¸¦å®½å¯†é›†å‹åº”ç”¨ï¼ŒCPU-DRAM å¸¦å®½å¸¸æˆä¸ºç“¶é¢ˆã€‚CXL çš„é¢å¤–å¸¦å®½å¯é€šè¿‡å°†éƒ¨åˆ†å¸¦å®½æ•æ„Ÿã€å»¶è¿Ÿä¸æ•æ„Ÿçš„é¡µé¢åˆ†é…åˆ° CXL å†…å­˜ï¼Œå®ç°å¸¦å®½æ‰©å±•ã€‚æœªæ¥éœ€ç ”ç©¶å¦‚ä½•è¯†åˆ«è¿™ç±»é¡µé¢ï¼Œç¡®å®šæœ€ä¼˜åˆ†é…æ¯”ä¾‹ï¼Œç”šè‡³æ¢ç´¢ç¡¬ä»¶æ”¯æŒä»¥æå‡è¯†åˆ«ç²¾åº¦ï¼Œå®ç° â€œå»¶è¿Ÿ - å¸¦å®½â€ åŒç»´åº¦çš„é¡µæ”¾ç½®ä¼˜åŒ–ã€‚ 7.3 ç¡¬ä»¶è¾…åŠ©çš„é¡µæ”¾ç½®ä¼˜åŒ–ç¡¬ä»¶ç‰¹æ€§å¯è¿›ä¸€æ­¥æå‡ TPP æ€§èƒ½ï¼šï¼ˆ1ï¼‰CXL ASIC ä¸Šçš„å†…å­˜ä¾§ç¼“å­˜ä¸é¢„å–å™¨ï¼Œå¯é™ä½ CXL å†…å­˜çš„æœ‰æ•ˆå»¶è¿Ÿï¼›ï¼ˆ2ï¼‰ç¡¬ä»¶æ”¯æŒçš„é¡µé¢è¿ç§»ï¼Œå¯å‡å°‘ CPU å‚ä¸çš„è¿ç§»å¼€é”€ã€‚å½“å‰ TPP çš„è¿ç§»å¸¦å®½ä¸º 4-16MBsï¼ˆ1-4K é¡µ ç§’ï¼‰ï¼Œè¿œä½äº CXL é“¾è·¯å¸¦å®½ï¼ŒCPU å¼€é”€å¯å¿½ç•¥ï¼›ä½†å¯¹äº â€œæå°æœ¬åœ°å†…å­˜ + æå¤§ CXL å†…å­˜â€ çš„æç«¯é…ç½®ï¼Œç¡¬ä»¶è¾…åŠ©è¿ç§»å°†æˆä¸ºå…³é”®ä¼˜åŒ–ç‚¹ã€‚ 8 ç›¸å…³å·¥ä½œ8.1 åˆ†å±‚å†…å­˜ç³»ç»Ÿéšç€ä½å»¶è¿Ÿé DRAM æŠ€æœ¯çš„å‘å±•ï¼Œå¼‚æ„å†…å­˜ç³»ç»Ÿæˆä¸ºç ”ç©¶çƒ­ç‚¹ï¼Œå·²æœ‰å¤§é‡å·¥ä½œæ¢ç´¢åˆ©ç”¨ NVM æ‰©å±•ä¸»å†…å­˜ã€‚CXL æŠ€æœ¯çš„å‡ºç°ï¼Œä¸ºåˆ†å±‚å†…å­˜ç³»ç»Ÿæä¾›äº†ä»‹äº DRAM ä¸ NVM ä¹‹é—´çš„ä¸­é—´å±‚ï¼Œå®ç°çµæ´»ä¸”é«˜æ€§èƒ½çš„æœåŠ¡å™¨è®¾è®¡ï¼Œä¸»æµå‚å•†å‡åœ¨æ¨è¿› CXL åˆ†å±‚å†…å­˜ç³»ç»Ÿçš„ç ”å‘ä¸éƒ¨ç½²ã€‚ 8.2 åˆ†å±‚å†…å­˜çš„é¡µæ”¾ç½®æŠ€æœ¯ç°æœ‰é¡µæ”¾ç½®æŠ€æœ¯å¯åˆ†ä¸ºä¸‰ç±»ï¼š ç¡¬ä»¶è¾…åŠ©ï¼šä¾èµ–ç‰¹å®šç¡¬ä»¶ç‰¹æ€§å®ç°é¡µçƒ­åº¦æ£€æµ‹ä¸è¿ç§»ï¼Œä½†è·¨å¹³å°å…¼å®¹æ€§å·®ï¼Œéš¾ä»¥å¤§è§„æ¨¡éƒ¨ç½²ï¼› åº”ç”¨å¼•å¯¼ï¼šéœ€åº”ç”¨ä¿®æ”¹ä»£ç æˆ–æä¾›å†…å­˜è®¿é—®ä¿¡æ¯ï¼Œå¢åŠ å¼€å‘æˆæœ¬ï¼Œæ— æ³•é€‚é…ç°æœ‰åº”ç”¨ï¼› é€æ˜é¡µæ”¾ç½®ï¼šé€šè¿‡åˆ†æç‰©ç†æˆ–è™šæ‹Ÿåœ°å€ç©ºé—´çš„è®¿é—®æ¨¡å¼è¯†åˆ«çƒ­é¡µï¼Œä½†å¸¸å›  TLB å¤±æ•ˆã€ä¸­æ–­ç­‰å¯¼è‡´é«˜å¼€é”€ã€‚ TPP ä¸ç°æœ‰é€æ˜é¡µæ”¾ç½®æŠ€æœ¯çš„æ ¸å¿ƒå·®å¼‚åœ¨äºï¼šï¼ˆ1ï¼‰å¤ç”¨ Linux ç°æœ‰ LRU æœºåˆ¶ä¸ NUMA Balancingï¼Œæ— éœ€é¢å¤–ç¡¬ä»¶æ”¯æŒï¼Œå¼€é”€ä½ï¼›ï¼ˆ2ï¼‰è§£è€¦åˆ†é…ä¸å›æ”¶é€»è¾‘ï¼Œç¡®ä¿æœ¬åœ°å†…å­˜é¢„ç•™å……è¶³ç©ºé—´ï¼›ï¼ˆ3ï¼‰ç»“åˆé¡µé¢ç±»å‹æ„ŸçŸ¥ï¼Œä¼˜åŒ–åˆå§‹åˆ†é…ä¸è¿ç§»ç­–ç•¥ã€‚ åŸºäºäº¤æ¢çš„å†…å­˜ç®¡ç†ï¼ˆå¦‚ TMOï¼‰å°† CXL å†…å­˜è§†ä¸ºäº¤æ¢ç©ºé—´ï¼Œéœ€é¡µé”™è¯¯è§¦å‘é¡µé¢åŠ è½½ï¼Œè€Œ TPP å°† CXL å†…å­˜è§†ä¸ºå¸¸è§„å†…å­˜ï¼Œæ”¯æŒç›´æ¥è®¿é—®ï¼Œé¿å…é¡µé”™è¯¯å¼€é”€ã€‚AutoTiering ç­‰æ–¹æ¡ˆè™½ä¹Ÿé‡‡ç”¨èƒŒæ™¯è¿ç§»ä¸ NUMA Balancing ä¼˜åŒ–ï¼Œä½†ç¼ºä¹åˆ†é… - å›æ”¶è§£è€¦ä¸é¡µé¢ç±»å‹æ„ŸçŸ¥ï¼Œåœ¨é«˜å‹åŠ›åœºæ™¯ä¸‹æ€§èƒ½åŠ£äº TPPã€‚ 8.3 å†…å­˜è§£èšå†…å­˜è§£èšæŠ€æœ¯å°†è¿œç¨‹ä¸»æœºçš„å†…å­˜ä½œä¸ºå…±äº«èµ„æºæ± ï¼Œä¸»è¦åŸºäº RDMA ç½‘ç»œï¼Œå»¶è¿Ÿè¿œé«˜äº CXLï¼ˆå¾®ç§’çº§ vs çº³ç§’çº§ï¼‰ï¼Œå…¶å†…å­˜ç®¡ç†æœºåˆ¶ä¸ TPP æ­£äº¤ â€”â€” å¯å°† CXL å†…å­˜ä¸è¿œç¨‹è§£èšå†…å­˜ä½œä¸ºä¸åŒå†…å­˜å±‚ï¼Œåˆ†åˆ«é€šè¿‡ TPP ä¸è§£èšç®¡ç†æ–¹æ¡ˆä¼˜åŒ–ã€‚ 9 ç»“è®ºæœ¬æ–‡é€šè¿‡è½»é‡çº§ç”¨æˆ·æ€å·¥å…· Chameleonï¼Œåˆ†ææ•°æ®ä¸­å¿ƒåº”ç”¨çš„å†…å­˜ä½¿ç”¨æ¨¡å¼ï¼Œè¯å®äº† CXL åˆ†å±‚å†…å­˜ç³»ç»Ÿçš„åº”ç”¨å‰æ™¯ã€‚åŸºäºåˆ†æç»“æœï¼Œè®¾è®¡æ“ä½œç³»ç»Ÿçº§é€æ˜é¡µæ”¾ç½®æœºåˆ¶ TPPï¼Œå®ç°çƒ­é¡µåœ¨æœ¬åœ°å†…å­˜ã€å†·é¡µåœ¨ CXL å†…å­˜çš„é«˜æ•ˆæ”¾ç½®ã€‚TPP æ— éœ€åº”ç”¨ç‰¹å®šçŸ¥è¯†ï¼Œé€šè¿‡è½»é‡çº§é™çº§ã€åˆ†é… - å›æ”¶è§£è€¦ã€ç²¾å‡†çƒ­é¡µæå‡ä¸é¡µé¢ç±»å‹æ„ŸçŸ¥ï¼Œæœ€å°åŒ–æ€§èƒ½æŸå¤±ä¸å¼€é”€ã€‚ åœ¨æ”¯æŒ CXL çš„ç”Ÿäº§æœåŠ¡å™¨é›†ç¾¤ä¸­ï¼Œé€šè¿‡å¤šç§å·¥ä½œè´Ÿè½½è¯„ä¼°è¡¨æ˜ï¼šTPP ä½¿åˆ†å±‚å†…å­˜ç³»ç»Ÿæ€§èƒ½æ¥è¿‘å…¨æœ¬åœ°å†…å­˜ï¼ˆå·®è· 1%ï¼‰ï¼Œç›¸æ¯”é»˜è®¤ Linux æå‡ 18%ï¼Œç›¸æ¯” NUMA Balancingã€AutoTiering æå‡ 5%-17%ã€‚å¤§éƒ¨åˆ† TPP ä»£ç å·²æ•´åˆåˆ° Linux å†…æ ¸ï¼Œä¸ºè¶…å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒçš„ CXL åˆ†å±‚å†…å­˜éƒ¨ç½²æä¾›å®ç”¨è§£å†³æ–¹æ¡ˆã€‚","tags":[null]},{"title":"CYY-RV64.zip","path":"/notebooks/paper/CYY-RV64.zip.html","content":"å­¦ä¹ ä¸€ä¸‹CYYå¸ˆå…„çš„å·¥ä½œï¼Œpart1 https://www.rv64.zip/ BackgroundMotivation1.ç†æƒ³çš„RISC-Væ¿å­åº”å½“åŒ…å«ä¸€ç»„æ ‡å‡†çš„æŒ‡ä»¤æ‹“å±•RVA23U64,ä½†æ˜¯ç›®å‰çš„ç”Ÿæ€ä¸‹ï¼Œä¸åŒç¡¬ä»¶æ”¯æŒçš„æ‹“å±•ä¸æ ‡å‡†å¹¶ä¸ä¸€è‡´ï¼› 2.ç¼–è¯‘å™¨å’ŒCPUæ²¡æœ‰é’ˆå¯¹æ–°æ‹“å±•è¿›è¡Œä¼˜åŒ–çš„è¯ï¼Œç›²ç›®æ‰“å¼€æ–°æ‹“å±•åè€Œä¼šå¯¼è‡´ç¨‹åºæ€§èƒ½ä¸‹é™ Existing solution1.target_clones attributes æ”¹ä»£ç ï¼Œç»´æŠ¤æˆæœ¬é«˜ é—´æ¥è°ƒç”¨å¼€é”€ï¼š When using target_clones or target_version, the compiler will use GNU IFUNC to dispatch the function call to the correct version at runtime. This introduces an overhead of an indirect function call, and also refuses some optimizations such as inlining. When compiling without -fno-plt or with -fno-pic, things will be worse since it requires 2 level call to the function (the first level is PLT call). å‰ç½®çŸ¥è¯†ï¼š PLTï¼ˆProcedure Linkage Table) PLT æ˜¯åŠ¨æ€é“¾æ¥ï¼ˆå…±äº«åº“ï¼‰ä¸­ç”¨äºå®ç° å»¶è¿Ÿç»‘å®šï¼ˆLazy Bindingï¼‰ çš„æ ¸å¿ƒç»“æ„ï¼Œè§£å†³ç¨‹åºè°ƒç”¨å…±äº«åº“å‡½æ•°æ—¶çš„è·³è½¬é—®é¢˜ã€‚ é¦–æ¬¡è°ƒç”¨å‡½æ•°æ—¶ï¼š ç¨‹åºè·³è½¬åˆ° PLT è¡¨ä¸­çš„å¯¹åº”æ¡ç›®ï¼ˆå¦‚ printf@pltï¼‰ã€‚ PLT æ¡ç›®åŒ…å«ä¸€æ¡è·³è½¬æŒ‡ä»¤ï¼Œé»˜è®¤æŒ‡å‘ åŠ¨æ€é“¾æ¥å™¨ï¼ˆ_dl_runtime_resolveï¼‰ã€‚ åŠ¨æ€é“¾æ¥å™¨è§£æå‡½æ•°çœŸå®åœ°å€ï¼Œå¹¶å›å¡«åˆ° GOTï¼ˆGlobal Offset Tableï¼‰ã€‚ åç»­è°ƒç”¨æ—¶ï¼š PLT ç›´æ¥é€šè¿‡ GOT è·³è½¬åˆ°çœŸå®å‡½æ•°åœ°å€ï¼ˆæ— éœ€å†æ¬¡è§£æï¼‰ã€‚ -fno-plt é€‰é¡¹å¯ç»•è¿‡ PLTï¼Œç›´æ¥é€šè¿‡ GOT è°ƒç”¨ IFUCNï¼ˆIndirect Functionï¼‰ è¿è¡Œæ—¶åŠ¨æ€é€‰æ‹©å‡½æ•°çš„å…·ä½“å®ç°,é€šè¿‡å‡½æ•°æŒ‡é’ˆè·³è½¬ï¼Œæ¯”ç›´æ¥è°ƒç”¨å¤šä¸€æ¬¡å¯»å€ï¼Œåœ°å€è¿è¡Œæ—¶ç¡®å®šï¼Œæ— æ³•å†…è” å®šä¹‰æ—¶é€šè¿‡ __ attribute__((ifunc(resolver)))æ ‡è®°å‡½æ•°ï¼Œæä¾›ä¸€ä¸ªè§£æå™¨å‡½æ•°ã€‚ static void* my_func_resolver() if (__builtin_cpu_supports(avx2)) return my_func_avx2; else return my_func_default;void my_func() __attribute__((ifunc(my_func_resolver))); æœ€ä½³æ¡ˆä¾‹ï¼šGLibé€šè¿‡IFUNCä¸ºmemcpyæä¾›äº†å¤šä¸ªå®ç°ã€‚ Solution1.Decoupled function clone tableâ€‹\tç›¸å½“äºå°†target_clones attributesä»å‡½æ•°å±‚æå‡åˆ°äº†æ–‡ä»¶å±‚ï¼Œä¸éœ€è¦ä¿®æ”¹æºä»£ç ã€‚patch 2.Automatic function clone table generationâ€‹\tæ ¹æ®perfç»“æœé€‰æ‹©æœ€ä½³çš„result 3.é’ˆå¯¹ç›´æ¥è°ƒç”¨æäº†ä¸€äº›ç¼–è¯‘å™¨ç«¯å’ŒCPUç«¯çš„æ”¯æŒ æœŸå¾…CYYå¸ˆå…„çš„æ­£å¼è®ºæ–‡,åç»­ç»§ç»­å­¦ä¹  Other1.è‹±è¯­è¡¨è¾¾è¯»èµ·æ¥å¥½èˆ’æœ 2.ç±»ä¼¼çš„æ–¹æ¡ˆåœ¨box64ä¹‹ç±»çš„äºŒè¿›åˆ¶ç¿»è¯‘åœºæ™¯ä¸‹ä¹Ÿå¤§æœ‰ç”¨å¤„ã€‚","tags":[null]},{"title":"ISCA`25 LIA A Single-GPU LLM Inference Acceleration with Cooperative AMX-Enabled CPU-GPU Computation and CXL Offloading","path":"/notebooks/paper/ISCA-25-LIA-A-Single-GPU-LLM-Inference-Acceleration-with-Cooperative-AMX-Enabled-CPU-GPU-Computation-and-CXL-Offloading.html","content":"Abstractâ€‹\tå•GPUçš„å†…å­˜å®¹é‡é™åˆ¶äº†å¤§æ¨¡å‹æ¨ç†ï¼Œä½¿å¾—ä½¿ç”¨æˆæœ¬é«˜æ˜‚çš„å¤šGPUéƒ¨ç½²æˆ–è€…åœ¨æ…¢é€ŸPCIEä¼ è¾“å¯¼è‡´æ€§èƒ½å—é™çš„CPU-GPUéƒ¨ç½²ååˆ†å¿…è¦ã€‚åœ¨è¿™ä¸ªå·¥ä½œä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆbenchmarkäº†æœ€æ–°çš„å¸¦æœ‰AMXçš„Intel CPUï¼ŒåŒ…æ‹¬4th SPRæ¶æ„å’Œ 6th GNRæ¶æ„çš„è‡³å¼ºå¤„ç†å™¨ï¼Œè¯æ˜çŸ©é˜µä¹˜æ³•çš„å¸¦å®½è¾¾åˆ°äº†20TFLOPSå’Œ40TFLOPSï¼Œéƒ½æ¯”å¾—ä¸Šä¸€äº›æœ€æ–°çš„GPU.\tè¿™äº›å‘ç°è§£é”äº†æ›´åŠ å¹¿æ³›çš„CPUè®¡ç®—å¸è½½ï¼Œå‡å°‘CPU-GPUä¼ è¾“ï¼Œä¸ä¹‹å‰ä»£é™…çš„CPUç›¸æ¯”ç¼“è§£äº†å¸¦å®½ç“¶é¢ˆã€‚ è¡¥å……ï¼šç®—åŠ›åˆ†æ1.TFLOPS(Trillions of Floating-Point Operations Per Second):æ¯ç§’ä¸‡äº¿æ¬¡æµ®ç‚¹æ•°è¿ç®— 20~40TFLOPSä¸ºä¸­ç­‰ç®—åŠ›æ°´å¹³ 2.ç®—åŠ›åœºæ™¯ä¸­ï¼Œæ›´å¸¸ä½¿ç”¨ååé‡(Throughput)TFLOPSè€Œéç†è®ºå³°å€¼ç®—åŠ›ï¼ŒThroughput æ›´è´´è¿‘å®é™…ä»»åŠ¡çš„æ€§èƒ½è¡¨ç°ï¼ŒThroughput ä¹Ÿæ˜¯ä¼˜åŒ– LLM æ¨ç†æ€§èƒ½çš„æ ¸å¿ƒç›®æ ‡ 3.å¸¸è§GPU ç®—åŠ›ï¼š 4090 83TFLOPS | A100 312 FLOPS åŸºäºä»¥ä¸Šå‘ç°ï¼Œæˆ‘ä»¬è®¾è®¡äº†LIAï¼Œä¸€ä¸ªå•GPUå¤§æ¨¡å‹æ¨ç†åŠ é€Ÿæ¡†æ¶ï¼ŒååŒAMXä½¿èƒ½çš„CPU-GPUè®¡ç®—ä»¥åŠCXLå¸è½½ï¼ŒLIAç³»ç»Ÿçš„å¸è½½äº†è®¡ç®—åˆ°CPUä¸Šï¼Œä¼˜åŒ–äº†å»¶è¿Ÿå’Œå¸¦å®½ã€‚è¿™ä¸ªæ¡†æ¶åŒæ ·ä»‹ç»äº†ä¸€ä¸ªå†…å­˜å¸è½½ç­–ç•¥ï¼Œè¿™ä¸ªç­–ç•¥æ— ç¼çš„é›†æˆäº†ä¾¿å®œçš„CXL-DDRå†…å­˜å¢å¼ºäº†å¸¦å®½é©±åŠ¨å‹ä»»åŠ¡çš„æ€§èƒ½è¡¨ç°ã€‚åœ¨æœ‰ä¸€å¼ H100çš„SPRç³»ç»Ÿä¸Šï¼ŒLIAå¯¹æ¯”ä¹‹å‰çš„å•GPUæ¨ç†æ¡†æ¶ï¼Œè¾¾åˆ°äº†5.1åˆ°19å€çš„å»¶è¿Ÿé™ä½ä»¥åŠ3.7åˆ°5.1å€çš„å¸¦å®½ã€‚å¹¶ä¸”ï¼ŒLIAéƒ¨ç½²äº†CXLå¸è½½ï¼Œäº§ç”Ÿäº†ä¸€ä¸ªé¢å¤–çš„1.5å€å¸¦å®½æå‡ï¼ˆå¯¹æ¯”çº¯DDRæ–¹æ¡ˆï¼‰å’Œ1.8å€çš„æœ€å¤§batch size æå‡ã€‚ 1 Introductionâ€‹\tLLMåœ¨è®¸å¤šé¢†åŸŸé‡Šæ”¾å·¨å¤§çš„æ½œåŠ›ï¼Œç„¶è€Œï¼Œè¿™ç§å‰æ‰€æœªæœ‰çš„èƒ½åŠ›ä¼´éšç€å·¨å¤§çš„èŠ±è´¹ï¼ˆæŒ‡ä¸æ–­æ‰©å¤§çš„å‚æ•°è§„æ¨¡ï¼‰ã€‚æœ€è¿‘çš„å¤§æ¨¡å‹éƒ½è®¾è®¡äº†å·¨å¤§çš„å‚æ•°é‡ï¼Œå¹¶ä¸” ä¼¼ä¹ä¸¾ä¾‹å‚æ•°ä¸Šé™ç¨³å®šçº¿è¿˜ååˆ†é¥è¿œã€‚è¿™äº›å‚æ•°é‡çš„å¢åŠ å¼•å‘äº†ä¸€ä¸ªå·¨å¤§çš„æŠ€æœ¯æŒ‘æˆ˜ï¼šåœ¨ä¸€å¼ GPUå†…ä¿å­˜æ¨¡å‹å‚æ•°å’Œä¸­é—´å€¼ï¼ˆæ¯”å¦‚KV-cacheå’Œæ¿€æ´»å€¼ï¼‰å˜å¾—infeasibleã€‚å³ä½¿æœ€æ–°çš„GPUä¾‹å¦‚H100è¾¾åˆ°äº†94GBçš„æ¿è½½HBMå†…å­˜ï¼Œä½†æ˜¯ä¾æ—§éš¾ä»¥é¢å¯¹æ¨ç†æ—¶çš„å†…å­˜éœ€æ±‚ã€‚é’ˆå¯¹å•GPUçš„èƒ½åŠ›é™åˆ¶ï¼Œæœ€è¿‘çš„ä¸€äº›å·¥ä½œå·²ç»è½¬å‘äº†å¤šGPUéƒ¨ç½²ï¼Œè¿™åˆ©ç”¨äº†æ¨¡å‹çš„å¹¶è¡Œæ€§ã€‚ç„¶è€Œè¿™äº›æ–¹æ³•åœ¨éå¸¸æ˜‚è´µçš„ï¼ŒåŒæ—¶æ“ä½œèµ·æ¥ååˆ†å¤æ‚ã€‚ä¾‹å¦‚ï¼Œéƒ¨ç½²ä¸€ä¸ª175bilionçš„å‚æ•°çš„OPTæ¨¡å‹è‡³å°‘éœ€è¦5å¼ H100GPUï¼Œæ€»èŠ±è´¹è¶…è¿‡150000åˆ€ã€‚å› æ­¤ï¼Œé€šè¿‡å¢åŠ GPUçš„æ•°é‡æ˜¯ä¸€ç§åœ¨ä¸€äº›é«˜æ€§ä»·æ¯”çš„ç»æµåœºæ™¯ä¸­ä¸æ˜¯ä¸€ä¸ªå¯è¡Œçš„æ–¹æ¡ˆã€‚è®¸å¤šå‹ç¼©æŠ€æœ¯ï¼Œä¾‹å¦‚é‡åŒ–ã€å‰ªæã€ä»¥åŠæ¨¡å‹è’¸é¦ï¼ˆdistillation)å·²ç»è¢«æå‡ºæ¥å‡è½»å¤§æ¨¡å‹å¯æ‹“å±•æ€§çš„è´Ÿæ‹…ï¼Œå°½ç®¡è¿™äº›æ–¹æ³•å‡è½»äº†å†…å­˜éœ€æ±‚ï¼Œç„¶è€Œä»–ä»¬é€šå¸¸ä»¥æŸå¤±æ¨¡å‹ç²¾åº¦ä¸ºä»£ä»·ï¼Œå¹¶ä¸”ä»ç„¶éœ€è¦å¤šGPUã€‚ä¸€ä¸ªå¯é€‰æ‹©çš„æ–¹å‘æ˜¯ç³»ç»Ÿçº§åˆ«çš„å¸è½½ï¼Œå°†æ¨¡å‹å‚æ•°å­˜å‚¨åœ¨æ›´å¤§çš„CPUå†…å­˜ä¸­ç„¶åæŒ‰éœ€ä¼ è¾“åˆ°GPUä¸­ã€‚ç„¶è€Œï¼Œè¿™äº›æ–¹æ³•é¢ä¸´ä»–è‡ªå·±çš„å†…å­˜ç“¶é¢ˆï¼ŒåŸå› æ˜¯PCIEçš„å¸¦å®½æœ‰é™ï¼ˆH100 çš„PCIEå¸¦å®½æ˜¯64GBï¼ŒPCIe5.0),è¿™è§æ»¡äº†CPU-GPUçš„ä¼ è¾“ï¼Œå¯¼è‡´äº†å¤§é‡çš„æ¨ç†å»¶è¿Ÿã€‚ â€‹\tä¸ºäº†å‡è½»å¤§é‡æ•°æ®çš„ä¼ è¾“å¼€é”€ï¼Œä¸€äº›æ–¹æ³•å·²ç»æå‡ºé€‰æ‹©ä¸€äº›å±‚åœ¨CPUä¸Šè¿›è¡Œè®¡ç®—ï¼Œç„¶è€Œï¼Œè¿™äº›CPUã€GPUååŒçš„æ¡†æ¶çš„æ•ˆç‡è¢«CPUè®¡ç®—å¸¦å®½é™åˆ¶ï¼ŒFlexGenå’ŒFastDecodeè¿™ä¸¤ä¸ªå·¥ä½œå¸è½½äº†è®¡ç®—æœ€ä¸æ•æ„Ÿçš„å­å±‚åˆ°CPUï¼Œç„¶è€ŒPowerInfoerå¸è½½å†·ç¥ç»å…ƒåˆ°CPUï¼Œè¿™æ˜¾è‘—é™ä½äº†æ¨¡å‹çš„ç²¾åº¦ã€‚é™¤äº†å¤æ‚æ€§ä»¥å¤–ï¼Œå¤§æ¨¡å‹éœ€è¦æ ¹æ®åº”ç”¨çš„éœ€æ±‚è¿è¡Œä¸åŒbatch sizeçš„æ¨ç†æ“ä½œã€‚è™šæ‹ŸåŠ©æ‰‹ã€æœç´¢å¼•æ“è¿™è¿™ç±»é¢å‘ç”¨æˆ·æ¥å£çš„è¯·æ±‚å…·æœ‰å°batch ä½å»¶è¿Ÿçš„ç‰¹ç‚¹ï¼Œå¿«é€Ÿå“åº”å½±å“äº†ç”¨æˆ·çš„ä½¿ç”¨ä½“éªŒã€‚ç›¸åï¼Œbenchmarkã€ä¿¡æ¯æå–ä¹‹ç±»çš„ä»»åŠ¡å…·æœ‰å»¶è¿Ÿä¸æ•æ„Ÿæ€§çš„ä»»åŠ¡ï¼Œå¤§batchã€é«˜å¸¦å®½æ˜¯éå¸¸é‡è¦çš„ã€‚ â€‹\tä¸ºäº†å¤„ç†è¿™äº›æŒ‘æˆ˜ï¼Œæˆ‘ä»¬æ¨å‡ºäº†LIAæ¡†æ¶ï¼Œä¸€ä¸ªå•GPUæ¨ç†åŠ é€Ÿæ¡†æ¶ï¼Œä½¿ç”¨äº†AMXå’ŒCXLæŠ€æœ¯é€‚é…äº†å°batchå’Œå¤§batchåœºæ™¯ã€‚LIAä¸»è¦æœ‰3ç‚¹è´¡çŒ®ï¼š AMXçŸ©é˜µä¹˜æ³•çš„ç»¼åˆæ€§èƒ½åˆ†æã€‚ AMXé©±åŠ¨çš„CPU-GPUååŒå¤§æ¨¡å‹æ¨ç†æ¿€ç´  ä½¿ç”¨CXLå†…å­˜æ¥æ‹“å±•å¸¦å®½ LIAä¸»è¦æœ‰ä¸¤ä¸ªç»„ä»¶ç»„æˆï¼šC1:å‰ç«¯ç®—æ³•ï¼Œå†³å®šäº†é‚£äº›å­å±‚å¸è½½åˆ°CPUï¼›C2ï¼šåç«¯æ‰§è¡Œï¼Œæ— ç¼çš„é›†æˆäº†AMX CPU ã€GPUã€‚LIAå…è®¸æ‰€æœ‰çš„å­å±‚å¸è½½åˆ°AMXä½¿èƒ½çš„CPUä¸Šã€‚ å‰ç«¯ç»„ä»¶è€ƒè™‘äº†ä¸€äº›å†å²å› ç´ æ¥å†³ç­–æœ€ä¼˜çš„å¸è½½ç­–ç•¥ï¼Œè¿™äº›å› ç´ åŒ…æ‹¬æ¯ä¸ªç»™å®šäº†batch size å’Œtoken lengthå­å±‚çš„æ¯å­—èŠ‚æ“ä½œé‡ã€CPU-GPUä¼ è¾“æ•°æ®é‡ã€CPUä¸GPUçš„è®¡ç®—ååé‡å’Œå†…å­˜å¸¦å®½ã€‚å°†è¿™äº›å˜é‡è€ƒè™‘åœ¨å†…ï¼ŒLIAæœ€å¤§åŒ–äº†èµ„æºåˆ©ç”¨ç‡ï¼Œæœ€å°åŒ–äº†ç«¯åˆ°ç«¯å»¶è¿ŸLIAåˆ©ç”¨äº†å¤§æ¨¡å‹çš„ä¸€ä¸ªç‰¹æ€§ï¼šä¹Ÿå°±æ˜¯æ¯å­—èŠ‚æ“ä½œæ¯”ä¼šéšç€æ‰¹æ¬¡å¤§å°å’Œè¾“å…¥é•¿åº¦åŠ¨æ€æ³¢åŠ¨ã€‚è¿™ä½¿å¾—åœ¨ä»¥åç³»ç»Ÿä¸­ï¼Œåˆ©ç”¨æ‰€ç»™çš„æ‰¹å¤§å°å’Œè¾“å…¥é•¿åº¦å†³å®šå¸è½½ç­–ç•¥ï¼Œèƒ½å¤Ÿå¾—åˆ°æœ€å°çš„å¸è½½å»¶è¿Ÿã€‚ åç«¯æ‹“å±•äº†IPEX(è¿™ä¸ªæ‹“å±•åŸæœ¬æ˜¯ç”¨æ¥ç»™GPUæˆ–è€…å•ä¸€çš„CPUè¿›è¡ŒåŠ é€Ÿ)æ¥æ— ç¼çš„é›†æˆCPUå’ŒGPUã€‚åç«¯æ‹“å±•åŒæ ·å¼•å…¥äº†è¿›ä¸€æ­¥å¢å¼ºGPUå†…å­˜å’ŒCPU-GPUè®¡ç®—èµ„æºçš„ä¼˜åŒ–ã€‚ ä½¿ç”¨CXLå†…å­˜æ—¶ä¸»è¦å°†æ¨¡å‹å‚æ•°å¸è½½ åˆ°CXLå†…å­˜ï¼Œè€ŒDDRå†…å­˜åˆ™å­˜å‚¨ä¸­é—´å€¼ã€‚ 2.Background2.1 LLM inference å¤§æ¨¡å‹ç”±embeddingencoding layerç»„æˆï¼ŒNä¸ªdecoder layers ,LM head(linear å’Œ softmax). decoder layersä¸»å¯¼äº†æ¨ç†æ—¶é—´å’Œå†…å­˜æ¶ˆè€— ä¸€ä¸ªdecoder layerç”±å¤šä¸ªå­å±‚ç»„æˆï¼ŒåŒ…æ‹¬çŸ©é˜µä¹˜æ³•ã€ å±‚å½’ä¸€åŒ–ã€æ®‹å·®å’Œsotfmaxã€‚ Nä¸ªdecoder æœ‰ä¸€æ ·çš„ç»“æ„ï¼Œä¸ä¸€æ ·çš„å‚æ•°ã€‚ æ¨¡å‹æ¥å—äº†è¾“å…¥tokenåºåˆ—ï¼Œç„¶åç”Ÿæˆè¾“å‡ºtokenï¼Œè€ŒååˆæŠŠæ–°è¾“å‡ºçš„tokenä½œä¸ºè¾“å…¥ï¼Œç›´åˆ°ç»“æŸã€‚ 3 Performance Bottlenecks of Offloading Frameworks for LLM Inference","tags":[null,null]},{"title":"OCP China 2024 CXL è®ºå›å­¦ä¹ ç¬”è®°","path":"/notebooks/paper/OCP-China-2024-CXL-è®ºå›å­¦ä¹ ç¬”è®°.html","content":"OCP China 2024 CXLè®ºå› å­¦ä¹ ç¬”è®°ä¼šè®®é“¾æ¥ é˜¿é‡Œäº‘ æ•°æ®ä¸­å¿ƒé«˜æ€§èƒ½Scale Up äº’è”ç³»ç»Ÿè¶‹åŠ¿ å­”é˜³ é˜¿é‡Œäº‘è¶…é«˜é€Ÿäº’è”è´Ÿè´£äºº èƒ¡æ–‡æ™® CXLéƒ¨åˆ† Scale Up äº‘çš„è§’åº¦ å…³æ³¨ä¸¤ä¸ªè®¡ç®— ï¼š é€šç”¨è®¡ç®—ã€GPUè®¡ç®— é€šç”¨è®¡ç®—ä¸Šï¼š è€ƒè™‘å¼¹æ€§åˆ†æï¼šå­˜å‚¨ä¸Š-äº‘ç›˜æŠ€æœ¯ ç½‘ç»œ-CIPUç½‘ç»œè™šæ‹ŸåŒ– å†…å­˜ä¸Š-CXL GPUä¸Šï¼šå¤§æ¨¡å‹å•æ¬¡ä»»åŠ¡ï¼Œæ•°æ®å¹¶è¡Œã€æµæ°´çº¿å¹¶è¡Œã€tensorå¹¶è¡Œã€ä¸“å®¶å¹¶è¡Œï¼Œéƒ½å…·æœ‰è¾ƒé«˜çš„å¸¦å®½è¦æ±‚ CXL æœºæŸœå†…çš„èµ„æºå¼¹æ€§å®ç°éœ€è¦æ»¡è¶³é«˜æ€§èƒ½æ¥å£ã€èµ„æºå…±äº«ã€æè‡´å¼¹æ€§ã€è½¯ä»¶ç”Ÿæ€å…¼å®¹æ€§ç­‰è¦æ±‚ã€‚CXLç‰¹æ€§ç¬¦åˆè¿™äº›è¦æ±‚ã€‚CXLå°†ä¸€è‡´æ€§è®¿é—®ä»CPUå†…éƒ¨æ‹“å±•åˆ°CPUå’Œå†…å­˜ä¹‹é—´ï¼Œå®ç°å¤šæœåŠ¡å™¨ä¹‹é—´çš„äº’è”ã€‚ CXLçš„æ¼”è¿› GIM ï¼š P2P ï¼š DSPä¸type3äº’è”ï¼Œtype3å¯ä»¥åˆ†é…ç»™DSPæˆ–è€…host HBR-PBR:ä¸æ­¢æ ‘çŠ¶ã€æ˜ŸçŠ¶ã€ç½‘ç»œçŠ¶ E3.s çƒ­æ’æ‹”ï¼Œä¾¿äºå¯æ‹“å±• JBOM å¤§å®¹é‡ PEMEM ï¼šæ”¯æŒ2.0ï¼Œæ»¡è¶³rediså®æ—¶æ€§æŒä¹…åŒ–ç­‰è¦æ±‚ åŸºäº å†…å­˜ä¸CPUå®ç°èµ„æºè§£è€¦ CXLåœ¨å°æ•°æ®ä¸Šä¼ è¾“æ€§èƒ½å¤§å¤§æé«˜ï¼› intel: CXL on Intel Xeon@ Platform èµµæ£®æ— CXL overview CXL Specification Summary","tags":[null]},{"title":"MICRO-25-LongSight ï½œCompute-Enabled Memory to Accelerate Large-Context LLMs via Sparse Attention","path":"/notebooks/paper/MICRO-25-LongSight: Compute-Enabled Memory to Accelerate Large-Context LLMs via Sparse Attention.html","content":"æ‘˜è¦åŸºäº Transformer çš„å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMsï¼‰ä¸­çš„å¤§è¾“å…¥ä¸Šä¸‹æ–‡çª—å£æœ‰åŠ©äºå‡å°‘å¹»è§‰ç°è±¡ï¼Œæé«˜è¾“å‡ºå‡†ç¡®æ€§å’Œä¸ªæ€§åŒ–ç¨‹åº¦ã€‚ç„¶è€Œï¼Œéšç€ä¸Šä¸‹æ–‡çª—å£çš„æ‰©å¤§ï¼Œæ³¨æ„åŠ›é˜¶æ®µåœ¨æ‰§è¡Œæ—¶é—´ä¸­çš„å æ¯”é€æ¸å¢åŠ ã€‚é”®å€¼ï¼ˆKVï¼‰ç¼“å­˜é€šè¿‡é¿å…é‡å¤è®¡ç®—ç¼“è§£äº†éƒ¨åˆ†æˆæœ¬ï¼Œä½† KV ç¼“å­˜æœ¬èº«å¯èƒ½å¾ˆå¿«è¶…å‡ºå½“ä»Š GPU é«˜å¸¦å®½å†…å­˜ï¼ˆHBMï¼‰çš„å®¹é‡ã€‚åœ¨æœ¬ç ”ç©¶ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº† LongSightï¼Œè¿™æ˜¯ä¸€ç§ç”¨äºåœ¨å¤§ä¸Šä¸‹æ–‡åœºæ™¯ä¸‹åŠ é€Ÿæ³¨æ„åŠ›è®¡ç®—çš„ç®—æ³• - ç¡¬ä»¶ååŒè®¾è®¡æ¡†æ¶ã€‚LongSight åˆ©ç”¨åŸæœ¬ä¸ºå¯†é›†æ£€ç´¢åŠ é€Ÿè®¾è®¡çš„è®¡ç®—ä½¿èƒ½ CXL å†…å­˜è®¾å¤‡ï¼Œå®ç° KV ç¼“å­˜å­˜å‚¨å’Œæ£€ç´¢çš„å¸è½½ã€‚å› æ­¤ï¼ŒLongSight æœ‰æ•ˆåœ°å°†æˆæœ¬ç›¸å¯¹è¾ƒä½çš„ LPDDR DRAM çš„ä»·å€¼æå‡è‡³é«˜ç«¯ HBM çš„æ°´å¹³ã€‚æˆ‘ä»¬çš„å®éªŒè¡¨æ˜ï¼Œä»…ä½¿ç”¨å•ä¸ª GPU å’Œå•ä¸ªè®¡ç®—ä½¿èƒ½ CXL å†…å­˜æ‰©å±•å™¨ï¼ŒLongSight å°±èƒ½ä¸ºæœ€å…ˆè¿›çš„ Llama æ¨¡å‹é«˜æ•ˆæ”¯æŒé«˜è¾¾ 100 ä¸‡ä¸ªä»¤ç‰Œçš„ä¸Šä¸‹æ–‡é•¿åº¦ã€‚ 1 å¼•è¨€é¢„è®­ç»ƒå¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMsï¼‰éœ€è¦è·å–æœ€æ–°ä¸”ç›¸å…³çš„ä¿¡æ¯ï¼Œä»¥å‡å°‘å¹»è§‰ç°è±¡å¹¶ç”Ÿæˆå‡†ç¡®ã€ä¸ªæ€§åŒ–çš„è¾“å‡ºã€‚è¿™äº›ä¿¡æ¯é€šå¸¸ä½œä¸ºæ¨¡å‹è¾“å…¥ä¸Šä¸‹æ–‡çš„ä¸€éƒ¨åˆ†æä¾›ã€‚äº‹å®ä¸Šï¼Œåœ¨æµ‹è¯•æ—¶æŠ€æœ¯ï¼ˆå¦‚æ€ç»´é“¾ã€å°‘æ ·æœ¬æç¤ºã€è‰ç¨¿æœ¬æç¤ºã€ReAct ç­‰ï¼‰ã€æ£€ç´¢å¢å¼ºç”Ÿæˆ ä»¥åŠè¾“å…¥æ•°æ®ï¼ˆå¦‚é•¿æ–‡æ¡£ã€ä»£ç æˆ–å¤šè½®äº¤äº’ï¼‰å¤æ‚åº¦ä¸æ–­æå‡çš„æ¨åŠ¨ä¸‹ï¼ŒLLMs æ­£è¶Šæ¥è¶Šå¤šåœ°åº”ç”¨äºéœ€è¦æ‰©å±•ä¸Šä¸‹æ–‡çª—å£çš„åœºæ™¯ä¸­ã€‚ éšç€ä¸Šä¸‹æ–‡é•¿åº¦çš„å¢åŠ ï¼Œæ¨ç†è¿‡ç¨‹çš„è®¡ç®—å’Œå†…å­˜éœ€æ±‚ä¹Ÿéšä¹‹å¢é•¿ã€‚ç‰¹åˆ«æ˜¯ï¼Œéšç€ä¸Šä¸‹æ–‡çª—å£çš„æ‰©å¤§ï¼ŒåŸºäº Transformer çš„ LLMs ä¸­çš„æ³¨æ„åŠ›é˜¶æ®µå¾€å¾€ä¼šä¸»å¯¼æ‰§è¡Œæ—¶é—´ã€‚é”®å€¼ï¼ˆKVï¼‰ç¼“å­˜é€šè¿‡ä»¥å¢åŠ å†…å­˜å‹åŠ›ä¸ºä»£ä»·é¿å…é‡å¤è®¡ç®—ï¼Œåœ¨ä¸€å®šç¨‹åº¦ä¸Šç¼“è§£äº†è¿™ä¸€é—®é¢˜ã€‚ç„¶è€Œï¼Œå¯¹äºæ›´å¤§çš„ä¸Šä¸‹æ–‡çª—å£ï¼ŒKV ç¼“å­˜çš„å¤§å°å¯èƒ½å¾ˆå¿«è¶…å‡ºå½“å‰ç¥ç»å¤„ç†å•å…ƒï¼ˆNPUsï¼‰ï¼ˆå¦‚ GPU æˆ– TPUï¼‰ä¸Šå¯ç”¨çš„é«˜å¸¦å®½å†…å­˜ï¼ˆHBMï¼‰å®¹é‡ã€‚ DReXæ˜¯ä¸€ç§æœ€æ–°çš„è®¡ç®—ä½¿èƒ½ CXL å†…å­˜æ‰©å±•å™¨ï¼Œç”¨äºåŠ é€Ÿå¯†é›†æ£€ç´¢ã€‚å¯†é›†æ£€ç´¢æ­£è¶Šæ¥è¶Šå¤šåœ°è¢«ç”¨äºå®ç°æ£€ç´¢å¢å¼ºç”Ÿæˆï¼ˆRAGï¼‰ï¼Œå…¶ä¸­å¯æ£€ç´¢é¡¹ä»¥é«˜ç»´åµŒå…¥å‘é‡çš„å½¢å¼å­˜å‚¨åœ¨å‘é‡æ•°æ®åº“ä¸­ï¼Œé€šè¿‡è®¡ç®—æŸ¥è¯¢å‘é‡ä¸åµŒå…¥å‘é‡ä¹‹é—´çš„ä½™å¼¦ç›¸ä¼¼åº¦æ¥è¯†åˆ«è¯­ä¹‰ç›¸å…³é¡¹ã€‚DReX åœ¨é«˜å®¹é‡ CXL å†…å­˜æ‰©å±•å™¨çš„ LPDDR DRAM èŠ¯ç‰‡å†…éƒ¨åŠé™„è¿‘é›†æˆäº†è½»é‡çº§åŠ é€Ÿå™¨ã€‚å®ƒè¿˜å¼•å…¥äº†ç¬¦å·ä½è¿‡æ»¤æœºåˆ¶ï¼Œæ— éœ€ä» DRAM ä¸­è·å–å®Œæ•´çš„åµŒå…¥å‘é‡å³å¯å¿«é€Ÿä¿®å‰ªæœç´¢ç©ºé—´ï¼Œä»è€Œæ˜¾è‘—æé«˜å¯†é›†æ£€ç´¢çš„æ€§èƒ½ã€‚ åœ¨æœ¬ç ”ç©¶ä¸­ï¼Œæˆ‘ä»¬æå‡ºäº† LongSightï¼Œè¿™æ˜¯ä¸€ç§ç”¨äºåœ¨å¤§ä¸Šä¸‹æ–‡æ¨ç†ä¸­åŠ é€Ÿæ³¨æ„åŠ›è®¡ç®—çš„ç®—æ³• - ç¡¬ä»¶ååŒè®¾è®¡æ¡†æ¶ã€‚åŸºäº DReX çš„åŸºç¡€ï¼ŒLongSight å°†å…¶åŠŸèƒ½æ‰©å±•åˆ°æ£€ç´¢å¢å¼ºç”Ÿæˆï¼ˆRAGï¼‰ä¹‹å¤–ï¼Œé‡æ–°åˆ©ç”¨ç›¸åŒçš„è®¡ç®—ä½¿èƒ½ CXL å†…å­˜æ‰©å±•å™¨æ¥åŠ é€ŸåŸºäº Transformer çš„ LLMs ä¸­çš„æ³¨æ„åŠ›æœºåˆ¶ã€‚å› æ­¤ï¼ŒLongSight èƒ½å¤Ÿåœ¨æé•¿çš„æ³¨æ„åŠ›ä¸Šä¸‹æ–‡ä¸‹å®ç°é«˜æ€§èƒ½ã€‚ å…·ä½“è€Œè¨€ï¼ŒLongSight ä½¿ç¥ç»å¤„ç†å•å…ƒï¼ˆNPUï¼‰èƒ½å¤Ÿé€šè¿‡ DReX ä¸­ CXL æä¾›çš„åŠ è½½ å­˜å‚¨æ¥å£å­˜å‚¨ KV ç¼“å­˜ã€‚LongSight å®ç°äº†ä¸€ç§æ··åˆå¯†é›† - ç¨€ç–æ³¨æ„åŠ›ç®—æ³•ï¼šç¥ç»å¤„ç†å•å…ƒï¼ˆNPUï¼‰åœ¨å…¶æœ¬åœ°é«˜å¸¦å®½å†…å­˜ï¼ˆHBMï¼‰ä¸­ä¿ç•™æœ€è¿‘çš„é”®å€¼ï¼ˆKVï¼‰å¯¹æ»‘åŠ¨çª—å£ï¼Œå¹¶å¯¹è¯¥çª—å£æ‰§è¡Œå¯†é›†æ³¨æ„åŠ›è®¡ç®—ï¼ŒåŒæ—¶å°†ç¨€ç–æ³¨æ„åŠ›è®¡ç®—å¸è½½åˆ° DReXã€‚å¯¹äºç¨€ç–éƒ¨åˆ†ï¼Œç¥ç»å¤„ç†å•å…ƒï¼ˆNPUï¼‰é€šè¿‡ CXL æ¥å£å‘ DReX æäº¤åŒ…å«æŸ¥è¯¢å‘é‡çš„æ³¨æ„åŠ›è¯·æ±‚ã€‚ç„¶åï¼ŒDReX é«˜æ•ˆæ£€ç´¢ä¸æŸ¥è¯¢å‘é‡ç‚¹ç§¯ç›¸ä¼¼åº¦æœ€é«˜çš„å‰ k ä¸ªé”®ã€‚æœ€åï¼Œç¥ç»å¤„ç†å•å…ƒï¼ˆNPUï¼‰é€šè¿‡å¯¹å¯†é›†é”®å’Œç¨€ç–é”®çš„ç»„åˆé›†åº”ç”¨ softmax å‡½æ•°ï¼Œå®Œæˆæ³¨æ„åŠ›æ“ä½œã€‚ æˆ‘ä»¬çš„å®éªŒè¡¨æ˜ï¼Œé…å¤‡å•ä¸ª GPU å’Œå•ä¸ª DReX å•å…ƒçš„ LongSightï¼Œèƒ½å¤Ÿä¸ºæœ€å…ˆè¿›çš„ Llama-3 1B å’Œ 8B æ¨¡å‹é«˜æ•ˆæ”¯æŒé«˜è¾¾ 100 ä¸‡ä¸ªä»¤ç‰Œçš„ä¸Šä¸‹æ–‡é•¿åº¦ã€‚åœ¨å½“å‰ç³»ç»Ÿä¸­ï¼Œåªæœ‰ä½¿ç”¨ 2 ä¸ª H100 GPU æ‰èƒ½æ”¯æŒå¦‚æ­¤é•¿çš„ä¸Šä¸‹æ–‡é•¿åº¦ã€‚åœ¨å•ä¸ª GPU æ”¯æŒçš„æœ€å¤§ä¸Šä¸‹æ–‡é•¿åº¦ä¸‹ï¼ŒLongSight ä¸º Llama-3 æ¨¡å‹å®ç°äº†é«˜è¾¾ 8.1-9.6 å€çš„ååé‡æå‡ï¼Œä»¥åŠæ¯ç”¨æˆ·æ¯ç§’ 3.6-11.9 å€çš„ä»¤ç‰Œç”Ÿæˆé€Ÿåº¦æå‡ã€‚ æˆ‘ä»¬çš„ä¸»è¦è´¡çŒ®å¦‚ä¸‹ï¼š æˆ‘ä»¬è¯å®äº†å…ˆå‰çš„ç ”ç©¶å‘ç°ï¼Œå³ Transformer ä¸­çš„æ³¨æ„åŠ›ä¸»è¦å—ä¸€å°éƒ¨åˆ†å†å²ä»¤ç‰Œçš„å½±å“ï¼Œè¿™äº›ä»¤ç‰Œçš„é”®å‘é‡ä¸å½“å‰æŸ¥è¯¢å‘é‡è¡¨ç°å‡ºé«˜çš„ç‚¹ç§¯ç›¸ä¼¼åº¦ã€‚åŸºäºè¿™ä¸€è§è§£ï¼Œæˆ‘ä»¬åˆ©ç”¨å¯†é›†æ£€ç´¢åŠ é€Ÿçš„æœ€æ–°è¿›å±•ï¼Œå®ç°äº†å¤§ä¸Šä¸‹æ–‡æ³¨æ„åŠ›è®¡ç®—ã€‚ æˆ‘ä»¬æå‡ºäº†ä¸€ç§æ··åˆå¯†é›† - ç¨€ç–æ³¨æ„åŠ›ç®—æ³•ï¼Œè¯¥ç®—æ³•å°†çŸ­æœŸæ³¨æ„åŠ›çª—å£ä¿ç•™åœ¨ç¥ç»å¤„ç†å•å…ƒï¼ˆNPUï¼‰çš„é«˜å¸¦å®½å†…å­˜ï¼ˆHBMï¼‰ä¸­ï¼Œå¹¶å°†é•¿æœŸæ³¨æ„åŠ›å®ç°ä¸ºé”®å€¼å‘é‡æ•°æ®åº“ï¼Œé€šè¿‡å‰ k ç‚¹ç§¯ç›¸ä¼¼åº¦è¿›è¡Œè®¿é—®ã€‚ æˆ‘ä»¬é‡æ–°åˆ©ç”¨äº†æœ€è¿‘æå‡ºçš„è®¡ç®—ä½¿èƒ½ CXL å†…å­˜æ‰©å±•å™¨ DReXï¼ˆå…¶æœ€åˆè®¾è®¡ç”¨äºå¯†é›†æ£€ç´¢ï¼‰ï¼Œä»¥åŠ é€Ÿæˆ‘ä»¬çš„æ··åˆæ³¨æ„åŠ›æœºåˆ¶ã€‚ 2 èƒŒæ™¯2.1 åŸºäº Transformer çš„å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰å›¾ 1 å±•ç¤ºäº†æœ€å…ˆè¿›çš„å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰æ¶æ„ã€‚å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰æ¨ç†åŒ…æ‹¬é¢„å¡«å……é˜¶æ®µå’Œè§£ç é˜¶æ®µã€‚é¢„å¡«å……é˜¶æ®µä¸ºç”¨æˆ·è¾“å…¥æç¤ºæ„å»ºé”®å€¼ï¼ˆKVï¼‰ç¼“å­˜ï¼Œè€Œè§£ç é˜¶æ®µåˆ™åˆ©ç”¨é”®å€¼ï¼ˆKVï¼‰ç¼“å­˜ä»¥è‡ªå›å½’æ–¹å¼ç”Ÿæˆæ–°ä»¤ç‰Œã€‚ä¸¤ä¸ªé˜¶æ®µå…±äº«ç›¸åŒçš„æƒé‡çŸ©é˜µå’Œæ¨¡å‹æ¶æ„ï¼ŒåŒ…æ‹¬ä»¤ç‰ŒåµŒå…¥å±‚å’Œå¤šä¸ªè§£ç å™¨å±‚ã€‚æ¯ä¸ªè§£ç å™¨å±‚ä¾æ¬¡æ‰§è¡ŒæŸ¥è¯¢ - é”® - å€¼ï¼ˆQKVï¼‰ç”Ÿæˆã€å¤šå¤´æ³¨æ„åŠ›è®¡ç®—ã€è¾“å‡ºæŠ•å½±å’Œå‰é¦ˆç½‘ç»œæ“ä½œã€‚æŸ¥è¯¢ - é”® - å€¼ï¼ˆQKVï¼‰ç”Ÿæˆåˆ©ç”¨è¯¥å±‚çš„æƒé‡çŸ©é˜µï¼Œä¸ºæ¯ä¸ªè¾“å…¥ä»¤ç‰Œå¹¶è¡Œåˆ›å»ºæŸ¥è¯¢ï¼ˆQï¼‰ã€é”®ï¼ˆKï¼‰å’Œå€¼ï¼ˆVï¼‰å¼ é‡ã€‚ä¹‹åï¼ŒæŸ¥è¯¢ï¼ˆQï¼‰ã€é”®ï¼ˆKï¼‰å’Œå€¼ï¼ˆVï¼‰å¼ é‡è¢«åˆ’åˆ†ä¸ºå¤šä¸ªå¤´ï¼Œå¹¶ä¼ é€’åˆ°å¤šå¤´æ³¨æ„åŠ›å±‚ã€‚åœ¨å¤šå¤´æ³¨æ„åŠ›å±‚ä¸­ï¼Œæ¯ä¸ªå¤´è®¡ç®—æ¯ä¸ªæŸ¥è¯¢ï¼ˆQï¼‰å¼ é‡ä¸è¾“å…¥åºåˆ—ä¸­æ‰€æœ‰å…ˆå‰çš„é”®ï¼ˆKï¼‰å¼ é‡çš„æ³¨æ„åŠ›åˆ†æ•°ã€‚æ³¨æ„åŠ›åˆ†æ•°ç»è¿‡ softmax å‡½æ•°å¤„ç†åï¼Œå†ä¸ç›¸åº”çš„å€¼ï¼ˆVï¼‰å¼ é‡ç›¸ä¹˜ã€‚ä½¿ç”¨å¤šä¸ªå¤´ä½¿æ¨¡å‹èƒ½å¤Ÿå…³æ³¨ä¸åŒä½ç½®çš„ä¸åŒè¡¨ç¤ºå­ç©ºé—´çš„ä¿¡æ¯ã€‚å¤šå¤´æ³¨æ„åŠ›ä½¿ Transformer èƒ½å¤Ÿæ•è·å¤šæ ·åŒ–çš„ä¸Šä¸‹æ–‡å…³ç³» ï¼›ä¾‹å¦‚ï¼Œä¸€ä¸ªå¤´å¯èƒ½ç”¨äºç¡®å®šè¯æ€§ï¼Œè€Œå¦ä¸€ä¸ªå¤´å¯èƒ½ç”¨äºç¡®å®šæƒ…æ„Ÿã€‚å¾—åˆ°çš„å‘é‡é€šè¿‡è¾“å‡ºæŠ•å½±å±‚è¿›è¡ŒæŠ•å½±ï¼Œå¹¶é€šè¿‡æ®‹å·®è¿æ¥ä¸è¾“å…¥åµŒå…¥ç›¸åŠ ï¼Œéšåè¿›å…¥å‰é¦ˆç½‘ç»œã€‚ å›¾ 1 çš„å·¦ä¾§å’Œå³ä¾§åˆ†åˆ«å±•ç¤ºäº†é¢„å¡«å……é˜¶æ®µå’Œè§£ç é˜¶æ®µçš„è§£ç å™¨å±‚ã€‚æ— è®ºå¤„äºå“ªä¸ªé˜¶æ®µï¼ŒæŸ¥è¯¢ - é”® - å€¼ï¼ˆQKVï¼‰ç”Ÿæˆã€è¾“å‡ºæŠ•å½±å’Œå‰é¦ˆç½‘ç»œéƒ½å¯ä»¥é€šè¿‡åœ¨å¤šä¸ªç”¨æˆ·ä¹‹é—´å…±äº«æƒé‡çŸ©é˜µæ¥ä»æ‰¹å¤„ç†ä¸­å—ç›Šï¼Œä»è€Œå®ç°çŸ©é˜µ - çŸ©é˜µä¹˜æ³•ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œç”±äºæ³¨æ„åŠ›è®¡ç®—åˆ©ç”¨çš„æ˜¯ç¼–ç æ¯ä¸ªè¾“å…¥ä»¤ç‰Œä¿¡æ¯çš„æŸ¥è¯¢ï¼ˆQï¼‰ã€é”®ï¼ˆKï¼‰å’Œå€¼ï¼ˆVï¼‰å¼ é‡ï¼Œå› æ­¤ç”±äºç”¨æˆ·æç¤ºçš„å·®å¼‚ï¼Œé”®å€¼ï¼ˆKVï¼‰æ•°æ®æ— æ³•åœ¨ä¸€ä¸ªæ‰¹æ¬¡ä¸­é‡å¤ä½¿ç”¨ã€‚è¾“å…¥é•¿åº¦å› æç¤ºè€Œå¼‚ï¼šåœ¨é¢„å¡«å……é˜¶æ®µï¼Œè¾“å…¥é•¿åº¦å¯¹åº”äºå®Œæ•´çš„ç”¨æˆ·æç¤ºé•¿åº¦ï¼Œè€Œè§£ç é˜¶æ®µä»…æ¥æ”¶å•ä¸ªè¾“å…¥ä»¤ç‰Œã€‚å› æ­¤ï¼Œé¢„å¡«å……é˜¶æ®µçš„æ³¨æ„åŠ›è®¡ç®—æ¶‰åŠçŸ©é˜µ - çŸ©é˜µä¹˜æ³•ï¼Œè€Œè§£ç é˜¶æ®µåˆ™éœ€è¦å‘é‡ - çŸ©é˜µä¹˜æ³•ã€‚ æ€»ä¹‹ï¼Œé™¤äº†è§£ç é˜¶æ®µçš„æ³¨æ„åŠ›è®¡ç®—å¤–ï¼Œå¤§å¤šæ•°å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰æ“ä½œéƒ½æ˜¯çŸ©é˜µ - çŸ©é˜µä¹˜æ³•ï¼Œè¿™ä½¿å¾— GPU èƒ½å¤Ÿé«˜æ•ˆåˆ©ç”¨è®¡ç®—èµ„æºã€‚ç„¶è€Œï¼Œè§£ç é˜¶æ®µçš„æ³¨æ„åŠ›è®¡ç®—æ¶‰åŠå‘é‡ - çŸ©é˜µä¹˜æ³•ï¼Œå¯¼è‡´å¯¹å†…å­˜å¸¦å®½çš„é«˜éœ€æ±‚ï¼Œå¹¶ä½¿ GPU è®¡ç®—èµ„æºæœªå¾—åˆ°å……åˆ†åˆ©ç”¨ã€‚æ­¤å¤–ï¼Œéšç€è¾“å…¥ä¸Šä¸‹æ–‡é•¿åº¦çš„å¢åŠ ï¼Œæ³¨æ„åŠ›è®¡ç®—éœ€è¦æ›´å¤šçš„é”®ï¼ˆKï¼‰å’Œå€¼ï¼ˆVï¼‰å¼ é‡ã€‚å…ˆå‰çš„ç ”ç©¶è¡¨æ˜ï¼Œç”±äºè¿™äº›åŸå› ï¼Œè§£ç å™¨é˜¶æ®µçš„æ³¨æ„åŠ›è®¡ç®—å¯èƒ½æˆä¸ºä¸»è¦çš„æ€§èƒ½ç“¶é¢ˆï¼Œæ˜¾è‘—å½±å“ä»¤ç‰Œç”Ÿæˆååé‡ ã€‚ 2.2 åˆ†å±‚ GPU å†…å­˜ä¸ CXLè¿‘å¹´æ¥ï¼Œä»¥ GPU ä¸ºä¸­å¿ƒçš„æ¶æ„å’Œç³»ç»Ÿçš„è¿›æ­¥æ¨åŠ¨äº†åˆ†å±‚ GPU å†…å­˜çš„å‘å±•ï¼Œå°† GPU çš„å­—èŠ‚å¯å¯»å€å†…å­˜ç©ºé—´ä»æœ¬åœ°é«˜å¸¦å®½å†…å­˜ï¼ˆHBMï¼‰æ‰©å±•åˆ°åŒ…æ‹¬ä¸»æœº DDR å†…å­˜ç”šè‡³ NVMe å›ºæ€ç¡¬ç›˜ ã€‚è¿™äº›ä»¥ GPU ä¸ºä¸­å¿ƒçš„æ–¹æ³•å…è®¸ GPU æŒ‰éœ€è®¿é—®å†…å­˜æˆ–å­˜å‚¨ä¸­çš„æ•°æ®ï¼Œè€Œæ— éœ€ä¾èµ– CPU æ¥å¯åŠ¨æˆ–è§¦å‘æ­¤ç±»è®¿é—®ã€‚ åˆ†å±‚ GPU å†…å­˜çš„æœ€ç®€å•å®ç°æ˜¯å°†ä¸»æœºå†…å­˜æ˜ å°„åˆ° GPU çš„åœ°å€ç©ºé—´ï¼Œä½¿ GPU èƒ½å¤Ÿé€šè¿‡ GPU çº¿ç¨‹æ‰§è¡Œçš„åŠ è½½ å­˜å‚¨æŒ‡ä»¤è®¿é—®ä¸»æœºå†…å­˜ï¼Œæˆ–å¯åŠ¨ç›´æ¥å†…å­˜è®¿é—®ï¼ˆDMAï¼‰ä¼ è¾“ã€‚NVIDIA æœ€è¿‘æ¨å‡ºçš„å¯æ‰©å±•åŠ é€Ÿæ•°æ®è®¿é—®ï¼ˆSCADAï¼‰APIï¼Œä½¿ GPU çº¿ç¨‹èƒ½å¤Ÿè·¨åˆ†å±‚å†…å­˜å±‚æ¬¡ç»“æ„å¯¹æ— é™å¤§å°çš„æ•°æ®é›†æ‰§è¡Œå¤šç²’åº¦å’Œéšæœºè®¿é—® ã€‚ è®¡ç®—å¿«é€Ÿé“¾è·¯ï¼ˆCXLï¼‰æ˜¯ä¸€é¡¹è¡Œä¸šæ ‡å‡†ï¼Œæ—¨åœ¨æä¾›å¯¹åˆ†å¸ƒå¼å†…å­˜çš„ä½å»¶è¿Ÿã€å­—èŠ‚çº§è®¿é—®ï¼ŒåŒæ—¶æ”¯æŒä¼ ç»Ÿä¸Šé€šè¿‡ PCIe äº’è¿è¿æ¥ä¸”æ— ä¸€è‡´æ€§çš„è®¾å¤‡ä¹‹é—´çš„ç¼“å­˜ä¸€è‡´æ€§ã€‚CXL å·²è¢«è¶…å¤§è§„æ¨¡æ•°æ®ä¸­å¿ƒé‡‡ç”¨ ï¼Œå¹¶æ­£è¢«ç”¨äºæ„å»ºæœºæ¶çº§å…±äº«å†…å­˜ç³»ç»Ÿ ã€‚åœ¨æœ¬ç ”ç©¶ä¸­ï¼Œæˆ‘ä»¬é‡ç‚¹å…³æ³¨ CXL é€šè¿‡ PCIe å°†åŸºäº DDR çš„å†…å­˜ï¼ˆâ€œ3 ç±»â€ è®¾å¤‡ï¼‰è¿æ¥åˆ°å¤„ç†å™¨çš„èƒ½åŠ›ï¼Œä½¿å…¶èƒ½å¤Ÿé€šè¿‡æ ‡å‡†åŠ è½½ å­˜å‚¨æŒ‡ä»¤ç›´æ¥è®¿é—®ã€‚ 3 å¤§ä¸Šä¸‹æ–‡ç”Ÿæˆçš„æœ€æ–°æŠ€æœ¯å…ˆå‰çš„ç ”ç©¶è¡¨æ˜ï¼Œéšç€åºåˆ—é•¿åº¦çš„å¢åŠ ï¼Œå…¨æ³¨æ„åŠ›è®¡ç®—çš„æˆæœ¬ä¼šé€æ¸ä¸»å¯¼è¿è¡Œæ—¶é—´ã€‚æ€»åºåˆ—é•¿åº¦åŒ…æ‹¬è¾“å…¥ä¸Šä¸‹æ–‡çš„å¤§å°å’Œæ¨ç†è¿‡ç¨‹ä¸­ç”Ÿæˆçš„è¾“å‡ºä»¤ç‰Œæ•°é‡ã€‚è¿™ä¸¤ä¸ªç»´åº¦åœ¨ç°ä»£å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰åº”ç”¨ä¸­éƒ½å˜å¾—è¶Šæ¥è¶Šé‡è¦ã€‚éœ€è¦æ›´é•¿çš„è¾“å…¥ä¸Šä¸‹æ–‡æ¥æä¾›èƒŒæ™¯ä¿¡æ¯ï¼Œå¹¶ä½¿å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰èƒ½å¤Ÿè·å–æ–°é²œã€ç›¸å…³çš„ä¿¡æ¯ï¼Œä»¥è¿›è¡Œå‡†ç¡®å’Œæœ€æ–°çš„ç”Ÿæˆã€‚åŒæ—¶ï¼Œåœ¨éœ€è¦æ¨ç†å’Œå¤šæ­¥éª¤è§„åˆ’çš„ä»»åŠ¡ä¸­ï¼Œç”Ÿæˆæ›´é•¿çš„è¾“å‡ºåºåˆ—è‡³å…³é‡è¦ï¼Œç‰¹åˆ«æ˜¯åœ¨æ™ºèƒ½ä½“äººå·¥æ™ºèƒ½ç³»ç»Ÿä¸­ï¼Œå¦‚ OpenAI çš„ DeepResearch ï¼Œè¯¥ç³»ç»Ÿåˆ©ç”¨å¼ºåŒ–å­¦ä¹ ï¼ŒåŸºäºå…ˆå‰ç”Ÿæˆçš„ä»¤ç‰ŒæŒ‡å¯¼å¤šè½®ç”Ÿæˆå’Œæ¨ç†ã€‚è¿™äº›ç³»ç»Ÿéœ€è¦å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰èƒ½å¤ŸåŒæ—¶å…³æ³¨å¤§é‡è¾“å…¥ä»¤ç‰Œå’Œä¸æ–­å¢åŠ çš„ç”Ÿæˆè¾“å‡ºä»¤ç‰Œã€‚ éšç€æ€»ä¸Šä¸‹æ–‡é•¿åº¦çš„å¢åŠ ï¼Œæ³¨æ„åŠ›æœºåˆ¶åœ¨æµ®ç‚¹è¿ç®—æ¬¡æ•°ï¼ˆFLOPsï¼‰å’Œå†…å­˜å®¹é‡æ–¹é¢éƒ½æˆä¸ºä¸€ä¸ªæ˜¾è‘—çš„ç“¶é¢ˆã€‚æ­¤å¤–ï¼Œä¸å‰é¦ˆç½‘ç»œæˆ–å…¶ä»–å—ç›Šäºæ‰¹å¤„ç†çš„ç»„ä»¶ä¸åŒï¼Œæ³¨æ„åŠ›è®¡ç®—çš„æˆæœ¬æ— æ³•åœ¨å¤šä¸ªç”¨æˆ·ä¹‹é—´åˆ†æ‘Šã€‚éšç€æ‰¹å¤„ç†å¤§å°çš„å¢åŠ ä»¥æé«˜è®¡ç®—æ•ˆç‡ï¼Œè¿™ä¸€é™åˆ¶å˜å¾—è¶Šæ¥è¶Šçªå‡ºã€‚å› æ­¤ï¼Œè¿™äº›æŒ‘æˆ˜æ¨åŠ¨äº†éäºŒæ¬¡éƒ¨åˆ†æ³¨æ„åŠ›æœºåˆ¶ï¼ˆå³ç¨€ç–æ³¨æ„åŠ›ï¼‰çš„å‘å±•ï¼Œä»¥åŠåˆ©ç”¨å†…å­˜å†…å’Œè¿‘å†…å­˜è®¡ç®—æ¶æ„åŠ é€Ÿæ³¨æ„åŠ›æ‰§è¡Œçš„ç ”ç©¶ã€‚ 3.1 åŸºäºè½¯ä»¶çš„ç¨€ç–æ³¨æ„åŠ›é¦–å…ˆï¼Œæˆ‘ä»¬è®¨è®ºåŸºäºè½¯ä»¶çš„ç¨€ç–æ³¨æ„åŠ›æ–¹æ³•ï¼Œè¿™ç§æ–¹æ³•å·²æˆä¸ºé™ä½æ³¨æ„åŠ›è®¡ç®—æˆæœ¬çš„ä¸€ç§æµè¡Œæ‰‹æ®µã€‚Reformer [15] é€šè¿‡ä½¿ç”¨å±€éƒ¨æ•æ„Ÿå“ˆå¸Œï¼ˆLSHï¼‰è¿‡æ»¤æ‰ä¸å¤ªå¯èƒ½ç›¸å…³çš„ä¸Šä¸‹æ–‡ä»¤ç‰Œï¼Œåœ¨è½¯ä»¶ä¸­å®ç°äº†ç¨€ç–æ³¨æ„åŠ›ã€‚ç„¶åï¼Œä»…å°†ä¿ç•™çš„ä»¤ç‰Œä¼ é€’åˆ°æ³¨æ„åŠ›æœºåˆ¶ã€‚è¿™ç§æ¦‚ç‡è¿‡æ»¤é™ä½äº†åç»­æ³¨æ„åŠ›é˜¶æ®µçš„è®¡ç®—å¤æ‚åº¦ã€‚ ç„¶è€Œï¼ŒReformer çš„åŸºäºå±€éƒ¨æ•æ„Ÿå“ˆå¸Œï¼ˆLSHï¼‰çš„è¿‡æ»¤å¼•å…¥äº†å…·æœ‰çº¿æ€§æ—¶é—´å¤æ‚åº¦çš„æ¯ä»¤ç‰Œå¼€é”€ã€‚æ­¤å¤–ï¼ŒReformer æ‰§è¡Œå¤šè½®è¿‡æ»¤ï¼Œæ¯è½®è¿‡æ»¤éƒ½éœ€è¦é¢å¤–çš„å­˜å‚¨æˆ–é‡æ–°è®¡ç®—å“ˆå¸Œæ¡¶ã€‚å› æ­¤ï¼Œåœ¨é’ˆå¯¹å¯†é›†ç‚¹ç§¯è®¡ç®—è¿›è¡Œé«˜åº¦ä¼˜åŒ–çš„ç°ä»£ç¡¬ä»¶ä¸Šæ‰§è¡Œæ—¶ï¼Œç¨€ç–æ€§å¸¦æ¥çš„å¥½å¤„å¯èƒ½ä¼šè¢«è¿™äº›å¼€é”€æ‰€æŠµæ¶ˆã€‚ æ­¤å¤–ï¼ŒReformer å‡è®¾æŸ¥è¯¢å’Œé”®æ˜¯ç›¸åŒçš„ï¼Œè¿™ä½¿å¾—æ— æ³•ä½¿ç”¨é”®å€¼å¤´æ•°é‡å°‘äºæŸ¥è¯¢å¤´æ•°é‡çš„é…ç½® â€”â€” è¿™æ˜¯ä¸€ç§å¸¸ç”¨çš„æœ€æ–°æŠ€æœ¯ï¼Œç”¨äºå‡å°‘å†…å­˜å ç”¨å¹¶æé«˜æ³¨æ„åŠ›è®¡ç®—æ•ˆç‡ã€‚ Longformer [2] é‡‡ç”¨äº†ä¸åŒçš„ç¨€ç–æ³¨æ„åŠ›æ–¹æ³•ï¼Œé€šè¿‡ç»“åˆæ»‘åŠ¨çª—å£å’Œæœ‰é™çš„å…¨å±€æ³¨æ„åŠ›æ¥å®ç°éç²¾ç¡®æ³¨æ„åŠ›ã€‚æ»‘åŠ¨çª—å£æœºåˆ¶çš„ä¸€ä¸ªå…³é”®ä¼˜åŠ¿æ˜¯å…¶è®¡ç®—ç®€å•æ€§ä»¥åŠä¸å½“å‰ç¡¬ä»¶çš„å…¼å®¹æ€§ï¼Œèƒ½å¤Ÿå®ç°é«˜æ•ˆæ‰§è¡Œã€‚ ç„¶è€Œï¼Œä»…é æ»‘åŠ¨çª—å£æ³¨æ„åŠ›æœ¬èº«åœ¨æ•è·é•¿è·ç¦»ä¾èµ–å…³ç³»æ–¹é¢å­˜åœ¨å›ºæœ‰çš„å±€é™æ€§ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒLongformer é€šè¿‡ä¸€ç»„å°‘é‡çš„å…¨å±€æ³¨æ„åŠ›ä»¤ç‰Œæ¥å¢å¼ºå±€éƒ¨æ»‘åŠ¨çª—å£æ³¨æ„åŠ›ï¼Œè¿™äº›å…¨å±€æ³¨æ„åŠ›ä»¤ç‰Œå¯ä»¥å¹¿æ³›åœ°å…³æ³¨æ•´ä¸ªåºåˆ—ã€‚Longformer ä¸­çš„ç¨€ç–æ³¨æ„åŠ›æ©ç æ˜¯é¢„å®šä¹‰ä¸”é™æ€çš„ï¼Œå…è®¸æ¨¡å‹é’ˆå¯¹ç‰¹å®šä»»åŠ¡è¿›è¡Œå¾®è°ƒï¼Œä»¥å®ç°å¯å®šåˆ¶çš„æ³¨æ„åŠ›æ¨¡å¼ã€‚é€šè¿‡æ ¹æ®æ¯ä¸ªä»»åŠ¡çš„ç»“æ„å®šåˆ¶æ©ç ï¼Œè¿™ç§æ–¹æ³•èƒ½å¤Ÿç›¸å¯¹äºåŸºå‡†æ¨¡å‹æé«˜ç¨€ç–æ€§ã€‚ å°½ç®¡æœ‰è¿™äº›ä¼˜ç‚¹ï¼ŒLongformer è®¾è®¡çš„ä¸€ä¸ªå…³é”®å±€é™æ€§æ˜¯ï¼Œæ³¨æ„åŠ›æ©ç å¿…é¡»é’ˆå¯¹æ¯ä¸ªä»»åŠ¡è¿›è¡Œæ‰‹åŠ¨é…ç½®ï¼Œè¿™è¢«è®¤ä¸ºæ˜¯ä¸€ä¸ªæ˜¾è‘—çš„å¯ç”¨æ€§å’Œæ³›åŒ–æ€§æŒ‘æˆ˜ [2]ã€‚ æ·±åº¦æ±‚ç´¢äººå·¥æ™ºèƒ½ï¼ˆDeepSeek AIï¼‰[44] æŠ¥å‘Šç§°ï¼Œâ€œå—çº§é€‰æ‹©å¯¹äºåœ¨ç°ä»£ GPU ä¸Šå®ç°é«˜æ•ˆè®¡ç®—è‡³å…³é‡è¦ã€‚â€ åŸºäºè¿™ä¸€è§è§£ï¼Œä»–ä»¬æå‡ºäº† NSAï¼ˆå¯åŸç”Ÿè®­ç»ƒçš„ç¨€ç–æ³¨æ„åŠ›ï¼‰ï¼Œè¯¥æ–¹æ³•å°†å—çº§ç¨€ç–æ€§ä¸å‹ç¼©å¯†é›†æ³¨æ„åŠ›å’Œæ»‘åŠ¨çª—å£æ³¨æ„åŠ›ç›¸ç»“åˆã€‚è™½ç„¶å—çº§ç¨€ç–æ€§èƒ½å¤Ÿåœ¨ GPU ç¡¬ä»¶ä¸Šé«˜æ•ˆå®ç°ï¼Œä½†ç”±äºå…¶ç²—ç²’åº¦ï¼Œå®ƒé™åˆ¶äº†å¯å®ç°çš„æ•´ä½“ç¨€ç–æ€§ã€‚æ­¤å¤–ï¼ŒNSA éœ€è¦è¿›è¡Œé•¿ä¸Šä¸‹æ–‡å¾®è°ƒæ‰èƒ½æœ‰æ•ˆæ‰§è¡Œï¼Œè¿™å¸¦æ¥äº†é¢å¤–çš„è®¡ç®—å’Œè´¢åŠ¡æˆæœ¬ã€‚ æ€»ä¹‹ï¼Œç°æœ‰çš„åŸºäºè½¯ä»¶çš„ç¨€ç–æ³¨æ„åŠ›å®ç°éš¾ä»¥åœ¨ä¸è¿›è¡Œé‡å¤§æ¨¡å‹æˆ–ä»»åŠ¡ç‰¹å®šä¿®æ”¹çš„æƒ…å†µä¸‹ï¼ŒåŒæ—¶å®ç°é«˜ç¨€ç–æ€§å’Œä½è¿‡æ»¤å¼€é”€ã€‚ 3.2 åŸºäºç¡¬ä»¶çš„æ³¨æ„åŠ›åŠ é€ŸNeuPIMs [9] å’Œ AttAcc [29] æ¢ç´¢äº†æ··åˆæ¶æ„ï¼Œå°†ä¼ ç»Ÿçš„ç¥ç»å¤„ç†å•å…ƒï¼ˆNPUsï¼‰ï¼ˆå¦‚ GPUï¼‰ä¸å†…å­˜å†…å¤„ç†ï¼ˆPIMï¼‰ç¡¬ä»¶ç›¸ç»“åˆï¼Œç”¨äºå¤§è§„æ¨¡å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰æ¨ç†ã€‚æ‰¹å¤„ç†å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰æ¨ç†å·¥ä½œè´Ÿè½½å…·æœ‰æ˜¾è‘—çš„å¼‚æ„æ€§ï¼›å› æ­¤ï¼ŒNeuPIMsAttAcc åœ¨ç¥ç»å¤„ç†å•å…ƒï¼ˆNPUï¼‰ä¸Šæ‰§è¡Œè®¡ç®—å¯†é›†å‹æµæ°´çº¿é˜¶æ®µï¼ˆå¦‚é¢„å¡«å……å’Œå‰é¦ˆç½‘ç»œï¼‰ï¼ŒåŒæ—¶å°†è§£ç é˜¶æ®µçš„å†…å­˜å¯†é›†å‹æ³¨æ„åŠ›è®¡ç®—å¸è½½åˆ°å†…å­˜å†…å¤„ç†ï¼ˆPIMï¼‰å•å…ƒã€‚ç„¶è€Œï¼Œè¿™äº›ç ”ç©¶çš„ä¸€ä¸ªå…³é”®å±€é™æ€§æ˜¯å®ƒä»¬ä½¿ç”¨å…¨å¯†é›†æ³¨æ„åŠ›ï¼Œå³ä½¿åœ¨å†…å­˜å†…å¤„ç†ï¼ˆPIMï¼‰ç¡¬ä»¶ä¸Šæ‰§è¡Œï¼Œè¿™ç§æ³¨æ„åŠ›è®¡ç®—ä»ç„¶æˆæœ¬é«˜æ˜‚ã€‚æ­¤å¤–ï¼ŒNeuPIMs ä¾èµ–äºåŒè¡Œç¼“å†²æœºåˆ¶ï¼Œè¿™å¸¦æ¥äº†é‡å¤§çš„å®ç°æŒ‘æˆ˜ï¼Œéœ€è¦å¯¹ DRAM ç”µè·¯è®¾è®¡è¿›è¡Œå¤§é‡ä¿®æ”¹ã€‚ CENT [8] é‡‡ç”¨äº†ä¸€ç§ç³»ç»Ÿçº§ã€å†…å­˜ä¸­å¿ƒçš„æ–¹æ³•ï¼Œå°†æ‰€æœ‰ Transformer æ“ä½œå¸è½½åˆ°è¿‘å†…å­˜å’Œå†…å­˜å†…è®¾å¤‡ã€‚CENT çš„ä¸€ä¸ªå…³é”®ä¼˜åŠ¿æ˜¯å®ƒåˆ©ç”¨é«˜å¸¦å®½å†…å­˜å†…å¤„ç†ï¼ˆPIMï¼‰å•å…ƒæ¥åŠ é€Ÿå†…å­˜å¯†é›†å‹è®¡ç®—ã€‚ç„¶è€Œï¼ŒCENT åœ¨å†…å­˜å†…ä¸ºæ³¨æ„åŠ›è®¡ç®—å®ç°äº† BFloat16 ä¹˜åŠ ï¼ˆMACï¼‰å•å…ƒï¼Œè¿™å¯¼è‡´äº†æ˜¾è‘—çš„é¢ç§¯å’Œèƒ½é‡å¼€é”€ã€‚æ­¤å¤–ï¼ŒCENT çš„å…¨ç³»ç»Ÿè®¾è®¡ç”¨å®šåˆ¶ç¡¬ä»¶æ›¿ä»£äº†é«˜åº¦ä¼˜åŒ–çš„ GPU æˆ–ç¥ç»å¤„ç†å•å…ƒï¼ˆNPUsï¼‰ï¼Œä»¥å¤„ç†è®¡ç®—å¯†é›†å‹ Transformer ç»„ä»¶ï¼Œä»è€Œå¢åŠ äº†æ•´ä½“ç³»ç»Ÿæˆæœ¬ã€‚ä¸ NeuPIMs ä¸€æ ·ï¼ŒCENT ä¹Ÿå®ç°äº†å¯†é›†æ³¨æ„åŠ›ï¼Œè¿™ä½¿å¾—éš¾ä»¥æ‰©å±•è¯¥æ¶æ„ä»¥æ”¯æŒé«˜æ•ˆçš„ç¨€ç–æ³¨æ„åŠ›ã€‚ DynaX [42] é‡‡ç”¨äº†ä¸åŒçš„æ–¹æ³•ï¼Œåˆ©ç”¨æŸ¥è¯¢å‘é‡ä¸­çš„ç¨€ç–æ€§ï¼Œå¹¶å¯¹æŸ¥è¯¢å’Œé”®é‡‡ç”¨ 4 ä½æˆ– 6 ä½é‡åŒ–ï¼Œä»¥é™ä½è®¡ç®—è¿‘ä¼¼æ³¨æ„åŠ›åˆ†æ•°çš„æˆæœ¬ã€‚ç„¶åï¼Œè¿™äº›è¿‘ä¼¼åˆ†æ•°è¢«ç”¨äºæ„å»ºåŸºäºå—çš„ç¨€ç–æ³¨æ„åŠ›æ©ç ã€‚DynaX é€šè¿‡å®šåˆ¶ç¡¬ä»¶è¿›ä¸€æ­¥åˆ©ç”¨è¿‡æ»¤å—å†…çš„ç»“æ„åŒ–ç¨€ç–æ€§ã€‚ç„¶è€Œï¼Œå…¶æ€§èƒ½æœ€ç»ˆå—åˆ°è¿‡æ»¤è¿‡ç¨‹ä¸­åŠ è½½é”®çš„æˆæœ¬çš„é™åˆ¶ã€‚å³ä½¿é‡‡ç”¨é‡åŒ–ï¼Œè‡³å°‘éœ€è¦åŠ è½½é”®å†…å­˜å ç”¨çš„ 14ãƒ»616â‰ˆ9.4% æ¥è¯„ä¼°æ³¨æ„åŠ›åˆ†æ•°ï¼Œè¿™å¯¹å¯å®ç°çš„åŠ é€Ÿæ¯”æ„æˆäº†é™åˆ¶ã€‚ 4 LongSightï¼šå¤§ä¸Šä¸‹æ–‡æ³¨æ„åŠ›çš„ç®—æ³• - ç³»ç»ŸååŒè®¾è®¡ä¸ºäº†å…‹æœç°æœ‰çš„åŸºäºè½¯ä»¶å’Œç¡¬ä»¶çš„å¤§ä¸Šä¸‹æ–‡æ³¨æ„åŠ›æ–¹æ³•çš„å±€é™æ€§ï¼Œæˆ‘ä»¬æå‡ºäº† LongSightã€‚LongSight å°†åŸºäº Transformer çš„å¤§å‹è¯­è¨€æ¨¡å‹ï¼ˆLLMï¼‰ä¸­çš„æ³¨æ„åŠ›ç®—æ³•ä¸ç³»ç»Ÿå’Œç¡¬ä»¶æ¶æ„è¿›è¡ŒååŒè®¾è®¡ï¼Œä»¥å®ç°ä»»æ„é•¿çš„ä¸Šä¸‹æ–‡æ³¨æ„åŠ›ï¼ŒåŒæ—¶ä¸å½±å“ç°æœ‰åŸºäº GPU çš„æœºå™¨å­¦ä¹ æ¡†æ¶çš„å¯ç»„åˆæ€§æˆ–å¯ç¼–ç¨‹æ€§ã€‚LongSight åŸºäºä»¥ä¸‹è§‚å¯Ÿç»“æœå¼•å…¥äº†ä¸€ç§ç¨€ç–æ³¨æ„åŠ›ç®—æ³•ï¼šTransformer ä¸»è¦å…³æ³¨å…ˆå‰çš„ä»¤ç‰Œï¼Œè¿™äº›ä»¤ç‰Œå¯¹åº”çš„é”®å‘é‡ä¸å½“å‰æŸ¥è¯¢å‘é‡è¡¨ç°å‡ºé«˜çš„ç‚¹ç§¯ç›¸ä¼¼åº¦ [12]ã€‚åœ¨é«˜å±‚çº§ä¸Šï¼ŒLongSight å°†é”®å€¼ï¼ˆKVï¼‰ç¼“å­˜è§†ä¸ºä¸€ä¸ªå‘é‡æ•°æ®åº“ï¼Œé€šè¿‡å‰ k ç‚¹ç§¯ç›¸ä¼¼åº¦æŸ¥è¯¢è¿›è¡Œè®¿é—®ï¼Œä»…æ£€ç´¢è¯­ä¹‰æœ€ç›¸å…³çš„é”®ï¼Œè€Œä¸æ˜¯å…³æ³¨æ•´ä¸ªé”®å€¼ï¼ˆKVï¼‰ç¼“å­˜å†å²ã€‚ ç„¶è€Œï¼Œè¿™ä¸ªå‘é‡æ•°æ®åº“åœ¨å‡ ä¸ªå…³é”®æ–¹é¢ä¸ä¼ ç»Ÿå‘é‡æ•°æ®åº“æœ‰æ˜¾è‘—å·®å¼‚ï¼š ç²’åº¦å’Œè§„æ¨¡ï¼šå®ƒä¸ºæ¯ä¸ªé”®å€¼å¤´ã€å±‚å’Œç”¨æˆ·ç»´æŠ¤ç‹¬ç«‹çš„æ•°æ®åº“ã€‚ä¾‹å¦‚ï¼Œåœ¨ Llama-3-8Bï¼ˆå…·æœ‰ 8 ä¸ªé”®å€¼å¤´å’Œ 32 ä¸ªè§£ç å™¨å±‚ï¼‰ä¸­ï¼Œæ¯ä¸ªç”¨æˆ·å¯¹åº” 256 ä¸ªç‹¬ç«‹çš„æ•°æ®åº“ã€‚éšç€ç”¨æˆ·æ•°é‡çš„å¢åŠ ï¼Œè¿™ä¸ªæ•°å­—å‘ˆçº¿æ€§å¢é•¿ã€‚ è®¿é—®é€Ÿç‡ï¼šæ•°æ®åº“çš„è®¿é—®é€Ÿç‡ä¸ºæ¯ç§’ä»¤ç‰Œæ•°ï¼ˆTPSï¼‰Ã— å±‚æ•°ï¼ˆLï¼‰Ã— æ³¨æ„åŠ›å¤´æ•°ï¼ˆHï¼‰Ã— æ‰¹å¤„ç†ç”¨æˆ·æ•°ï¼ˆUï¼‰ï¼Œå…¶ä¸­æ¯ç§’ä»¤ç‰Œæ•°ï¼ˆTPSï¼‰æ˜¯ä»¤ç‰Œç”Ÿæˆé€Ÿç‡ï¼Œå±‚æ•°ï¼ˆLï¼‰æ˜¯è§£ç å™¨å±‚æ•°ï¼Œæ³¨æ„åŠ›å¤´æ•°ï¼ˆHï¼‰æ˜¯æ³¨æ„åŠ›å¤´çš„æ•°é‡ï¼Œæ‰¹å¤„ç†ç”¨æˆ·æ•°ï¼ˆUï¼‰æ˜¯æ‰¹å¤„ç†ä¸­çš„ç”¨æˆ·æ•°é‡ã€‚å¯¹äºåœ¨ä¼˜åŒ–ç³»ç»Ÿä¸Šè¿è¡Œçš„ Llama-3-8Bï¼Œå³ä½¿æ˜¯ä¸­ç­‰æ‰¹å¤„ç†å¤§å°ï¼Œæ¯ç§’ä»¤ç‰Œæ•°ï¼ˆTPSï¼‰ä¹Ÿå¯ä»¥è¾¾åˆ°æ•°ç™¾ä¸ªä»¤ç‰Œ ç§’ï¼Œè¿™æ„å‘³ç€æ¯ç§’éœ€è¦æ‰§è¡Œæ•°åä¸‡ä¸ªå‘é‡æ•°æ®åº“æŸ¥è¯¢ã€‚ å»¶è¿Ÿæ•æ„Ÿæ€§ï¼šç”±äºåŸºäº Transformer çš„æ¨¡å‹çš„è‡ªå›å½’å’Œé¡ºåºç‰¹æ€§ï¼Œè¿™äº›å‘é‡æ•°æ®åº“è®¿é—®ä½äºä»¤ç‰Œç”Ÿæˆçš„å…³é”®è·¯å¾„ä¸Šã€‚å¯¹äºå•ç”¨æˆ·æ‰¹å¤„ç†å’Œ 32 å±‚ï¼Œæ¯ç§’ç”Ÿæˆ 100 ä¸ªä»¤ç‰Œçš„æƒ…å†µä¸‹ï¼Œæ¯ä¸ªå±‚çš„æ³¨æ„åŠ›è®¡ç®—å»¶è¿Ÿé¢„ç®—çº¦ä¸ºå‡ ç™¾å¾®ç§’ã€‚æˆ‘ä»¬å°†è¿™ä¸ªå»¶è¿Ÿé¢„ç®—ç§°ä¸ºæ³¨æ„åŠ›è¯·æ±‚çš„æœåŠ¡æ°´å¹³ç›®æ ‡ï¼ˆSLOï¼‰ã€‚ åŠ¨æ€æ›´æ–°ï¼šä¸é€šå¸¸é™æ€æˆ–å˜åŒ–ç¼“æ…¢çš„ä¼ ç»Ÿå‘é‡æ•°æ®åº“ä¸åŒï¼Œè¿™ä¸ªå‘é‡æ•°æ®åº“éœ€è¦é¢‘ç¹æ›´æ–°ã€‚åœ¨é¢„å¡«å……é˜¶æ®µï¼Œæ•´ä¸ªæ•°æ®åº“è¢«åˆå§‹åŒ–ã€‚åœ¨è§£ç é˜¶æ®µï¼Œä¸ºæ¯ä¸ªç”¨æˆ·ç”Ÿæˆçš„æ¯ä¸ªä»¤ç‰Œæ·»åŠ ä¸€ä¸ªæ–°çš„é”®å€¼å¯¹ï¼Œå¯¼è‡´é«˜æ›´æ–°é€Ÿç‡ã€‚ å½“å‰çš„æ–¹æ³•æ— æ³•æ»¡è¶³ä¸Šè¿°è¦æ±‚ã€‚ä¼ ç»Ÿå‘é‡æ•°æ®åº“é€šå¸¸ä½¿ç”¨ç©·ä¸¾æœ€è¿‘é‚»æœç´¢ï¼ˆENNSï¼‰æˆ–è¿‘ä¼¼æœ€è¿‘é‚»æœç´¢ï¼ˆANNSï¼‰æ¥æ£€ç´¢å‰ k ä¸ªæœ€ç›¸ä¼¼çš„å‘é‡ã€‚ç©·ä¸¾æœ€è¿‘é‚»æœç´¢ï¼ˆENNSï¼‰é€Ÿåº¦ææ…¢ï¼Œè¿åäº†æ³¨æ„åŠ›è¯·æ±‚çš„æœåŠ¡æ°´å¹³ç›®æ ‡ï¼ˆSLOï¼‰ã€‚å®é™…ä¸Šï¼Œå¯†é›†æ³¨æ„åŠ›ç›¸å½“äºå¯¹æ•´ä¸ªé”®å€¼ï¼ˆKVï¼‰ç¼“å­˜æ‰§è¡Œç©·ä¸¾æœ€è¿‘é‚»æœç´¢ï¼ˆENNSï¼‰ï¼Œä½¿å¾—åŸºäºç©·ä¸¾æœ€è¿‘é‚»æœç´¢ï¼ˆENNSï¼‰çš„ LongSight æ“ä½œå…·æœ‰å€’é€€æ€§ã€‚ åŸºäºèšç±»å’ŒåŸºäºå›¾çš„è¿‘ä¼¼æœ€è¿‘é‚»æœç´¢ï¼ˆANNSï¼‰è™½ç„¶é€Ÿåº¦è¾ƒå¿«ï¼Œä½†åœ¨ç´¢å¼•æ„å»ºå’Œç»´æŠ¤æ–¹é¢ä¼šäº§ç”Ÿæ˜¾è‘—å¼€é”€ã€‚æ¯æ¬¡æ·»åŠ æ–°å‘é‡æ—¶ï¼Œéƒ½å¿…é¡»æ›´æ–°ç´¢å¼• â€”â€” è¿™ä¸ªè¿‡ç¨‹æ—¢æ˜‚è´µåˆè€—æ—¶ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå…ˆå‰çš„ç ”ç©¶åªèƒ½ä½¿ç”¨è¿‘ä¼¼æœ€è¿‘é‚»æœç´¢ï¼ˆANNSï¼‰æ”¯æŒå›ºå®šçš„é•¿ä¸Šä¸‹æ–‡ [12]ã€‚ ä¸ºäº†åœ¨å¤§ä¸Šä¸‹æ–‡è§„æ¨¡ä¸‹å®ç°å‡†ç¡®ä¸”é«˜æ€§èƒ½çš„ç¨€ç–æ³¨æ„åŠ›ï¼ŒLongSight ä½¿ç¥ç»å¤„ç†å•å…ƒï¼ˆNPUï¼‰ï¼ˆå¦‚ GPUï¼‰èƒ½å¤Ÿå°†ç”¨æˆ·çš„é”®å€¼ï¼ˆKVï¼‰ç¼“å­˜å­˜å‚¨åœ¨å•ç‹¬çš„è®¡ç®—ä½¿èƒ½å†…å­˜è®¾å¤‡ä¸Šï¼Œå¹¶å°†å¤§éƒ¨åˆ†æ³¨æ„åŠ›è®¡ç®—å¸è½½åˆ°è¯¥è®¡ç®—ä½¿èƒ½å†…å­˜è®¾å¤‡ã€‚LongSight åŸºäºä¸‰ä¸ªå…³é”®æ€æƒ³æ„å»ºï¼š æ€æƒ³ 1ï¼šå¤šé˜¶æ®µå†…å­˜å†…å’Œè¿‘å†…å­˜è¿‡æ»¤ä¸æ£€ç´¢ã€‚ç¬¬ä¸€ä¸ªæ€æƒ³æ˜¯æ‘†è„±ä¾èµ–é¢„å¤„ç†ç´¢å¼•çš„ä¼ ç»Ÿè¿‘ä¼¼æœ€è¿‘é‚»æœç´¢ï¼ˆANNSï¼‰æ–¹æ³•ï¼Œè½¬è€Œé‡‡ç”¨ç”± DReX [34] å¼€åˆ›çš„åˆ†å±‚è¿‡æ»¤æœºåˆ¶ï¼Œè¯¥æœºåˆ¶é€šè¿‡å¤šä¸ªé˜¶æ®µæä¾›ç©·ä¸¾æœ€è¿‘é‚»æœç´¢ï¼ˆENNSï¼‰çš„å‡†ç¡®æ€§å’Œè¿‘ä¼¼æœ€è¿‘é‚»æœç´¢ï¼ˆANNSï¼‰çš„é€Ÿåº¦ï¼š é˜¶æ®µ 1ï¼šå†…å­˜å†…è¿‡æ»¤ã€‚æ‰€æœ‰é‡åŒ–çš„é”®å‘é‡éƒ½æ’åˆ—åœ¨ DRAM ä¸­ï¼Œä»¥ä¾¿å†…å­˜å†…å¤„ç†ï¼ˆPIMï¼‰å•å…ƒèƒ½å¤Ÿé«˜æ•ˆè®¿é—®ï¼ˆå›¾ 2b â‘¡â€™ï¼‰ã€‚å†…å­˜å†…å¤„ç†ï¼ˆPIMï¼‰å•å…ƒå¿«é€Ÿè®¡ç®—é‡åŒ–æŸ¥è¯¢å’Œé”®ä¹‹é—´çš„ç›¸ä¼¼åº¦ã€‚æˆ‘ä»¬åŸºäºé”®å‘é‡ç»´åº¦çš„å…¨ç²¾åº¦æ•°æ®è¡¨ç¤ºçš„ç¬¦å·ä½ï¼Œå¯¹é”®å‘é‡ç»´åº¦è¿›è¡Œä¸€ä½é‡åŒ–ï¼ˆç¬¬ 5 èŠ‚ï¼‰ã€‚ä½¿ç”¨å®½æ¾çš„é˜ˆå€¼æ¥è¿‡æ»¤æ‰è·ç¦»è¾ƒè¿œçš„é”®ï¼ŒåŒæ—¶ç¡®ä¿ä¸è¿‡æ»¤æ‰è¯­ä¹‰ç›¸å…³çš„é”®ã€‚è¿™æå¤§åœ°ç®€åŒ–äº†å­˜å‚¨ï¼Œå¹¶æ¶ˆé™¤äº†å¯¹å¤æ‚ç´¢å¼•çš„éœ€æ±‚ã€‚è¿™ä½¿å¾—ä½å¼€é”€ã€åŠ¨æ€è¿‡æ»¤å’Œé«˜æ›´æ–°é€Ÿç‡æˆä¸ºå¯èƒ½ã€‚æ­¤å¤–ï¼Œä¸å…¶ä»–ä»…æ”¯æŒæœ‰é™æ•°æ®ç±»å‹çš„å†…å­˜å†…å¤„ç†æ–¹æ³•ä¸åŒï¼Œå†…å­˜å†…è¿‡æ»¤ä¸ä»»ä½•æœ‰ç¬¦å·æ•°æ®ç±»å‹å…¼å®¹ã€‚ é˜¶æ®µ 2ï¼šè¿‘å†…å­˜å‰ k æ£€ç´¢ã€‚é€šè¿‡é˜¶æ®µ 1 è¿‡æ»¤çš„å‘é‡è¢«è½¬å‘åˆ°è¿‘å†…å­˜åŠ é€Ÿå™¨ï¼Œè¯¥åŠ é€Ÿå™¨æ‰§è¡Œç©·ä¸¾å…¨ç²¾åº¦ç‚¹ç§¯ç›¸ä¼¼åº¦æœç´¢ï¼Œä»¥è¯†åˆ«æœ€ç›¸å…³çš„é”®å’Œå€¼ï¼ˆå›¾ 2b â‘¢, â‘£ï¼‰ã€‚ç„¶åï¼Œå¾—åˆ°çš„å‰ k ä¸ªé›†åˆè¢«è¿”å›ç»™ GPUï¼Œç”¨äºæœ€ç»ˆçš„æ³¨æ„åŠ›è®¡ç®—ï¼ˆå›¾ 2b â‘¤ï¼‰ã€‚ æ€æƒ³ 2ï¼šåˆ©ç”¨ CXL å®ç° GPU çš„ç»†ç²’åº¦è®¿é—®ã€‚DReX å†…éƒ¨çš„è¿™ç§å¤šé˜¶æ®µå†…å­˜å†…å’Œè¿‘å†…å­˜è¿‡æ»¤æ»¡è¶³äº†é«˜å¸¦å®½ã€ä½å»¶è¿Ÿå’Œé«˜ç²¾åº¦çš„è¦æ±‚ã€‚ä¸ºäº†æ”¯æŒç»†ç²’åº¦è®¿é—®ï¼ŒDReX ä½¿ç”¨ CXL å°†å…¶å†…éƒ¨å†…å­˜å’Œå†…å­˜æ˜ å°„ IOï¼ˆMMIOï¼‰å¯„å­˜å™¨ç›´æ¥æš´éœ²åˆ° GPU åœ°å€ç©ºé—´ã€‚ç°ä»£ GPU API é€šè¿‡è¯¸å¦‚ SCADA ä¹‹ç±»çš„æœºåˆ¶æ”¯æŒè¿™ä¸€ç‚¹ï¼Œå…è®¸ GPU ä½¿ç”¨æ ‡å‡†åŠ è½½ å­˜å‚¨æŒ‡ä»¤è®¿é—®è¿œç¨‹å†…å­˜ã€‚ æ€æƒ³ 3ï¼šæ··åˆå¯†é›†å’Œç¨€ç–æ³¨æ„åŠ›ã€‚ç”±äº LongSight éœ€è¦åœ¨ç”Ÿæˆè¿‡ç¨‹ä¸­é¢‘ç¹æ›´æ–°æ¯ä¸ªå¤´ã€æ¯å±‚å’Œæ¯ä¸ªç”¨æˆ·çš„é”®å€¼ï¼ˆKVï¼‰æ•°æ®åº“ï¼Œæˆ‘ä»¬å®ç°äº†ä¸€ç§æ··åˆå¯†é›† - ç¨€ç–æ³¨æ„åŠ›ç­–ç•¥ã€‚TODO","tags":[null,null]},{"title":"OSDI'25 Tiered Memory Management Beyond Hotness","path":"/notebooks/paper/OSDI-25-Tiered-Memory-Management-Beyond-Hotness.html","content":"Tiered Memory Management Beyond Hotness Jinshu Liu Hamid Hadian Hanchen Xu Huaicheng Li Virginia Tech https://github.com/MoatLab/SoarAlto/ Virginia è¿™ä¸ªMoatLabå¯¹CXLå†…å­˜çš„ç ”ç©¶å¾ˆæ·±å…¥ï¼Œä¹‹å‰çš„Pond(ASPLOS `23)ã€Melodyï¼ˆASPLOS`25ï¼‰éƒ½å‡ºè‡ªè¿™ä¸ªå®éªŒå®¤ 1.IntroductionHot data is not always performance-critical and can reside in the slow-tier without degrading performance . Latency mitigation techniques, such as memory-level parallelism (MLP), obscure the true cost of memory accesses 1.å…ˆå‰çš„å·¥ä½œé€šè¿‡å¯å‘å¼æˆ–è€…å†…å­˜è®¿é—®æˆæœ¬é—´æ¥çš„ååº”MLPçš„å½±å“ï¼Œä½†æ˜¯ä»ç„¶ç¼ºå°‘å‡†ç¡®çš„MLPå»ºæ¨¡å’ŒæŒ‡æ ‡ã€‚ 2.ç°æœ‰çš„å†…å­˜åˆ†å±‚æ–¹æ³•å…·æœ‰éš¾ä»¥è½»é‡åŒ–å’Œä¸å‡†ç¡®çš„ç‰¹ç‚¹ã€‚å°¤å…¶æ˜¯ä¸€å¼€å§‹å…ˆæ”¾ç½®æœ¬åœ°å†…å­˜çš„æ–¹æ³•æœ¬èº«å°±æ˜¯æ¬¡ä¼˜çš„ï¼Œå¹¶ä¸”æ¿€è¿›çš„è¿ç§»ç­–ç•¥ä¼šå¯¼è‡´è¿‡åˆ†çš„è¿ç§»ã€‚ æ‰€ä»¥ä½œè€…å°±å®šä¹‰äº†ä¸€ä¸ªMLPå½±å“çš„æŒ‡æ ‡ï¼ŒAOLï¼Œå¹¶ä¸”ç”¨æ¥è¾…åŠ©æ”¾ç½®å†³ç­–å’Œè¿ç§»å†³ç­–ã€‚ Propose Amortized Offcore Latency (AOL), a novel performance metric that accurately quantifies the performance impact of memory accesses by integrating memory latency and MLP. æ”¾ç½®å†³ç­–ç­–ç•¥SOARåŸºäºAOLè¿›è¡Œæ’åºï¼Œç„¶åä»¥æ­¤å†³å®šæ”¾ç½®ã€‚ALTOä¾é AOLæ¥è¿›è¡Œé¡µé¢æå‡çš„è¿‡æ»¤ï¼Œå¯ä»¥ä¸TPPç­‰ç­–ç•¥è¿›è¡Œç»“åˆã€‚ 2.Background and MotivationMLPåæ˜ ç­‰å¾…å†…å­˜æ§åˆ¶å™¨å®ç°çš„å†…å­˜è¯·æ±‚æ•°é‡ã€‚ high-MLP access patternsï¼š array traversalsã€‚ low MLPï¼špointer-chasing with depedent requests æŠŠä¸¤ä¸ªç±»å‹çš„è®¿å­˜ä¸€èµ·è·‘ï¼Œç„¶åä¸åŒçš„åˆ†å±‚ç­–ç•¥ä¾ç…§ä¸åŒçš„ç­–ç•¥è·‘äº†æµ‹æ€§èƒ½ï¼Œå‘ç°æŠŠæ•°ç»„è®¿é—®çš„æ”¾åˆ°å¿«é€Ÿå±‚ï¼Œåè€Œä¼šä½¿æ€§èƒ½é™ä½ã€‚ 3.Memory Performance PredictionRelating Slow-tier Performance to CPU Stallsç¦»çº¿åˆ†æ Performance degradation on the slow-tier is predominantly caused by increased CPU stalls due to LLC misses, which we refer to as LLC-Stalls å¼ºè°ƒåŒºåˆ†LLC-misså’ŒLLC-Stall æ…¢é€Ÿå±‚å•æ¬¡missé€ æˆçš„å»¶è¿Ÿæ›´é•¿ï¼Œå‡è®¾ç›¸åŒçš„miss,æ…¢é€Ÿå±‚ä¹Ÿä¼šæœ‰æ›´é•¿çš„LLC-Stall. è®ºæ–‡ä¸­è®²åˆ°åŸºäºLLC-Stallæ¥é¢„æµ‹å‡é€Ÿçš„è¯¯å·®ä½äº4%ï¼Œå¼€æºä»¥åå¯ä»¥é¢„æµ‹ä¸€ä¸‹åŸºäºLLC-Missçš„ï¼ˆè€ƒè™‘é¢„å–å™¨çš„å½±å“ï¼‰ã€‚ LLC-Stalls for Performance Predictionåœ¨çº¿é¢„æµ‹ å‘ç°å¿«é€Ÿå±‚å‘ç”ŸCPUStallçš„åœ¨æ…¢é€Ÿå±‚ä¹Ÿä¼šå‘ç”Ÿã€‚ æ‰€ä»¥ç”¨P SLLCcæ¥é¢„æµ‹æ…¢é€Ÿå±‚çš„å‡é€Ÿã€‚ AOL for Accurate Predictionè¿›ä¸€æ­¥ç ”ç©¶å‘ç°ï¼ŒPåœ¨ä½MLPçš„åœºæ™¯ä¸‹å‡†ç¡®ï¼Œä½†æ˜¯åœ¨é«˜MLPçš„åœºæ™¯ä¸‹å¹¶ä¸å‡†ç¡®ã€ä¸»è¦æ˜¯å¿½ç•¥äº†MLPçš„å½±å“ï¼Œé«˜MLPä¼šå‡å°‘é•¿å»¶è¿Ÿçš„å½±å“ã€‚ éšç€å»¶è¿Ÿçš„å¢åŠ ï¼ŒMLPçš„å»¶è¿Ÿæ©ç›–å—ç›Šä¼šé™ä½ã€‚ å› æ­¤å®šä¹‰äº†AOLï¼š æŒ‡æ ‡ äº‹ä»¶ å«ä¹‰ ğ‘ ğ¿ğ¿ğ¶ CYCLE ACTIVITY.STALLS L3 MISS L3 Missæ—¶å¯¼è‡´çš„Stall c CPU_CLK_UNHALTED.THREAD éHaltä¸‹çš„æ—¶é’Ÿå‘¨æœŸæ•° A1 OFFCORE_REQUESTS_OUTSTANDING.CYCLES_WITH_DATA_RD L2 Miss åã€è¯·æ±‚å®Œæˆå‰ï¼Œè¿™äº›å†…å­˜è¯»å–è¯·æ±‚åœ¨ SQ ä¸­ç­‰å¾…çš„å‘¨æœŸæ•°æ¢è¨€ä¹‹ï¼Œæ¯ä¸ªæ—¶é’Ÿå‘¨æœŸæ£€æŸ¥æ˜¯å¦å­˜åœ¨è‡³å°‘ä¸€ä¸ªloadè¯·æ±‚ï¼Œæœ‰å°±åŠ 1 A2 OFFCORE_REQUESTS_OUTSTANDING.DEMAND_DATA_RD L2 miss åï¼Œæ¯ä¸ªå‘¨æœŸæœ‰å¤šå°‘ä¸ªæœªå®Œæˆçš„ Demand Load è¯·æ±‚åœ¨SQä¸­ç­‰å¾…ï¼Œå³ï¼šè¯·æ±‚å †ç§¯çš„æ·±åº¦å‹åŠ›ã€‚ A3 OFFCORE REQUESTS.DEMAND DATA RD L2 miss åï¼Œè¢«å‘å¾€ uncore çš„ load è¯·æ±‚çš„æ¬¡æ•°ã€‚ å»¶è¿Ÿè®¡ç®—è¿ç”¨åˆ°äº†æ’é˜Ÿè®ºä¸­çš„Little`sæ³•åˆ™:å¹³å‡åœ¨ç³»ç»Ÿä¸­çš„é¡¹æ•° L = åˆ°è¾¾ç‡ Î» Ã— å¹³å‡å“åº”æ—¶é—´ W ç»“åˆäº‹ä»¶ï¼š L æŸä¸ªæ—¶é—´æ®µå†…ï¼Œåœ¨ uncore æ­£åœ¨ç­‰å¾…å®Œæˆçš„è¯·æ±‚æ•°ï¼ˆå•ä½ï¼šä¸ªï¼‰ï¼Œå³ â€œæ¯å‘¨æœŸ outstanding çš„è¯·æ±‚æ•°â€ Î» è¯·æ±‚åˆ°è¾¾é€Ÿç‡ï¼ˆå•ä½ï¼šè¯·æ±‚å‘¨æœŸï¼‰â‰ˆ æ€»è¯·æ±‚æ•° æ€»å‘¨æœŸæ•° W æ¯ä¸ªè¯·æ±‚åœ¨ç³»ç»Ÿä¸­åœç•™çš„æ—¶é—´ï¼ˆå•ä½ï¼šå‘¨æœŸï¼‰â†’ å¹³å‡å»¶è¿Ÿ W = L / Î» = å¹³å‡ outstanding è¯·æ±‚æ•° / åˆ°è¾¾é€Ÿç‡ æ ¹æ®æ’é˜Ÿç†è®ºï¼Œè®¡ç®—å¾—1ã€‚ MLPæ˜¯å¹³å‡æ¯ä¸ªå‘¨æœŸå†…å¤šå°‘ä¸ªinflightå†…å­˜è¯·æ±‚ï¼Œè¡¡é‡å†…å­˜è®¿é—®çš„å¹¶è¡Œåº¦ã€‚ A2ä»£è¡¨æ€»çš„å †ç§¯è¯·æ±‚æ•°ï¼Œæ€»çš„å †ç§¯è¯·æ±‚æ•°ï¼ˆA2ï¼‰é™¤ä»¥æ€»çš„å †ç§¯å‘¨æœŸæ•°ï¼ˆA1),å¾—åˆ°æ¯ä¸ªå‘¨æœŸçš„å¹³å‡inflightè¯·æ±‚æ•°ã€‚ 1ã€2ä»£å…¥çš„AOLã€‚ å»¶è¿Ÿé™¤ä»¥å¹¶è¡Œè¯·æ±‚ï¼Œå¾—åˆ°äº†ä¸€ä¸ªå¹¶è¡Œè¯·æ±‚ä¸‹å•ä¸ªè¯·æ±‚çš„å»¶è¿Ÿå½±å“ã€‚ ç„¶åä½œè€…å®šä¹‰äº†å‡é€Ÿæ¨¡å‹ï¼šS P x K. k f(AOL)çš„å‡½æ•°æ˜¯ç”¨SPä¸AOLè¿›è¡Œåˆ†æï¼Œåå‘å‘ˆç°å‡ºç‰¹å®šçš„æ¸è¿›åŒæ›²çº¿ï¼Œåæ¨å‡ºäº†å…¶æ•°å­¦æ¨¡å‹ã€‚ å…³äºaå’Œbï¼Œä¸ç¡¬ä»¶ç›¸å…³è€Œä¸å·¥ä½œè´Ÿè½½æ— å…³çš„å¸¸æ•°ï¼Œä¸¤ä¸ªç‰¹å®šçš„åœºæ™¯ï¼ˆæŒ‡é’ˆè¿½è¸ªã€æ•°ç»„è®¿é—®ï¼‰èƒ½å¤Ÿæ¨å‡ºï¼ˆä¼°è®¡å¾…å®šç³»æ•°æ³•ï¼‰ åˆ†æï¼š AOLå¢åŠ æ—¶ï¼ˆMLPå‡å°æˆ–è€…Latencyå¢å¤§ï¼‰ï¼ŒKè¶‹è¿‘åˆ°ä¸Šç•Œ1ï¼ŒSæ¥è¿‘P,é¢„æµ‹ç”±LLC.stallcå†³å®šã€‚ç›¸åï¼ˆMLPå¢å¤§æˆ–è€…Latencyå‡å°‘ï¼‰ï¼ŒKè¶‹è¿‘ä¸‹ç•Œ0ï¼ŒSå‡å° æœ‰äº†é¢„æµ‹æ¨¡å‹ä»¥åï¼ŒåŸºäºæ—¶é—´åºåˆ—é¢„æµ‹äº† 4.Soar: Rank-based Static Object Allocationç°æœ‰çš„åˆæ¬¡æ”¾ç½®çš„åˆ†å±‚æ–¹æ¡ˆç›®çš„æ˜¯æœ€å¤§åŒ–åˆ©ç”¨å¿«é€Ÿå±‚å†…å­˜ã€‚ ä½œè€…å¸Œæœ›å¯»æ‰¾ä¸€ç§æ–¹æ³•æœ€åˆå°±èƒ½ç²¾å‡†æ”¾ç½®å†…å­˜ï¼Œé™ä½å†…å­˜è¿ç§»å¼€é”€ã€‚ è¯»åˆ°è¿™å¥è¯çš„æ—¶å€™è¿™éš¾å—ã€‚ã€‚ æŒ‘æˆ˜ï¼š While AOL-based prediction is effective at the workload level, it falls short for individual objects due to the semantic gap between architectural events and object-level memory accesses. å°½ç®¡AOLé¢„æµ‹åœ¨workloadçº§åˆ«èƒ½å¤Ÿè¡¨ç°å¾—å¾ˆå¥½ï¼Œä½†æ˜¯å´æ— æ³•åœ¨å•ä¸ªå˜é‡ä¸Šè¡¨ç°å¾ˆå¥½ã€‚ key insightï¼š â€‹\tdistribute CPU stalls across objects proportionally to their relative access frequencies based on the observed MLP and latencies, thereby approximating each objectâ€™s performance impact to application performance accurately. Object-Level Performance Profilingâ€‹\tPeriodically collects and processes three types of metrics: object metadata via object tracking memory accesses via PEBS-based LLC-miss sampling temporal performance via AOL-based prediction â‘ -â‘¡Object TrackingFlow é€šè¿‡LD_PRELOADçš„æ–¹å¼æ‹¦æˆªä¿®æ”¹ï¼Œè®°å½•äº”å…ƒç»„å¯¹è±¡æµ â‘¢-â‘£ç”¨PEBSè®°å½•LLC missesã€è®¿é—®æ—¶é—´æˆ³å’Œvaddr â‘¤-â‘¥åŸºäºAOLé¢„æµ‹æ€§èƒ½ â‘¦ åˆå¹¶ä¸‰ä¸ªå¯¹è±¡æµï¼ŒåŸºäºæ—¶é—´æˆ³æ¥åˆ¤æ–­åœ°å€ï¼Œæœ‰äº†è®¿é—®æ—¶é—´æˆ³ï¼Œå¯ä»¥è®¡ç®—è®¿é—®æ¬¡æ•°ä»¥åŠè®¿é—®æ¯”ä¾‹ã€‚ â‘§å°†è®¿å­˜æ¯”ä¾‹ä¸AOLå‡é€Ÿé¢„æµ‹ç»“åˆï¼Œè®¡ç®—å‡é€Ÿå¾—åˆ† å…·ä½“è®¡ç®—ç®—æ³•ï¼š æç«¯åœºæ™¯ä¸‹å¹¶è¡Œå°‘ï¼ŒMLP1ï¼Œå‡é€Ÿæ‰“åˆ†ç­‰äºæ—¶é—´æ®µå‡é€ŸP*è®¿å­˜æ¯”ä¾‹R é«˜MLPæ—¶ï¼Œç¼©å°è¯„åˆ† ä½MLPæ—¶ï¼Œæ”¾å¤§è¯„åˆ† ä½œè€…éšåè§£é‡Šäº†æ€æ ·è®¾è®¡çš„factorï¼Œä»¥åŠè®¡ç®—å•ä½å­—èŠ‚å¾—åˆ†ç­‰ã€‚ Object Allocationä¾ç„¶æ˜¯æ‰“åˆ†ä¹‹åè¿›è¡Œæ’åºï¼Œtopk æ”¾ç½®åˆ°å¿«é€Ÿå±‚ å½±å“æ’åä¸ä¸€å®šä¸è¯·æ±‚é¡ºåºç›¸åŒï¼Œå¦‚æœæ‰“åˆ†ä½çš„å…ˆåˆ°äº†ï¼Œåç»­æ‰“åˆ†é«˜çš„è¯·æ±‚åˆ°äº†ä¼šä½¿å¾—æ‰“åˆ†ä½çš„è¯·æ±‚é™çº§ã€‚ é—®é¢˜ï¼šæ˜¯ä¾æ®è°ƒç”¨æ ˆæ¥è¿›è¡Œåˆ†ç»„å¯¹å˜é‡è¿›è¡Œæ ‡è¯†çš„ï¼Œè¿™æ ·åœ¨ä¸€ä¸ªå‡½æ•°å†…éƒ¨è¿›è¡Œå†…å­˜åˆ†é…æ—¶ï¼Œå¤§å®¶è°ƒç”¨æ ˆéƒ½ç›¸åŒï¼Œè¿™æ ·å¹¶æ— æ³•åŒºåˆ†ã€‚ å…·ä½“è¦çœ‹ä»£ç å®ç°æ˜¯å¦åŒºåˆ†æ—¶ç©ºè°ƒç”¨ï¼Ÿ ç‰¹åˆ«æŒ‡å‡ºå¯ä»¥ä¸ä¸€äº›å¼‚æ„å†…å­˜æ„ŸçŸ¥çš„å†…å­˜åˆ†é…å™¨åŒæ—¶ä½¿ç”¨ï¼ˆmemkindã€Unified Memory Framework) Use Cases and Limitations1.HPCã€åœ¨çº¿æœåŠ¡è¿™ç§é•¿æ—¶é—´è®¿é—®çš„åº”ç”¨ï¼Œé™æ€åˆ†é…ä¸å†æœ€ä¼˜ 2.å‡è®¾å¯¹è±¡æ˜¯å‡åŒ€çš„ï¼Œå¯¹è±¡å†…éƒ¨çš„è®¿é—®æ¯ä¸€é¡µé¢‘ç‡éƒ½å·®ä¸å¤šã€‚ 5.Alto: AOL-based Adaptive Page Migrationsç°åœ¨æ–¹æ¡ˆçš„ä¸è¶³ï¼š 1.æŸäº›è¿ç§»æ²¡æœ‰ã€‚åªæ˜¯è¡¨é¢çƒ­ 2.è¿ç§»å¼€é”€å¾ˆå¤§ï¼Œç­–ç•¥åˆ°å•æ¬¡è¿ç§»éœ€è¦12us,è®¿é—®åˆ°è¿ç§»ä¸­çš„é¡µå¯¼è‡´CPU stall 3.CXLä¸localçš„å»¶è¿Ÿå’Œå¸¦å®½éƒ½åœ¨ç¼©å°ï¼Œè¿ç§»å¼€é”€çš„å½±å“å°±æ˜¾å¾—å¾ˆå¤§ 4.å†·é¡µä¸æ˜¯çœŸçš„å†·ã€‚ è™½ç„¶ç”¨ AOLï¼ˆAmortized Offcore Latencyï¼‰æ¥è®¾è®¡åŸºäºæ€§èƒ½æ„ŸçŸ¥çš„é¡µè¿ç§»ï¼ˆpage-level migrationï¼‰ç­–ç•¥æ˜¯å¾ˆæœ‰å‰æ™¯çš„ï¼Œä½†ç›®å‰ä»é¢ä¸´ä¸€äº›ç‹¬ç‰¹çš„æŒ‘æˆ˜ï¼Œç‰¹åˆ«æ˜¯åœ¨å¦‚ä½•ç”¨ç°æœ‰ç²—ç²’åº¦ç¡¬ä»¶æ€§èƒ½è®¡æ•°å™¨ï¼ˆperformance countersï¼‰å‡†ç¡®ä¼°ç®—å•ä¸ªå†…å­˜é¡µçš„æ€§èƒ½å½±å“æ–¹é¢ã€‚ æ–¹æ³•å¾ˆç®€å•ï¼Œå°±æ˜¯ç”¨AOLè¾…åŠ©å¹³æ—¶çš„æ–¹æ³•å†³ç­–ä¸€ä¸‹ï¼š è€Œåè®²äº†ä¸TPPã€Nomadã€NBTç­‰æ–¹æ³•çš„é›†æˆã€‚ 6.Evaluation å…³æ³¨1ï¼šCXLæ¨¡æ‹Ÿæ–¹å¼ï¼šSKX lowering the uncore frequency and disabling cores on one NUMA node å…³æ³¨2ï¼šworkloads : GAPBSã€MLã€cachingã€SPEC2017 æ‰§è¡Œè¿‡ç¨‹ä¸­çš„æ’åº ALTOæ•ˆæœã€‚ ä¸è¶³ä¸æœºä¼šï¼š1.ä»MLPçš„è§’åº¦åˆ†æï¼Œå’Œé¢„å–æœ‰å…³ç³»å—ï¼Ÿå¯¹äºé¢„å–çš„å½±å“ï¼ˆå¦‚æœè¿™ä¸ªä¸œè¥¿èƒ½é‡åŒ–ï¼Œä¹Ÿèƒ½åˆ†æå‡ºå¾ˆå¤šä¸œè¥¿ï¼‰ 2.å¹¶æ²¡æœ‰è€ƒè™‘åŒºåˆ†è¯»å†™æ¯”ä¾‹çš„å½±å“ï¼Ÿ 3.æœ¬æ–‡ä¸­ç¬¬4èŠ‚æåˆ°çš„é€šè¿‡è®¿å­˜æ¯”ä¾‹æ¥åˆ†é…å†…å­˜slowdownçš„åšæ³•æ˜¯å¦åˆç†ï¼Ÿ æ˜¯å› ä¸ºå…¶æŒ‡æ ‡æ˜¯åŸºäºperf statçš„ï¼Œå¦‚æœå…¨éƒ¨ç”¨perf recordçš„æ–¹æ³•æ˜¯å¦ä¼šæ›´åŠ ç²¾ç¡®ï¼Ÿè¿™ä¸€ç‚¹ä½œè€…æ²¡æœ‰è¯¦ç»†æè¿°ã€‚ hard 4.å…¨éƒ¨æ”¾åœ¨è¿è¡Œæ—¶è¿›è¡Œå˜é‡åˆ†æä¼šä¸ä¼šå‘ç”Ÿé‡‡æ ·ä¸å‡†ç¡®çš„é—®é¢˜ï¼Œåœ¨NeoMemä¸­ä¹Ÿæœ‰ï¼Ÿä½†æ˜¯å¦‚ä½•è§£å†³ï¼Ÿå¯ä¸å¯ä»¥ç»“åˆNeoMemå®Œå…¨æ•è·æ•°æ®æµï¼Ÿ åŸºäºé‡‡æ ·ï¼Œé•¿ç”Ÿå‘½å‘¨æœŸçš„å¯èƒ½é‡‡é›†åˆ°ï¼ŒçŸ­ç”Ÿå‘½å‘¨æœŸå–æ ·ã€‚ æœºå™¨çš„æ‹“å±•æ€§ï¼Œé’ˆå¯¹SPXï¼Œå…¶ä»–çš„SPRã€EMRçš„å¯¹åº”äº‹ä»¶çš„æ‹“å±•æ€§æ›¿ä»£å¦‚ä½•ï¼Œæ˜¯å¦éƒ½åªæ˜¯PEBSï¼Ÿ ä¹±åºæ ¡æ­£çš„å½±å“å¤§ä¸å¤§ï¼Ÿ ä¾‹å¦‚ä¸‰æ®µå¼çš„ï¼Œç¬¬ä¸€æ¬¡è¿›è¡Œçƒ­ç‚¹ä»£ç è¯†åˆ«ï¼Œç¬¬äºŒæ¬¡å°†çƒ­ç‚¹ä»£ç å…¨éƒ¨å¸è½½åˆ°CXLï¼Œç„¶ååˆ©ç”¨Neomemæ•è·traceï¼Œä»è€Œå‡†ç¡®æ„ŸçŸ¥ï¼Œæœ€åæ ¹æ®å†³ç­–å®ç°æ•°æ®æ”¾ç½®ï¼Ÿ hard 5.ç»“åˆå†…å­˜åˆ†é…å™¨è¿›è¡Œå°å˜é‡é¡µå†…é›†ä¸­ä¼˜åŒ–ï¼Œå¤§å˜é‡çš„è®¿é—®æ˜¯å¦é›†ä¸­ï¼Ÿä¸é›†ä¸­çš„è¯å¯ä»¥ç”¨perfé‡‡é›†åœ°å€ï¼Œç„¶åç»˜åˆ¶è®¿å­˜ç›´æ–¹å›¾ã€‚","tags":[null]},{"title":"é¾™èœ¥CXLè®²è§£-é«˜æ˜¾æ‰¬","path":"/notebooks/paper/é¾™èœ¥CXLè®²è§£-é«˜æ˜¾æ‰¬.html","content":"CXLæŠ€æœ¯ä»‹ç»å¯¹è§†é¢‘é“¾æ¥çš„PPTæ¬è¿ï¼Œæ–¹ä¾¿å¿«é€Ÿé˜…è¯» é«˜æ˜¾æ¨ æµªæ½® ç»¼è¿° åè®®åè®®æ¼”è¿› 1.1å†…å­˜æ‹“å±• 2.0å†…å­˜èµ¤åŒ– 3.0ç‰¹æ€§ CXLå­åè®® CXLè®¾å¤‡ CXL Fabric å‚è€ƒVPNï¼Œä¸‹è¾¹ä¸¤å¼ ä¸ºå•switch CXL RASç‰¹æ€§ å†…å­˜çƒ­æ’æ‹”ï¼Ÿå¦‚ä½•é¿å…å®•æœº CXLåˆå§‹åŒ– RCRB CXL 1.1è·‘CXL2å®ç°åè®®å…¼å®¹ CXLæ–¹æ¡ˆ æ± åŒ–ç®¡ç†ï¼šFMä¸­çš„bindå’ŒUnBind ä¸šç•Œæ–¹æ¡ˆ è¡¥å……","tags":[null]},{"title":"Hexo","path":"/notebooks/other/hexo.html","content":"Hexoéƒ¨ç½²è¿‡ç¨‹ä¸­é‡åˆ°çš„ä¸€äº›é—®é¢˜å›¾ç‰‡ä¸Typoraå…¼å®¹ç½‘ä¸Šç»™äº†å¾ˆå¤šæ–¹æ³•ï¼Œå°è¯•æ²¡æœ‰æ•ˆæœï¼Œè‡ªå·±å°è¯•çš„æ–¹æ¡ˆï¼š å¸è½½æ’ä»¶hexo-asset-image: yarn remove hexo-asset-image,GitHubæœ‰ä¿®æ”¹çš„å¯¹åº”æ’ä»¶ï¼Œä½†æ˜¯ä½¿ç”¨æ— æ•ˆæœ typoraé…ç½® Typoraæ–°æ’å…¥å›¾ç‰‡è·¯å¾„æ˜¾ç¤ºä¸ºï¼š Hexoéƒ¨ç½²æ—¶æ­£å¸¸æ˜¾ç¤º Hexoä¸ç”Ÿæ•ˆé—®é¢˜Hexoéƒ¨ç½²åˆ°githubä¸Šä¸ç”Ÿæ•ˆï¼Œç½‘ä¸Šè§£å†³æ–¹æ¡ˆè¯´éœ€è¦é™¤Mainæˆ–è€…Masteråˆ†æ”¯ä»¥å¤–é¢å¤–æ„å»ºä¸€ä¸ªåˆ†æ”¯ï¼Œç„¶åç½‘ç«™æ¨é€åˆ°è¿™ä¸ªåˆ†æ”¯ä¸Šï¼Œå®é™…ä½¿ç”¨ä¸ç®¡ç”¨ã€‚ é¦–å…ˆï¼Œåªéœ€è¦ç»´æŠ¤ä¸€ä¸ªä¸»åˆ†æ”¯ï¼Œä¸éœ€è¦å…¶ä»–åˆ†æ”¯ï¼› å…¶æ¬¡ï¼Œhexo -dæ‰§è¡Œä»¥åï¼Œmainåˆ†æ”¯ä¸­å³ä½¿å·²ç»æ›´æ–°äº†ä»£ç ï¼Œä½†æ˜¯github pageæ›´æ–°ä¹Ÿéœ€è¦ä¸€æ®µæ—¶é—´ï¼Œéƒ¨ç½²é¢‘ç¹ä¼šäº§ç”Ÿæ’é˜Ÿ ä»“åº“ä¸»é¡µgithub-pagesä¸Šå¯ä»¥è§‚å¯Ÿåˆ°ç”Ÿæˆé™æ€é¡µé¢çš„è¿›åº¦ã€‚","tags":[null]},{"title":"perfä½¿ç”¨","path":"/notebooks/other/perfä½¿ç”¨.html","content":"Perfä½¿ç”¨ æ‚è®°1.æ–‡æ¡£1.man+perf -hé‡åˆ°æ–°å·¥å…·å½“ç„¶æœ€å¥½çš„æ–¹å¼æ˜¯è¯»æ–‡æ¡£ï¼Œä½†æ˜¯ç½‘ç»œä¸Šæ‰¾åŠå¤©ä¹Ÿæ²¡æœ‰æ‰¾åˆ°å¾ˆå¥½çš„perfæ‰‹å†Œï¼Œæœ€åå‘ç°åœ¨GPTçš„æŒ‡å¼•ä¸‹ï¼Œæœ€å¥½çš„æ‰‹å†Œå®³å¾—æ˜¯linux manæ‰‹å†Œã€‚ ä¸Šæ‰‹æœ€å¿«æœ€å…¨é¢çš„æ–¹å¼ï¼šhelp+man é¦–å…ˆperf -hæŸ¥çœ‹å„æ¡å­å‘½ä»¤åŸºæœ¬åŠŸèƒ½ã€‚ åœ¨ä½¿ç”¨å­å‘½ä»¤æ—¶ man perf-recordã€man perf-scriptæŸ¥çœ‹å„æ¡å­å‘½ä»¤çš„è¯¦ç»†åŠŸèƒ½ã€‚ è¸©å‘æ¡ˆä¾‹ï¼š æŠ˜è…¾åŠå¤©perf recordè®°å½•çš„L3 missï¼Œperf scriptæŸ¥çœ‹å¯¹åº”çš„ç»“æœï¼Œå‘ç°é‡Œé¢æœ‰ä¸€äº›åœ°å€ï¼Œå’Œç¨‹åºmallocæ—¶çš„åœ°å€è¿›è¡ŒåŒ¹é…å‘ç°éƒ½æ²¡æœ‰è®¿é—®ç¨‹åºmallocçš„ä½ç½®ï¼Œæœ€åå‘ç°å…¶ä¸­çš„åœ°å€æ˜¯ipè€Œä¸æ˜¯è®¿é—®çš„å†…å­˜åœ°å€ã€‚å‡ ç•ªæŸ¥æ‰¾èµ„æ–™æ— æœï¼Œæœ€åå‘ç°perf recordä¸­ä½¿ç”¨-då‚æ•°æ‰ä¼šæ˜¾ç¤ºaddr 2.eventæŸ¥çœ‹å„ä¸ªäº‹ä»¶çš„è¯¦ç»†æè¿°ï¼Œåœ¨intel å®˜æ–¹çš„äº‹ä»¶åº“ä¸­æŸ¥æ‰¾å¯¹åº”çš„äº‹ä»¶åŠŸèƒ½ https://perfmon-events.intel.com/index.html?pltfrm=skylake_server.html 3.æ–‡ç« ä¸ä¼˜åŒ–æ¡ˆä¾‹https://www.brendangregg.com/ https://weedge.github.io/perf-book-cn/zh/chapters/3-CPU-Microarchitecture/3-8_Modern_CPU_design_cn.html 2.è¸©å‘æ‚è®°perfäº‹ä»¶å†²çª","tags":[null]},{"title":"LLVM","path":"/notebooks/compiler_kernel/LLVM/LLVM.html","content":"å…¥é—¨llvmç¬”è®° 1.æ–°å¢passæµç¨‹æ–°å¢æ•™ç¨‹ï¼š https://llvm.org/docs/WritingAnLLVMNewPMPass.html1.æ–°å¢pass çš„æµç¨‹ä»åŸºäºè™šå‡½æ•°çš„è¿è¡Œæ—¶å¤šæ€å˜æ›´ä¸ºäº†åŸºäºCRTPçš„ç¼–è¯‘æœŸå¤šæ€ã€‚ä¸€ä¸ªä¼˜ç‚¹æ˜¯é™ä½äº†è¿è¡Œæ—¶å¼€é”€ã€‚ 2CRTPï¼ˆå¥‡å¼‚é€’å½’æ¨¡æ¿æ¨¡å¼ï¼‰(ä»¥ä¸‹å†…å®¹åŸºäºAIç”Ÿæˆåä¿®æ”¹) é€šå¸¸é€šè¿‡ç»§æ‰¿çš„æ–¹å¼å®ç°å•ä¾‹æ¨¡å¼ä¹Ÿæ˜¯è¿™æ ·ï¼Œåªæ˜¯ä¸çŸ¥é“å«è¿™ä¸ªåå­— CRTPï¼ˆCuriously Recurring Template Patternï¼Œå¥‡å¼‚é€’å½’æ¨¡æ¿æ¨¡å¼ï¼‰æ˜¯C++ä¸­çš„ä¸€ç§é«˜çº§æ¨¡æ¿ç¼–ç¨‹æŠ€æœ¯ï¼Œé€šè¿‡è®©ä¸€ä¸ªç±»ç»§æ‰¿è‡ªä»¥è‡ªèº«ä¸ºæ¨¡æ¿å‚æ•°çš„åŸºç±»æ¨¡æ¿ï¼Œå®ç°é™æ€å¤šæ€æˆ–ä»£ç å¤ç”¨ã€‚ template typename Derivedclass Base /* åŸºç±»ä½¿ç”¨Derivedç±»å‹ */ ;class MyClass : public BaseMyClass /* æ´¾ç”Ÿç±»å°†è‡ªèº«ä½œä¸ºæ¨¡æ¿å‚æ•°ä¼ é€’ç»™åŸºç±» */ ; æ ¸å¿ƒä½œç”¨1. é™æ€å¤šæ€ï¼ˆç¼–è¯‘æ—¶å¤šæ€ï¼‰ åŠ¨æ€å¤šæ€ï¼ˆè™šå‡½æ•°ï¼‰çš„é—®é¢˜ï¼šè¿è¡Œæ—¶è™šè¡¨æŸ¥æ‰¾å¯¼è‡´æ€§èƒ½å¼€é”€ã€‚ CRTPçš„è§£å†³æ–¹æ¡ˆï¼šåŸºç±»åœ¨ç¼–è¯‘æ—¶é€šè¿‡æ¨¡æ¿å‚æ•°ç›´æ¥è°ƒç”¨æ´¾ç”Ÿç±»çš„æ–¹æ³•ã€‚ template typename Derivedclass Animal public: void speak() static_castDerived*(this)-speakImpl(); // ç¼–è¯‘æ—¶ç¡®å®šè°ƒç”¨ ;class Cat : public AnimalCat public: void speakImpl() std::cout Meow ; ;class Dog : public AnimalDog public: void speakImpl() std::cout Woof ; ;// ä½¿ç”¨AnimalCat cat;cat.speak(); // è¾“å‡º Meowï¼ˆæ— è™šå‡½æ•°å¼€é”€ï¼‰ 2. ä»£ç å¤ç”¨ åŸºç±»å¯æä¾›é€šç”¨é€»è¾‘ï¼Œæ´¾ç”Ÿç±»é€šè¿‡ç‰¹åŒ–å®ç°å·®å¼‚éƒ¨åˆ†ã€‚ template typename Derivedclass Counter protected: static int count;public: Counter() ++count; static int getCount() return count; ;template typename Derivedint CounterDerived::count = 0;// ç»Ÿè®¡å¯¹è±¡å®ä¾‹æ•°çš„ç±»class Widget : public CounterWidget ;class Gadget : public CounterGadget ;// ä½¿ç”¨Widget w1, w2;Gadget g1;std::cout Widget::getCount(); // è¾“å‡º 2std::cout Gadget::getCount(); // è¾“å‡º 1 CRTP vs è™šå‡½æ•° ç‰¹æ€§ CRTP è™šå‡½æ•° å¤šæ€æ—¶æœº ç¼–è¯‘æ—¶ è¿è¡Œæ—¶ æ€§èƒ½ æ— é¢å¤–å¼€é”€ï¼ˆç›´æ¥è°ƒç”¨ï¼‰ è™šè¡¨æŸ¥æ‰¾å¼€é”€ çµæ´»æ€§ ç±»å‹å›ºå®šï¼ˆæ¨¡æ¿å‚æ•°éœ€æ˜ç¡®ï¼‰ æ”¯æŒè¿è¡Œæ—¶ç±»å‹åŠ¨æ€æ›¿æ¢ é€‚ç”¨åœºæ™¯ é«˜æ€§èƒ½åº“ã€æ¡†æ¶åŸºç¡€è®¾æ–½ éœ€è¦è¿è¡Œæ—¶åŠ¨æ€è¡Œä¸ºçš„æƒ…å†µ CRTPçš„å…¸å‹åº”ç”¨åœºæ™¯ ç¼–è¯‘æ—¶å¤šæ€ï¼šå¦‚æ•°å­¦åº“ä¸­çš„å‘é‡çŸ©é˜µè¿ç®—ï¼ˆEigenåº“ï¼‰ã€‚ å¯¹è±¡è®¡æ•°ï¼šç»Ÿè®¡ä¸åŒæ´¾ç”Ÿç±»çš„å®ä¾‹æ•°é‡ã€‚ Mixinæ¨¡å¼ï¼šä¸ºç±»åŠ¨æ€æ·»åŠ åŠŸèƒ½ï¼ˆå¦‚LLVMçš„PassInfoMixinï¼‰ã€‚ é“¾å¼è°ƒç”¨ï¼šè¿”å›æ´¾ç”Ÿç±»å¼•ç”¨ä»¥å®ç°é“¾å¼è¯­æ³•ï¼ˆreturn static_castDerived(*this);ï¼‰ã€‚ 3 LLVMä¸CPPå®ç°DenseMapä¸stdMapdyn_castä¸RTTI isadef-use user-valueä¸ºä»€ä¹ˆllvmä¸­Userä¼šç»§æ‰¿value 4 æ”¯é…æ ‘åŸºæœ¬æ¦‚å¿µæ”¯é…æ ‘ wiki ä¸¥æ ¼æ”¯é…ï¼ˆStrict Dominationï¼‰ï¼šå¦‚æœ A æ”¯é… B ä¸” A â‰  Bï¼Œåˆ™ç§° A ä¸¥æ ¼æ”¯é… Bã€‚ ç«‹å³æ”¯é…è€…ï¼ˆImmediate Dominator, idomï¼‰ï¼šå¯¹äºæŸä¸ªåŸºæœ¬å— Bï¼Œå…¶è¢«ä¸¥æ ¼æ”¯é…çš„æ‰€æœ‰åŸºæœ¬å—ä¸­ï¼Œç¦» B æœ€è¿‘çš„é‚£ä¸ªç§°ä¸º B çš„ç«‹å³æ”¯é…è€…ã€‚ LLVMä¸­çš„ä½¿ç”¨åœºæ™¯ æ­»ä»£ç æ¶ˆé™¤ (Dead Code Elimination) æ­»ä»£ç æ¶ˆé™¤æœ‰å¤šç§æ–¹æ³•å¤šç§ç²’åº¦ï¼Œè¿™é‡Œblockä¸ºç²’åº¦å¯ä»¥ä½¿ç”¨æ”¯é…æ ‘æ–¹æ³• å¦‚æœä¸€ä¸ªåŸºæœ¬å—ä¸åœ¨å…¥å£å—çš„æ”¯é…æ ‘ä¸Šï¼Œé‚£è¯´æ˜å®ƒåœ¨æŸäº›è·¯å¾„ä¸Šæ ¹æœ¬æ— æ³•åˆ°è¾¾ï¼Œå› æ­¤å¯èƒ½æ˜¯ä¸å¯è¾¾ä»£ç ã€‚ if (!DT-dominates(entry, B)) B-eraseFromParent(); // åˆ é™¤ä¸å¯è¾¾çš„åŸºæœ¬å— å¾ªç¯è¯†åˆ« (Loop Identification) LICMï¼ˆLoop-Invariant Code Motionï¼‰æ˜¯ä¸€ç§ç»å…¸çš„å¾ªç¯ä¼˜åŒ–ç­–ç•¥ã€‚è¦å®‰å…¨åœ°å°†ä¸€æ¡æŒ‡ä»¤ä»å¾ªç¯ä½“ä¸­ç§»å‡ºï¼ˆå¤–æåˆ°å‰ç½®å—ä¸­ï¼‰ï¼Œå¿…é¡»ä¿è¯å…¶åœ¨æ‰€æœ‰å¾ªç¯å…¥å£éƒ½è¢«æ‰§è¡Œã€‚ åˆ¤æ–­æŸæ¡æŒ‡ä»¤çš„åŸºæœ¬å¼€æ˜¯å¤Ÿè¢«å¾ªç¯å…¥å£å—æ”¯é…ï¼Œå¦‚æœæ”¯é…ï¼Œåˆ™è¯´æ˜æ¯æ¬¡éƒ½ä¼šæ‰§è¡Œè¿™æ¡æŒ‡ä»¤ï¼Œå¯ä»¥å¤–æ é™æ€å•èµ‹å€¼èŠ‚ç‚¹Î¦ èŠ‚ç‚¹æ’å…¥ å…³é”®ç±»ä¸å…³é”®æ¥å£ DominatorTreeï¼šæ ¸å¿ƒæ”¯é…æ ‘å®ç°ï¼Œllvm/IR/Dominators.h DominatorTreeWrapperPassï¼šå°†æ”¯é…æ ‘å°è£…ä¸ºåˆ†æPass DominatorTreeAnalysisï¼šæ”¯é…æ ‘åˆ†æ DominatorTree DT = getAnalysisDominatorTreeWrapperPass().getDomTree(); ä½œç”¨ï¼š invoke callCallBaseInvokeInst","tags":[null]},{"title":"Kernel-compile","path":"/notebooks/compiler_kernel/Linux kernel/Kernel-compile.html","content":"å†…æ ¸ç¼–è¯‘#æŸ¥çœ‹å½“å‰å†…æ ¸ç‰ˆæœ¬uname -a#æºç è·å–sudo apt-get install linux-sourcecd /usr/srctar xvf linux-source-*.tar.bz2cd linux-source-*#è¡¥ä¸åº”ç”¨patch -p1 /path/to/patch.diff#`-p1`é€‰é¡¹å¯èƒ½éœ€è¦æ ¹æ®è¡¥ä¸æ–‡ä»¶çš„æ ¼å¼è¿›è¡Œè°ƒæ•´ã€‚#ç¼–è¯‘ä¸€äº›è€ç‰ˆæœ¬æ—¶ï¼Œconfigæ–‡ä»¶å·®å¼‚æ¯”è¾ƒå¤§ï¼Œ è§£å†³æ–¹æ³•æ˜¯ä½¿ç”¨ä¸€äº›è€ç‰ˆæœ¬çš„pve kernel çš„é…ç½®æ–‡ä»¶# http://mirrors.ustc.edu.cn/proxmox/debian/dists/bullseye/pve-no-subscription/binary-amd64/#wget ä¸‹è½½å¥½ä»¥åï¼Œdpkg -i å®‰è£…ï¼Œä¹‹åcopyå¯¹åº”çš„å†…æ ¸configæ–‡ä»¶è¿›è¡Œç¼–è¯‘make menuconfig #æˆ–è€…oldconfig,æœ¬è´¨æ˜¯é…ç½®/usr/src/configmake -j$(nproc)#æ ¹æ® .config é…ç½®æ–‡ä»¶ç¼–è¯‘å†…æ ¸ã€å†…æ ¸æ¨¡å—å’Œå…¶ä»–å¿…è¦çš„æ–‡ä»¶ï¼Œç”Ÿæˆå†…æ ¸é•œåƒï¼ˆvmlinuzï¼‰å’Œå…¶ä»–ç›¸å…³çš„æ–‡ä»¶#ç¼–è¯‘è¿‡ç¨‹ä¸­å¯èƒ½å‡ºç°æ¯åŒ…å¤´æ–‡ä»¶æˆ–è€…å…¶ä»–é”™è¯¯ï¼Œå¯èƒ½æ˜¯ç‰ˆæœ¬åŸå› ï¼Œé’ˆå¯¹æŠ¥é”™è§£å†³å³å¯#å†…æ ¸å®‰è£…#å®‰è£…è¿‡ç¨‹å¯èƒ½ä¼šå‡ºç°å¤´æ–‡ä»¶æŠ¥é”™æˆ–è€…ç¼ºåº“ã€æˆ–å®‰è£…å®Œæˆåç¼ºåº“ï¼Œåªéœ€è¦aptå®‰è£…å¯¹åº”çš„åº“å°±å¥½ï¼Œmakeè¿‡ç¨‹ä¸­ä¼šè‡ªåŠ¨hook#å®‰è£…å†…æ ¸æ¨¡å—(åœ¨è¿è¡Œæ—¶å¯ä»¥åŠ è½½æˆ–å¸è½½çš„æ¨¡å—)#ä»ç¼–è¯‘è¾“å‡ºçš„ç›®å½•ï¼ˆå¦‚ lib/modules/kernel_version/ï¼‰,å¹¶æ‰§è¡Œ depmod æ¥ç”Ÿæˆæ¨¡å—ä¾èµ–å…³ç³»sudo make modules_install#å†…æ ¸é•œåƒï¼ˆå¦‚ vmlinuzï¼‰ã€é…ç½®æ–‡ä»¶ï¼ˆå¦‚ configï¼‰ã€ç¬¦å·è¡¨æ–‡ä»¶ï¼ˆå¦‚ System.mapï¼‰å’Œ initrd é•œåƒå®‰è£…åˆ° /boot ç›®å½•sudo make install#æ›´æ–°å¯åŠ¨å¼•å¯¼ç¨‹åºsudo update-grup å…³äºé…ç½®é€‰é¡¹ç›¸å…³æ“ä½œï¼Œå‚è€ƒï¼š:star::star:Linux å†…æ ¸åŠ¨æ‰‹ç¼–è¯‘å®ç”¨æŒ‡å— KGDBé…ç½®ç¼–è¯‘é€‰é¡¹ å‚è€ƒèµ„æ–™KGDBåŸç†åˆ†æåŠè¿œç¨‹æŒ‚è½½è°ƒè¯•ARM64å†…æ ¸ å†…æ ¸å¯åŠ¨å‚æ•° kgdboc=ttyS0,115200 kgdbwait kgdbtcp=192.168.1.2:1234 kgdboc=ttyS0,115200ï¼šè®¾ç½®ä¸²å£è°ƒè¯•ï¼ˆå¯é€‰ï¼‰ kgdbwaitï¼šå¯åŠ¨æ—¶ç­‰å¾…è°ƒè¯•å™¨è¿æ¥ kgdbtcp=192.168.1.2:1234ï¼šè¢«è°ƒè¯•ä¸»æœºçš„IPå’Œç«¯å£ æ°¸ä¹…ä¿®æ”¹ï¼š/etc/default/grubä¸‹GRUB_CMDLINE_LINUXå˜é‡ proxmox-boot-toolproxmox-boot-toolï¼Œä¸€ä¸ªè„šæœ¬ï¼Œè®¾ç½®å¯åŠ¨å†…æ ¸ã€å¢åˆ å†…æ ¸ç­‰,ä½¿ç”¨è®¾ç½®grubå†…æ ¸å¯åŠ¨å‚æ•°çš„æ–¹å¼ä¸ä¸€å®šç”Ÿæ•ˆçš„æƒ…å†µä¸‹å¯ä»¥ä½¿ç”¨è¿™ä¸ªå·¥å…·ã€‚ proxmox-boot-tool git clone https://git.proxmox.com/git/proxmox-kernel-helper.gitä¹‹å make debä¼šåœ¨å½“å‰è·¯å¾„ä¸‹ç”Ÿæˆå¯¹åº”çš„debåŒ…ï¼Œapt installå®‰è£…åå¯ä»¥æ­£å¸¸ä½¿ç”¨/usr/sbin/proxmox-boot-tool å‚è€ƒé“¾æ¥ï¼šhttps://kernelnewbies.org/KernelBuild","tags":[null]},{"title":"Neoperf_study","path":"/notebooks/compiler_kernel/Linux kernel/Neoperf-study.html","content":"NeoPerf study æœ¬æ–‡ä¸»è¦ä¸ºå­¦ä¹ è®ºæ–‡ã€ŠNeoMem: HardwareSoftware Co-Design for CXL-Native Memory Tieringã€‹çš„å·¥ä½œï¼Œåˆ†ä¸ºä¸‰ä¸ªéƒ¨åˆ†ï¼Œç”¨æˆ·æ€ã€å†…æ ¸ä»¥åŠFPGAéƒ¨åˆ†ï¼Œå†…æ ¸å¼€æºä»“åº“åœ°å€ä¸ºï¼š PKUZHOUlinux ä»£ç åŸºäºlinuxå†…æ ¸ä»£ç 6.0å¼€å§‹ä¿®æ”¹ã€‚ ç”±äºåˆæ­¥æ¢ç´¢linuxå†…æ ¸ä»£ç ï¼Œæ‰€ä»¥æ²¡æœ‰æŒ‰ç…§è‡ªé¡¶å‘ä¸‹çš„è§†è§’åˆ†æä»£ç ï¼Œè€Œæ˜¯åŸºäºgitæäº¤è®°å½•ï¼Œå€ŸåŠ©AIä¸äº’è”ç½‘æœç´¢ï¼Œå¹³é“ºé‡åˆ°çš„ç›¸å…³çŸ¥è¯†ã€‚ç‰ˆæœ¬ä¸æ–­æ›´æ–°â€¦â€¦ a naive neoprof drivercommit ID 9bd35383 æœ¬æ¬¡ä¸»è¦åœ¨driverç›®å½•ä¸‹æäº¤äº†ä¸€ä¸ªé©±åŠ¨neoperf: ä¸»è¦æ˜¯å®ç°äº†ä¸€äº›å¯¹å¤–è®¾çš„IOæ“ä½œ Linuxå†…æ ¸é…ç½®æ–‡ä»¶KconfigKconfigæ–‡ä»¶ç”¨äºå®šä¹‰å†…æ ¸é…ç½®èœå•ï¼Œè¿™äº›èœå•å¯ä»¥åœ¨ç¼–è¯‘å†…æ ¸æ—¶å¯ç”¨æˆ–ç¦ç”¨ç‰¹å®šçš„åŠŸèƒ½ã€‚ #Kconfigæ–‡ä»¶config NEOPROF#å®šä¹‰äº†ä¸€ä¸ªåä¸º`NEOPROF`çš„å†…æ ¸é…ç½®é€‰é¡¹ï¼Œå°†åœ¨å†…æ ¸é…ç½®èœå•ä¸­åˆ›å»ºé€‰é¡¹\tbool Enable Neoprofiler #boolç±»å‹ï¼Œæ˜¯å¦å¯ç”¨ default n #é»˜è®¤ä¸å¯ç”¨ åœ¨å†…æ ¸ç¼–è¯‘è¿‡ç¨‹ä¸­å¯ä»¥åœ¨Driversä¸‹æŸ¥æ‰¾åˆ° Kconfigæœ‰å…¶ç‹¬ç‰¹çš„è¯­æ³•ï¼Œä¹Ÿæ˜¯å¯ä»¥ä¸€å±‚ä¸€å±‚åŒ…è£¹ä¸‹å»ï¼šmenuã€sourceã€endmenuç­‰ç»„æˆäº†ç¼–è¯‘é€‰é¡¹é…ç½®è¿‡ç¨‹ä¸­çš„æ ‘çŠ¶èœå• Kconfigè®¾ç½®å¯¹åº”çš„ç¼–è¯‘å˜é‡åï¼ŒmakefileæŒ‡å¯¼æ„å»ºç¼–è¯‘çš„è¿‡ç¨‹ä¸­ä¼šåˆ©ç”¨è¿™äº›å˜é‡ï¼Œä»è€Œå®ç°é€‰æ‹©æ€§çš„ç¼–è¯‘ neoperf.hä¸»è¦æ–°å¢äº†å››ä¸ªæ¥å£ï¼Œå¯¹neoprofè®¾å¤‡ï¼ˆæ­¤å¤„æŒ‡Type2-CXLè®¾å¤‡ï¼‰è¿›è¡Œè®¿é—®ï¼š /* * The following functions are used to access the neoprof device*/u64 get_nr_hotpages(void);//è·å–å½“å‰ç³»ç»Ÿä¸­çš„çƒ­é¡µæ•°é‡u64* get_hotpages(void);//è·å–çƒ­é¡µu64 get_hotness_threshold(void);//è·å–çƒ­åº¦é˜ˆå€¼void set_hotness_threshold(u64 threshold);//è®¾ç½®çƒ­åº¦é˜ˆå€¼ neoperf.cé©±åŠ¨å¼€å‘hello worldneoperf.c ä»¥ä¸‹éƒ¨åˆ†å‚è€ƒé©±åŠ¨å¼€å‘çŸ¥è¯†ï¼šhttps://www.cnblogs.com/downey-blog/p/10500828.html module_init(neoprof_init);module_exit(neoprof_exit);MODULE_LICENSE(GPL v2);MODULE_AUTHOR(PKUZHOU);MODULE_DESCRIPTION(Neoprofiler Linux driver); ioåœ°å€æ˜ å°„ç›¸å…³çŸ¥è¯†éœ€è¦ç†è§£ IOç«¯å£çš„ç¼–å€æ–¹å¼ï¼š åŒ…æ‹¬IOæŒ‡ä»¤çš„ç«¯å£æ˜ å°„æ–¹å¼ã€MMIOçš„ç»Ÿä¸€å†…å­˜æ˜ å°„æ–¹å¼ ä¸€äº›å¸¸è§çš„IOæ“ä½œå‡½æ•° void * ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags); //memset_io\\memcpy_fromio\\readb å‚è€ƒï¼šhttps://blog.csdn.net/do2jiang/article/details/5450839 neomem migration skeletoncommit ID 26cabad18 æ–°å¢ NeoMemæ¨¡å—: migrate.cä¸»è¦æ˜¯æä¾›æ¥å£migrate_misplaced_page_no_vma è°ƒç”¨ä¸€äº›mmä¸­çš„å†…å­˜æ“ä½œå‡½æ•°ï¼Œè¿›è¡Œé¡µé¢éš”ç¦»ã€è¿ç§» neomem.h eomem.cä¸»è¦å°±æ˜¯å¯åŠ¨ neomemæ¨¡å—ï¼ˆè°ƒç”¨coreæ–‡ä»¶ä¸­å¯åŠ¨å®ˆæŠ¤è¿›ç¨‹ï¼‰ late_initcall()åœ¨å†…æ ¸å¯åŠ¨åæœŸé€‚å½“æ—¶é—´æ‰§è¡Œï¼Œç†è§£module_initç­‰initå®çš„é¡ºåºï¼Œåœ¨include/linux/init.hä¸­ linuxè®¾å¤‡é©±åŠ¨åŠ è½½çš„å…ˆåé¡ºåº neomem_core.c å†…å­˜ä¸­çš„å„ç§åˆ†é…å‡½æ•° kthread_runå†…æ ¸çº¿ç¨‹ FPGAç«¯ä¾§æ¨¡å—ç»“æ„é¡¶å±‚æ¨¡å—ï¼š cxltyp3_memexp_ddr4_top-ed_top_wrapper_typ3 ddrå†…å­˜å‚æ•°è°ƒæ•´cxl ipè€ƒè™‘äº†ä¸åŒddrçš„ï¼ŒåŒ…æ‹¬æ˜¯å¦æ”¯æŒDBIã€å†…å­˜é€šé“æ•°é‡ç­‰ã€‚é‡‡ç”¨å®çš„æ–¹å¼åŒºåˆ†ï¼Œè®¾ç½®ä¸åŒçš„æ–¹å¼æ—¶ï¼Œéœ€è¦å¯¹ipå†…é€šè¿‡å®å®šä¹‰æ¥ç¡®å®šç›¸å…³çš„å†…å­˜å‚æ•°ï¼ŒåŒæ—¶ä¹Ÿéœ€è¦åœ¨é¡¶å±‚æ¨¡å—å¯¹ç›¸å…³å‚æ•°è¿›è¡Œä¿®æ”¹ã€‚ .ewiflfomhwoi{zoom:50%;} .zjedgavxqyoc{zoom:50%;} .kmksdqqyojvw{zoom:50%;} æˆ–è€…é€šè¿‡æ›´æ”¹ipæ–‡ä»¶ï¼Œé‡æ–°ç”Ÿæˆæ–°çš„IPæ–‡ä»¶å¤¹ .djcxlntwijgd{zoom:50%;} quartusset_global_assignment -name OPTIMIZATION_MODE AGGRESSIVE COMPILE TIME çƒ§å½•æ¨¡å¼AS Jtag ps ä¸‰ç§çƒ§å½•æ¨¡å¼ Neomem todoä»£ç å­˜åœ¨ä¸€äº›å¯ä»¥å®Œå–„çš„åœ°æ–¹ï¼š CXLåœ°å€é‡‡ç”¨ç¡¬ç¼–ç ï¼Œå¯ä»¥å¼•å…¥è®¾å¤‡æ ‘æˆ–è€…å…¶ä»–æ£€æµ‹CXLç‰©ç†åœ°å€çš„å·¥å…·è¿›è¡Œä¼˜åŒ–ï¼Œå‚è€ƒ","tags":[null,null,null,null,null]},{"title":"linuxè„šæœ¬å¤‡å¿˜å½•","path":"/notebooks/compiler_kernel/Linux kernel/linuxè„šæœ¬å¤‡å¿˜å½•.html","content":"Linuxè„šæœ¬å¤‡å¿˜å½•å®‰è£…ç³»ç»Ÿåçš„ç¯å¢ƒå‡†å¤‡æ·»åŠ æ–°ç”¨æˆ· adduser #å°è£…å‘½ä»¤ï¼Œå¤„ç†å®Œæ·»åŠ ç”¨æˆ·çš„å…¨éƒ¨è¿‡ç¨‹ suåˆ°æ–°ç”¨æˆ·æ˜¾ç¤ºusername@hostname~$:useradd #åº•å±‚å‘½ä»¤ï¼Œä»€ä¹ˆéƒ½æ²¡æœ‰åŠ ,suåˆ°æ–°ç”¨æˆ·æ˜¾ç¤º$:# ç”Ÿæˆ 8 ä½å¼ºå¯†ç PASSWORD=$(openssl rand -base64 6 | cut -c1-8)echo Password: $PASSWORD ç”¨æˆ·æ·»åŠ sudoç»„ usermod -aG sudo new_user#åŠ å®Œä»¥åè®°å¾—:newgrp sudo#ä½œç”¨æœ‰3ï¼š#1.åˆ‡æ¢åˆ°æŒ‡å®šçš„ç»„ä¸Šä¸‹æ–‡#2.å³æ—¶ç”Ÿæ•ˆç»„æ›´æ”¹#3.å¯åŠ¨ä¸€ä¸ªå­ shell é…ç½®sshd#æœåŠ¡ç«¯å®‰è£…apt install ssh-server#é…ç½®sudo vim /etc/ssh/sshd_config#é‡å¯æœåŠ¡sudo service restart sshd VimVimé…ç½®æ¨è - ma6174 wget 47.93.11.51:88/install_vim.shbash install_vim.sh zsh#å®‰è£…zshsudo apt install zsh#ä¿®æ”¹é»˜è®¤shellä¸ºzshchsh -s /bin/zsh#å®‰è£…oh-my-zshsh -c $(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)##å¦‚æœä¸æˆåŠŸï¼Œè¯·æ‰§è¡Œä¸‹é¢ä¸¤æ¡å‘½ä»¤ï¼ŒæˆåŠŸäº†å°±ä¸éœ€è¦åšä¸‹é¢ä¸¤æ¡wget 47.93.11.51:88/install_zsh.shbash install_zsh.sh#å®‰è£…zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM:-~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting å†å²è®°å½•æ¨èå‘½ä»¤æ’ä»¶##å‘½ä»¤è‡ªåŠ¨æ¨èï¼Œæ ¹æ®å†å²è®°å½•git clone https://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM:-~/.oh-my-zsh/custom/plugins/zsh-autosuggestions å‘½ä»¤è‡ªåŠ¨è¡¥å…¨##å‘½ä»¤è‡ªåŠ¨è¡¥å…¨æ’ä»¶mkdir ~/.oh-my-zsh/plugins/incrwget http://mimosa-pudica.net/src/incr-0.2.zsh -O ~/.oh-my-zsh/plugins/incr/incr.plugin.zsh##ç›®å½•è‡ªåŠ¨è·³è½¬æ’ä»¶sudo apt install autojump .zshrcé…ç½®æ–‡ä»¶é…ç½®#æ’ä»¶æ·»åŠ zsh-syntax-highlightingplugins=(git zsh-syntax-highlighting) #è®¾ç½®ç»ˆç«¯é¢œè‰²ï¼Œæç¤ºç¬¦ï¼ŒåŠä¸Šä¸€æ¡æŒ‡ä»¤è¿”å›ç æç¤ºautoload -U colors colorsPROMPT=%$fg[red]%%n%$reset_color%@%$fg[blue]%%m %$fg[yellow]%%1~ %$reset_color%%# RPROMPT=[%$fg[yellow]%%?%$reset_color%]# Useful support for interacting with Terminal.app or other terminal programs[ -r /etc/zshrc_$TERM_PROGRAM ] . /etc/zshrc_$TERM_PROGRAMsource ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.plugin.zshsource /usr/share/autojump/autojump.shsource ~/.oh-my-zsh/plugins/incr/incr*.zsh ctags#å®‰è£…sudo apt install ctags #å»ºç«‹ç´¢å¼•ctags -I __THROW -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --langmap=c:+.h --languages=c,c++ --links=yes --c-kinds=+p --c++-kinds=+p --fields=+iaS --extra=+q -f ~/.vim/systags /usr/include/* /usr/include/x86_64-linux-gnu/sys/* /usr/include/x86_64-linux-gnu/bits/* /usr/include/arpa/* .vimrcæ·»åŠ ç´¢å¼• set tags+=~/systags å®‰è£…glibc-doc ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤å®‰è£… sudo apt install glibc-doc å¸¸è§è·¯å¾„hostname :/etc/hostname host: /ect/hosts tomcat#å®‰è£…JDK8sudo apt install default-jre -ysudo apt install openjdk-11-jre-headless -ysudo apt install openjdk-8-jre-headless -y #sudo wget https://downloads.apache.org/tomcat/tomcat-8/v8.5.65/bin/apache-tomcat-8.5.65.tar.gzsudo wget https://mirrors.bfsu.edu.cn/apache/tomcat/tomcat-8/v8.5.73/bin/apache-tomcat-8.5.73.tar.gztar zxf apache-tomcat-8.5.73.tar.gzsudo mv apache-tomcat-8.5.73 /usr/local/tomcat#å»ºç«‹è½¯è¿æ¥sudo ln -s /usr/local/tomcat/bin/* /usr/local/sbin/#å¯åŠ¨startup.sh start #ç«¯å£æ£€æŸ¥netstat -anput | grep 8080#å¯åŠ¨å‘½ä»¤startup.sh start #//å¯åŠ¨shutdown.sh #//å…³é—­catalina.sh stop #//å¯åŠ¨catalina.sh start #//å…³é—­#å…³é—­é˜²ç«å¢™sudo ufw disable #tomcat å‚æ•°é…ç½®vim /usr/local/tomcat/conf/server.xml #.......Connector port=8081 protocol=HTTP/1.1 #å°†ä¹‹å‰8080ç«¯å£æ”¹æˆ8081ç«¯å£connectionTimeout=20000 # redirectPort=8443 /#ç›®å½•ä¿® # Host name=localhost appBase=/opt/www #å°†ç½‘ç«™æ ¹ç›®å½•æ”¹åˆ°/opt/www # unpackWARs=true autoDeploy=true#æ›´æ”¹ç½‘ç«™å®¶ç›®å½•ï¼Œè¿™é‡Œçš„ROOTå¿…é¡»å¤§å†™ï¼Œæ›´æ”¹å®Œæˆåéœ€è¦é‡å¯sudo mkdir /opt/www/ROOT -p gdb å¤šçª—å£è°ƒè¯•é€šè¿‡TUIï¼ˆText User Interfaceï¼‰æä¾›å¤šçª—å£è°ƒè¯•ç¯å¢ƒå¯åŠ¨ï¼š gdb -tui a.out æˆ–è¿è¡Œè¿‡ç¨‹ä¸­ ctrl+X+Aå¼€å¯æˆ–è€…å…³é—­TUIåœºæ™¯ä¸‹æ“ä½œï¼š layout srcï¼šæ˜¾ç¤ºæºä»£ç çª—å£å’Œå‘½ä»¤çª—å£ layout asmï¼šæ˜¾ç¤ºæ±‡ç¼–ä»£ç çª—å£å’Œå‘½ä»¤çª—å£ layout splitï¼šåŒæ—¶æ˜¾ç¤ºæºä»£ç ã€æ±‡ç¼–ä»£ç å’Œå‘½ä»¤çª—å£ layout regï¼šæ˜¾ç¤ºå¯„å­˜å™¨çª—å£ï¼ˆä¼šä¸Â srcÂ æˆ–Â asmÂ çª—å£åŒæ—¶æ˜¾ç¤ºï¼‰ focus nextÂ å‘½ä»¤å¯ä»¥å°†ç„¦ç‚¹åˆ‡æ¢åˆ°å‘½ä»¤ï¼ˆcmdï¼‰çª—å£ï¼Œä¹‹åæ–¹å‘é”®å°±å¯ä»¥ç”¨æ¥ç¿»æ‰¾å†å²å‘½ä»¤ focus prevÂ å¯ä»¥åˆ‡å›Â srcÂ çª—å£ LLDBmac ä½¿ç”¨gdbè¦é…ç½®ç­¾åï¼Œlldb ä¸‹ç›´æ¥è¾“å…¥gui ï¼Œæœ‰ä¸€ä¸ªå›¾å½¢åŒ–ç•Œé¢ mysqlmysql 8.0ä¸‹è½½ wget https://repo.mysql.com//mysql-apt-config_0.8.20-1_all.deb #MySQL è®¾ç½®#å¯†ç sudo mysql -uroot use mysql;update user set authentication_string=PASSWORD(è‡ªå®šä¹‰å¯†ç ) where User=root;update user set plugin=mysql_native_password where User =root;flush privileges;quit; å¯¹äºLinuxå’Œwindowsä¸‹å­—ç¬¦é›†ä¸å…¼å®¹çš„æƒ…å†µï¼Œéœ€è¦æ›¿æ¢ â€¢ æŠŠæ–‡ä»¶ä¸­çš„æ‰€æœ‰çš„utf8mb4_0900_ai_ciæ›¿æ¢ä¸ºutf8_general_ciâ€¢ ä»¥åŠutf8mb4æ›¿æ¢ä¸ºutf8â€¢ å¦‚ä¸Šå›¾æ‰€ç¤ºçš„ä½ç½®ï¼Œä¸Šå›¾åªæ˜¯ä¸€éƒ¨åˆ†ï¼Œæ³¨æ„å…¨éƒ¨æ›¿æ¢ã€‚ æ•°æ®åº“å¯¼å‡º mysqldump -uroot -p c:ShareYunAlbumã€‚sql æ•°æ®åº“å¯¼å…¥ use ShareYunAlbum source ~/ShqreYunAlbum.sql å¸è½½mysql sudo apt purge mysql-* -ysudo rm -rf /etc/mysql/ /var/lib/mysqlsudo apt autoremovesudo apt autorecleansudo apt-get remove mysql-common dpkg -l |grep ^rc|awk print $2 |sudo xargs dpkg -P","tags":[null]},{"title":"llama.cpp","path":"/notebooks/other/å¤§æ¨¡å‹/llama-cpp.html","content":"Llama.cppæºç æµ…æggml æºç ç»“æ„å­¦ä¹ å…¥å£å‡½æ•°ç®€å•ä»¥llama.cliä½œä¸ºæ¨ç†å­¦ä¹ çš„å…¥å£ã€‚å…¶å…¥å£å‡½æ•°mainä½ç½®ä¸ºï¼šllama.cpp/tool/main.cpp/main() å…³é”®æ•°æ®ç»“æ„å†…å­˜ç®¡ç†Arena åˆ†é…å™¨â€œæ‰¹å‘å†…å­˜ï¼Œé›¶å”®æŒ‡é’ˆï¼Œæ•´å•æ¸…åœºâ€ æ‰¹å‘å†…å­˜ï¼š é›¶å”®æŒ‡é’ˆ æ•´åœºæ¸…é™¤ï¼š mmapæ¨¡å‹åŠ è½½æµç¨‹ï¼š æ ¸å¿ƒæ­¥éª¤ï¼š llama_model_loadre æ ¸å¿ƒå¯¹è±¡. ä¹‹ååŠ è½½æ¨¡å‹æ¶æ„arch\\è¶…å‚æ•°hparams\\è¯è¡¨vocab\\å…ƒæ•°æ®ä¿¡æ¯ã€ä»¥åŠå¼ é‡tensors","tags":[null]},{"title":"å¤§æ¨¡å‹å…¥é—¨","path":"/notebooks/other/å¤§æ¨¡å‹/å¤§æ¨¡å‹å…¥é—¨.html","content":"å¤§æ¨¡å‹åŸºç¡€æ¦‚å¿µå…¥é—¨Transformerè‡ªæ³¨æ„åŠ›ï¼ˆSelf-Attentionï¼‰Q\\K\\V Qï¼šç›®å‰å…³ç³»çš„é—®é¢˜ï¼Œå½“å‰token; K:tokençš„æ ‡ç­¾ V:åŒ…å«çš„ä¿¡æ¯ Q*Kå¾—åˆ°è°æ›´é‡è¦ï¼Œä¹‹åå†ä¹˜ä»¥Vå¾—åˆ°è¿™äº›é‡è¦çš„äººè¯´äº†ä»€ä¹ˆä¿¡æ¯ã€‚ é™¤ä»¥æ ¹å·dkä¸softmaxæ˜¯æ•°å­¦ç­–ç•¥ã€‚ å‰é¦ˆç½‘ç»œFFNç®€å•è€Œè¨€å°±æ˜¯å¢åŠ ç»´åº¦-å¢åŠ ä¿¡æ¯-é™ä½ç»´åº¦ã€‚-å¢åŠ éçº¿æ€§å˜åŒ–ã€‚ å±‚æ•°å½±å“é€å±‚æŠ½è±¡ã€‚æµ…å±‚å­¦ä¹ ä½çº§ç‰¹å¾ï¼ˆè¯æ€§ã€å±€éƒ¨è¯­æ³•ï¼‰ï¼Œæ·±å±‚æ•æ‰é«˜çº§è¯­ä¹‰ è¾“å…¥ç©ºé—´â€”Layer 1â€”è¯­æ³•ç©ºé—´â€”Layer 2â€”è¯­ä¹‰ç©ºé—´â€”â€¦â€”æ¨ç†ç©ºé—´ å•å±‚è¡¨ç¤ºï¼š Layer(x)LayerNorm(x+FFN(LayerNorm(x+Attention(x)))) å¤šå±‚å¤åˆï¼š Model(x)LayerN(LayerNâˆ’1(â€¦Layer1(x))) Prefill Decoder Prefillï¼ˆé¢„å¡«å……ï¼‰ï¼šå¤„ç†è¾“å…¥çš„æ‰€æœ‰å·²çŸ¥ tokensï¼Œè®¡ç®—å®ƒä»¬çš„éšè—çŠ¶æ€å¹¶å¡«å…… KV Cacheã€‚ Decoderï¼ˆè§£ç ï¼‰ï¼šåŸºäº KV Cache é€ä¸ªç”Ÿæˆæ–° tokenï¼Œç›´åˆ°ç»“æŸã€‚ 1.ä¸ºä»€ä¹ˆè¦æå‰è®¡ç®—æ‰€æœ‰çš„tokensï¼Ÿ 2.æ€ä¹ˆè®¡ç®—kvçš„ï¼Ÿ 3.ä»€ä¹ˆæ˜¯ token çš„éšè—çŠ¶æ€ 4.QKVæƒé‡çŸ©é˜µæ˜¯å¹²å˜›çš„ï¼Ÿ 5.ä»€ä¹ˆæ˜¯PDåˆ†ç¦» ä¼˜åŒ–ç­–ç•¥è®¡ç®—å›¾ä¼˜åŒ–ä¸ç®—å­èåˆ æŠ•æœºé‡‡æ · FlashAttention","tags":[null]}]