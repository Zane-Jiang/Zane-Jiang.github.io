[{"title":"OSDI'25 Tiered Memory Management Beyond Hotness","path":"/2025/07/08/论文阅读/OSDI-25-Tiered-Memory-Management-Beyond-Hotness/","content":"Tiered Memory Management Beyond Hotness Jinshu Liu Hamid Hadian Hanchen Xu Huaicheng Li Virginia Tech https://github.com/MoatLab/SoarAlto/ Virginia 这个MoatLab对CXL内存的研究很深入，之前的Pond(ASPLOS `23)、Melody（ASPLOS`25）都出自这个实验室 1.IntroductionHot data is not always performance-critical and can reside in the slow-tier without degrading performance . Latency mitigation techniques, such as memory-level parallelism (MLP), obscure the true cost of memory accesses 1.先前的工作通过启发式或者内存访问成本间接的反应MLP的影响，但是仍然缺少准确的MLP建模和指标。 2.现有的内存分层方法具有难以轻量化和不准确的特点。尤其是一开始先放置本地内存的方法本身就是次优的，并且激进的迁移策略会导致过分的迁移。 所以作者就定义了一个MLP影响的指标，AOL，并且用来辅助放置决策和迁移决策。 Propose Amortized Offcore Latency (AOL), a novel performance metric that accurately quantifies the performance impact of memory accesses by integrating memory latency and MLP. 放置决策策略SOAR基于AOL进行排序，然后以此决定放置。ALTO依靠AOL来进行页面提升的过滤，可以与TPP等策略进行结合。 2.Background and MotivationMLP反映等待内存控制器实现的内存请求数量。 high-MLP access patterns： array traversals。 low MLP：pointer-chasing with depedent requests 把两个类型的访存一起跑，然后不同的分层策略依照不同的策略跑了测性能，发现把数组访问的放到快速层，反而会使性能降低。 3.Memory Performance PredictionRelating Slow-tier Performance to CPU Stalls离线分析 Performance degradation on the slow-tier is predominantly caused by increased CPU stalls due to LLC misses, which we refer to as LLC-Stalls 强调区分LLC-miss和LLC-Stall 慢速层单次miss造成的延迟更长，假设相同的miss,慢速层也会有更长的LLS-Stall. 论文中讲到基于LLC-Stall来预测减速的误差低于4%，开源以后可以预测一下基于LLC-Miss的（考虑预取器的影响）。 LLC-Stalls for Performance Prediction在线预测 发现快速层发生CPUStall的在慢速层也会发生。 所以用P&#x3D; SLLC&#x2F;c来预测慢速层的减速。 AOL for Accurate Prediction进一步研究发现，P在低MLP的场景下准确，但是在高MLP的场景下并不准确、主要是忽略了MLP的影响，高MLP会减少长延迟的影响。 随着延迟的增加，MLP的延迟掩盖受益会降低。 因此定义了AOL： 指标 事件 含义 𝑠𝐿𝐿𝐶 CYCLE ACTIVITY.STALLS L3 MISS L3 Miss时导致的Stall c CPU_CLK_UNHALTED.THREAD 非Halt下的时钟周期数 A1 OFFCORE_REQUESTS_OUTSTANDING.CYCLES_WITH_DATA_RD L2 Miss 后、请求完成前，这些内存读取请求在 SQ 中等待的周期数换言之，每个时钟周期检查是否存在至少一个load请求，有就加1 A2 OFFCORE_REQUESTS_OUTSTANDING.DEMAND_DATA_RD L2 miss 后，每个周期有多少个未完成的 Demand Load 请求在SQ中等待，即：请求堆积的深度&#x2F;压力。 A3 OFFCORE REQUESTS.DEMAND DATA RD L2 miss 后，被发往 uncore 的 load 请求的次数。 延迟计算运用到了排队论中的Little`s法则:平均在系统中的项数 L = 到达率 λ × 平均响应时间 W 结合事件： L &#x3D; 某个时间段内，在 uncore 正在等待完成的请求数（单位：个），即 “每周期 outstanding 的请求数” λ &#x3D; 请求到达速率（单位：请求&#x2F;周期）≈ 总请求数 &#x2F; 总周期数 W &#x3D; 每个请求在系统中停留的时间（单位：周期）→ 平均延迟 W = L / λ = 平均 outstanding 请求数 / 到达速率 根据排队理论，计算得1。 MLP是平均每个周期内多少个inflight内存请求，衡量内存访问的并行度。 A2代表总的堆积请求数，总的堆积请求数（A2）除以总的堆积周期数（A1),得到每个周期的平均inflight请求数。 1、2代入的AOL。 延迟除以并行请求，得到了一个并行请求下单个请求的延迟影响。 然后作者定义了减速模型：S&#x3D; P x K. k &#x3D; f(AOL)的函数是用S&#x2F;P与AOL进行分析，反向呈现出特定的渐进双曲线，反推出了其数学模型。 关于a和b，与硬件相关而与工作负载无关的常数，两个特定的场景（指针追踪、数组访问）能够推出（估计待定系数法） 分析： AOL增加时（MLP减小或者Latency增大），K趋近到上界1，S接近P,预测由LLC.stall&#x2F;c决定。相反（MLP增大或者Latency减少），K趋近下界0，S减小 有了预测模型以后，基于时间序列预测了 4.Soar: Rank-based Static Object Allocation现有的初次放置的分层方案目的是最大化利用快速层内存。 作者希望寻找一种方法最初就能精准放置内存，降低内存迁移开销。 读到这句话的时候这难受。。 挑战： While AOL-based prediction is effective at the workload level, it falls short for individual objects due to the semantic gap between architectural events and object-level memory accesses. 尽管AOL预测在workload级别能够表现得很好，但是却无法在单个变量上表现很好。 key insight： ​\tdistribute CPU stalls across objects proportionally to their relative access frequencies based on the observed MLP and latencies, thereby approximating each object’s performance impact to application performance accurately. Object-Level Performance Profiling​\tPeriodically collects and processes three types of metrics: object metadata via object tracking memory accesses via PEBS-based LLC-miss sampling temporal performance via AOL-based prediction ①-②Object Tracking&#x2F;Flow 通过LD_PRELOAD的方式拦截修改，记录五元组对象流 ③-④用PEBS记录LLC misses、访问时间戳和vaddr ⑤-⑥基于AOL预测性能 ⑦ 合并三个对象流，基于时间戳来判断地址，有了访问时间戳，可以计算访问次数以及访问比例。 ⑧将访存比例与AOL减速预测结合，计算减速得分 具体计算算法： 极端场景下并行少，MLP&#x3D;1，减速打分等于时间段减速P*访存比例R 高MLP时，缩小评分 低MLP时，放大评分 作者随后解释了怎样设计的factor，以及计算单位字节得分等。 Object Allocation依然是打分之后进行排序，topk 放置到快速层 影响排名不一定与请求顺序相同，如果打分低的先到了，后续打分高的请求到了会使得打分低的请求降级。 问题：是依据调用栈来进行分组对变量进行标识的，这样在一个函数内部进行内存分配时，大家调用栈都相同，这样并无法区分。 具体要看代码实现是否区分时空调用？ 特别指出可以与一些异构内存感知的内存分配器同时使用（memkind、Unified Memory Framework) Use Cases and Limitations1.HPC、在线服务这种长时间访问的应用，静态分配不再最优 2.假设对象是均匀的，对象内部的访问每一页频率都差不多。 5.Alto: AOL-based Adaptive Page Migrations现在方案的不足： 1.某些迁移没有。只是表面热 2.迁移开销很大，策略到单次迁移需要12us,访问到迁移中的页导致CPU stall 3.CXL与local的延迟和带宽都在缩小，迁移开销的影响就显得很大 4.冷页不是真的冷。 虽然用 AOL（Amortized Offcore Latency）来设计基于性能感知的页迁移（page-level migration）策略是很有前景的，但目前仍面临一些独特的挑战，特别是在如何用现有粗粒度硬件性能计数器（performance counters）准确估算单个内存页的性能影响方面。 方法很简单，就是用AOL辅助平时的方法决策一下： 而后讲了与TPP、Nomad、NBT等方法的集成。 6.Evaluation 关注1：CXL模拟方式：SKX lowering the uncore frequency and disabling cores on one NUMA node 关注2：workloads : GAPBS、ML、caching、SPEC2017 执行过程中的排序 ALTO效果。 不足与机会：1.从MLP的角度分析，和预取有关系吗？对于预取的影响（如果这个东西能量化，也能分析出很多东西） 2.并没有考虑区分读写比例的影响？ 3.本文中第4节提到的通过访存比例来分配内存slowdown的做法是否合理？ 是因为其指标是基于perf stat的，如果全部用perf record的方法是否会更加精确？这一点作者没有详细描述。 hard 4.全部放在运行时进行变量分析会不会发生采样不准确的问题，在NeoMem中也有？但是如何解决？可不可以结合NeoMem完全捕获数据流？ 基于采样，长生命周期的可能采集到，短生命周期取样。 机器的拓展性，针对SPX，其他的SPR、EMR的对应事件的拓展性替代如何，是否都只是PEBS？ 乱序校正的影响大不大？ 例如三段式的，第一次进行热点代码识别，第二次将热点代码全部卸载到CXL，然后利用Neomem捕获trace，从而准确感知，最后根据决策实现数据放置？ hard 5.结合内存分配器进行小变量页内集中优化，大变量的访问是否集中？不集中的话可以用perf采集地址，然后绘制访存直方图。"},{"title":"CYY-RV64.zip","path":"/2025/07/07/论文阅读/CYY-RV64.zip/","content":"https://www.rv64.zip/ Background&amp;Motivation1.理想的RISC-V板子应当包含一组标准的指令拓展RVA23U64,但是目前的生态下，不同硬件支持的拓展与标准并不一致； 2.编译器和CPU没有针对新拓展进行优化的话，盲目打开新拓展反而会导致程序性能下降 Existing solution1.target_clones attributes 改代码，维护成本高 间接调用开销： When using target_clones or target_version, the compiler will use GNU IFUNC to dispatch the function call to the correct version at runtime. This introduces an overhead of an indirect function call, and also refuses some optimizations such as inlining. When compiling without -fno-plt or with -fno-pic, things will be worse since it requires 2 level call to the function (the first level is PLT call). 前置知识： PLT（Procedure Linkage Table) PLT 是动态链接（共享库）中用于实现 延迟绑定（Lazy Binding） 的核心结构，解决程序调用共享库函数时的跳转问题。 首次调用函数时： 程序跳转到 PLT 表中的对应条目（如 printf@plt）。 PLT 条目包含一条跳转指令，默认指向 动态链接器（_dl_runtime_resolve）。 动态链接器解析函数真实地址，并回填到 GOT（Global Offset Table）。 后续调用时： PLT 直接通过 GOT 跳转到真实函数地址（无需再次解析）。 -fno-plt 选项可绕过 PLT，直接通过 GOT 调用 IFUCN（Indirect Function） 运行时动态选择函数的具体实现,通过函数指针跳转，比直接调用多一次寻址，地址运行时确定，无法内联 定义时通过 __ attribute__((ifunc(&quot;resolver&quot;)))标记函数，提供一个解析器函数。 12345static void* my_func_resolver() &#123; if (__builtin_cpu_supports(&quot;avx2&quot;)) return &amp;my_func_avx2; else return &amp;my_func_default;&#125;void my_func() __attribute__((ifunc(&quot;my_func_resolver&quot;))); 最佳案例：GLib通过IFUNC为memcpy提供了多个实现。 Solution1.Decoupled function clone table​\t相当于将target_clones attributes从函数层提升到了文件层，不需要修改源代码。patch 2.Automatic function clone table generation​\t根据perf结果选择最佳的result 3.针对直接调用提了一些编译器端和CPU端的支持 更多方案期待CYY师兄的正式论文 Other1.英语表达读起来好舒服 2.类似的方案在box64之类的二进制翻译场景下也大有用处。"},{"title":"CPP杂记","path":"/2025/06/18/CPP/CPP杂记/","content":"全局静态变量、函数内静态变量、attribute((destructor))析构顺序构造析构顺序的不确定性 以及静态函数获取的单例。 C++ 标准规定：同一个编译单元（同一个 cpp 文件）内，静态&#x2F;全局对象的析构顺序与构造顺序相反。 但不同编译单元（不同 cpp 文件&#x2F;so）之间的析构顺序是未定义的。 局部 static（即函数内 static）对象的析构顺序与其定义顺序有关，但也只在同一编译单元内有保证。 若一个变量仅在单个文件中可见，则建议将这个变量声明为静态全局变量，static修饰的静态全局变量仅在当前文件中可见。 如果一个全局变量只被单个函数使用,将其改为该函数的静态局部变量可以进一步限制变量的作用域,提高代码的内聚性,降低耦合度。静态局部变量具有全局寿命但局部作用域的特点, 静态全局变量是存储在**静态数据区的,**而不是栈区,因此静态全局变量的大小不会导致栈溢出。栈溢出通常是由于函数调用层次过深或局部变量过大导致的。 类的内存占用 1.32位系统中虚函数指针为4字节，64位为8字节 2.只需要考虑虚函数指针，虚函数表不计入某个类的资源 3.char占一字节，但是需要考虑内存调用 4.如果有虚继承，则多一个虚基类指针。 5.空类占一个字节（用于标识） 指针好题 int arr[5]&#x3D;{1,2,3,4,5};在这个数组的定义中，通常的理解arr是数组的地址即数组首元素的地址，进一步理解arr是一个int型的指针常量，常量+1地址偏移sizeof(int)，所以arr+1是首元素下一个元素的地址；考虑到这一层就不难理解**&amp;arr*的含义，&amp;arr是对arr取地址，结果也是个地址，只是这个地址的类型是指向有5个int类型数据的数组的指针常量，这个常量+1地址偏移5sizeof(int)。 各级指针算各级的： 主要就是理解&amp; 和 * 的“升级降级”； 链接：https://www.nowcoder.com/exam/test/89156461/submission?examPageSource=Intelligent&pid=62380309&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fintelligent%3FquestionJobId%3D10%26subTabName%3Dintelligent_page%26tagId%3D21000&amp;testclass&#x3D;%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91 Copy and Swap传统做法operator= 12345678910111213141516171819202122class MyString &#123;private: char* data; // 动态分配的字符串public: // 赋值运算符重载 MyString&amp; operator=(const MyString&amp; other) &#123; // 检查自赋值 if (this == &amp;other) &#123; return *this; &#125; // 释放当前对象的资源 delete[] data; // 复制数据 data = new char[std::strlen(other.data) + 1]; std::strcpy(data, other.data); // 返回当前对象的引用 return *this; &#125;&#125;; Copy and Swap 123456789MyString&amp; operator=(const MyString&amp; other) &#123; // 检查自赋值 if (this == &amp;other) &#123; return *this; &#125; MyString tmp&#123;other&#125;; std::swap(data,other.data); return *this;&#125; 优势： 异常安全：传统方法new抛出异常时，对象出于无效状态。data已经被删除，但是分配失败 强异常安全性: 如果一个操作因为异常而失败，程序的状态会回滚到操作之前的样子，就像这个操作从来没执行过一样 代码复用：复用拷贝构造函数 自动资源管理：自动释放tmp资源 C++11 写法 123456MyString&amp; operator=(MyString other) &#123;//值传递 //传入左值：拷贝构造 //传入右值：移动构造 std::swap(data,other.data); return *this; &#125; 移动构造还是拷贝构造？ 左值：叫得出名字 右值：叫不出名字（临时变量，std::move） 左值用拷贝构造，右值用移动构造（偷）"},{"title":"CXL-place-llvm-PGO杂记","path":"/2025/04/23/备忘录/CXL-place-llvm-PGO杂记/","content":"CXL-place-llvm-PGO杂记 记录完成llvmPGO 中的一些知识杂记 1.llvm中的malloc重定向拦截案例：2.复制构造、移动构造、原地构造3.内存分配器的实现https://blog.lfalive.top/2022/02/15/JeMalloc/ http://hydra.azilian.net/Papers/jemalloc.pdf"},{"title":"LLVM explore","path":"/2025/04/23/LLVM/LLVM/","content":"入门llvm笔记 新旧新增pass流程CRTP（奇异递归模板模式）(以下内容基于AI生成后修改) 通常通过继承的方式实现单例模式也是这样，只是不知道叫这个名字 CRTP（Curiously Recurring Template Pattern，奇异递归模板模式）是C++中的一种高级模板编程技术，通过让一个类继承自以自身为模板参数的基类模板，实现静态多态或代码复用。 123template &lt;typename Derived&gt;class Base &#123; /* 基类使用Derived类型 */ &#125;;class MyClass : public Base&lt;MyClass&gt; &#123; /* 派生类将自身作为模板参数传递给基类 */ &#125;; 核心作用1. 静态多态（编译时多态） 动态多态（虚函数）的问题：运行时虚表查找导致性能开销。 CRTP的解决方案：基类在编译时通过模板参数直接调用派生类的方法。 123456789101112131415161718192021template &lt;typename Derived&gt;class Animal &#123;public: void speak() &#123; static_cast&lt;Derived*&gt;(this)-&gt;speakImpl(); // 编译时确定调用 &#125;&#125;;class Cat : public Animal&lt;Cat&gt; &#123;public: void speakImpl() &#123; std::cout &lt;&lt; &quot;Meow &quot;; &#125;&#125;;class Dog : public Animal&lt;Dog&gt; &#123;public: void speakImpl() &#123; std::cout &lt;&lt; &quot;Woof &quot;; &#125;&#125;;// 使用Animal&lt;Cat&gt; cat;cat.speak(); // 输出 &quot;Meow&quot;（无虚函数开销） 2. 代码复用 基类可提供通用逻辑，派生类通过特化实现差异部分。 123456789101112131415161718192021template &lt;typename Derived&gt;class Counter &#123;protected: static int count;public: Counter() &#123; ++count; &#125; static int getCount() &#123; return count; &#125;&#125;;template &lt;typename Derived&gt;int Counter&lt;Derived&gt;::count = 0;// 统计对象实例数的类class Widget : public Counter&lt;Widget&gt; &#123;&#125;;class Gadget : public Counter&lt;Gadget&gt; &#123;&#125;;// 使用Widget w1, w2;Gadget g1;std::cout &lt;&lt; Widget::getCount(); // 输出 2std::cout &lt;&lt; Gadget::getCount(); // 输出 1 CRTP vs 虚函数 特性 CRTP 虚函数 多态时机 编译时 运行时 性能 无额外开销（直接调用） 虚表查找开销 灵活性 类型固定（模板参数需明确） 支持运行时类型动态替换 适用场景 高性能库、框架基础设施 需要运行时动态行为的情况 CRTP的典型应用场景 编译时多态：如数学库中的向量&#x2F;矩阵运算（Eigen库）。 对象计数：统计不同派生类的实例数量。 Mixin模式：为类动态添加功能（如LLVM的PassInfoMixin）。 链式调用：返回派生类引用以实现链式语法（return static_cast&lt;Derived&amp;&gt;(*this);）。 4 LLVM与CPP实现DenseMap与stdMapdyn_cast与RTTI isadef-use user-value为什么llvm中User会继承value 处理器硬件计数pt LBR PEBS"},{"title":"龙蜥CXL讲解-高显扬","path":"/2025/01/06/CXL/龙蜥CXL讲解-高显扬/","content":"CXL技术介绍对视频链接的PPT搬运，方便快速阅读 高显杨 浪潮 综述 协议协议演进 1.1内存拓展 2.0内存赤化 3.0特性 CXL子协议 CXL设备 CXL Fabric 参考VPN，下边两张为单switch CXL RAS特性 内存热插拔？如何避免宕机 CXL初始化 RCRB CXL 1.1跑CXL2实现协议兼容 CXL方案 池化管理：FM中的bind和UnBind 业界方案 补充"},{"title":"OCP China 2024 CXL 论坛学习笔记","path":"/2025/01/06/CXL/OCP-China-2024-CXL-论坛学习笔记/","content":"OCP China 2024 CXL论坛 学习笔记会议链接 阿里云 数据中心高性能Scale Up 互联系统趋势 孔阳 阿里云超高速互联负责人 胡文普 CXL部分 Scale Up 云的角度 关注两个计算 ： 通用计算、GPU计算 通用计算上： 考虑弹性分析：存储上-&gt;云盘技术 网络-&gt;CIPU网络虚拟化 内存上-&gt;CXL GPU上：大模型单次任务，数据并行、流水线并行、tensor并行、专家并行，都具有较高的带宽要求 CXL 机柜内的资源弹性实现需要满足高性能接口、资源共享、极致弹性、软件生态兼容性等要求。CXL特性符合这些要求。CXL将一致性访问从CPU内部拓展到CPU和内存之间，实现多服务器之间的互联。 CXL的演进 GIM ： P2P ： DSP与type3互联，type3可以分配给DSP或者host HBR-&gt;PBR:不止树状、星状、网络状 E3.s 热插拔，便于可拓展 JBOM 大容量 PEMEM ：支持2.0，满足redis实时性持久化等要求 基于 内存与CPU实现资源解耦 CXL在小数据上传输性能大大提高； intel: CXL on Intel Xeon@ Platform 赵森林 CXL overview CXL Specification Summary"},{"title":"Kernel-compile","path":"/2024/12/05/Linux kernel/Kernel-compile/","content":"内核编译123456789101112131415161718192021222324252627282930#查看当前内核版本uname -a#源码获取sudo apt-get install linux-sourcecd /usr/srctar xvf linux-source-*.tar.bz2cd linux-source-*#补丁应用patch -p1 &lt; /path/to/patch.diff#`-p1`选项可能需要根据补丁文件的格式进行调整。make menuconfig #或者oldconfig,本质是配置/usr/src/configmake -j$(nproc)#根据 .config 配置文件编译内核、内核模块和其他必要的文件，生成内核镜像（vmlinuz）和其他相关的文件#编译过程中可能出现每包头文件或者其他错误，可能是版本原因，针对报错解决即可#内核安装#安装过程可能会出现头文件报错或者缺库、或安装完成后缺库，只需要apt安装对应的库就好，make过程中会自动hook#安装内核模块(在运行时可以加载或卸载的模块)#从编译输出的目录（如 lib/modules/&lt;kernel_version&gt;/）,并执行 depmod 来生成模块依赖关系sudo make modules_install#内核镜像（如 vmlinuz）、配置文件（如 config）、符号表文件（如 System.map）和 initrd 镜像安装到 /boot 目录sudo make install#更新启动引导程序sudo update-grup 关于配置选项相关操作，参考：:star::star:Linux 内核动手编译实用指南 KGDB配置编译选项 参考资料KGDB原理分析及远程挂载调试ARM64内核 内核启动参数 1kgdboc=ttyS0,115200 kgdbwait kgdbtcp=192.168.1.2:1234 kgdboc=ttyS0,115200：设置串口调试（可选） kgdbwait：启动时等待调试器连接 kgdbtcp=192.168.1.2:1234：被调试主机的IP和端口 永久修改：/etc/default/grub下GRUB_CMDLINE_LINUX变量 proxmox-boot-toolproxmox-boot-tool，一个脚本，设置启动内核、增删内核等 Proxmox VE（Proxmox Virtual Environment）是一个开源的虚拟化管理平台，专为企业级环境设计，能够管理虚拟机（VM）、容器、存储和集群。 其中 proxmox-boot-tool脚本在内核管理切换过程中比较有用，这里做备份，便于不整体下载Proxmox VE而单独使用此工具，仅供个人学习使用 使用前提是需要先下载Promox VE 先换源/etc/apt/sources.list.d/pve-no-subscription.list 12deb http://mirrors.ustc.edu.cn/proxmox/debian/pve bookworm pve-no-subscriptiondeb http://mirrors.tuna.tsinghua.edu.cn/proxmox/debian/pve bookworm pve-no-subscription 记得把&#x2F;etc&#x2F;apt&#x2F;sources.list.d下原有的源注释掉 kernel add等 在 &#x2F;boot下边找到对应版本号 之后可通过apt search \\install 搜索下载对应的pve版本内核 proxmox-boot-tool下载链接,先下载proxmox-kernel-helper 参考链接： https://kernelnewbies.org/KernelBuild"},{"title":"Hexo","path":"/2024/11/28/Hexo/hexo/","content":"Hexo部署过程中遇到的一些问题图片与Typora兼容网上给了很多方法，尝试没有效果，自己尝试的方案： 卸载插件hexo-asset-image: yarn remove hexo-asset-image,GitHub有修改的对应插件，但是使用无效果 typora配置 Typora新插入图片路径显示为： Hexo部署时正常显示 Hexo不生效问题Hexo部署到github上不生效，网上解决方案说需要除Main或者Master分支以外额外构建一个分支，然后网站推送到这个分支上，实际使用不管用。 首先，只需要维护一个主分支，不需要其他分支； 其次，hexo -d执行以后，main分支中即使已经更新了代码，但是github page更新也需要一段时间，部署频繁会产生排队 仓库主页github-pages上可以观察到生成静态页面的进度。"},{"title":"Neoperf_study","path":"/2024/11/28/Linux kernel/Neoperf-study/","content":"NeoPerf study 本文主要为学习论文《NeoMem: Hardware&#x2F;Software Co-Design for CXL-Native Memory Tiering》的工作，分为三个部分，用户态、内核以及FPGA部分，内核开源仓库地址为： PKUZHOU&#x2F;linux 代码基于linux内核代码6.0开始修改。 由于初步探索linux内核代码，所以没有按照自顶向下的视角分析代码，而是基于git提交记录，借助AI与互联网搜索，平铺遇到的相关知识。版本不断更新…… a naive neoprof drivercommit ID 9bd35383 本次主要在driver目录下提交了一个驱动neoperf: 主要是实现了一些对外设的IO操作 Linux内核配置文件KconfigKconfig文件用于定义内核配置菜单，这些菜单可以在编译内核时启用或禁用特定的功能。 1234#Kconfig文件config NEOPROF#定义了一个名为`NEOPROF`的内核配置选项，将在内核配置菜单中创建选项\tbool &quot;Enable Neoprofiler&quot; #bool类型，是否启用 default n #默认不启用 在内核编译过程中可以在Drivers下查找到 Kconfig有其独特的语法，也是可以一层一层包裹下去：menu、source、endmenu等组成了编译选项配置过程中的树状菜单 Kconfig设置对应的编译变量后，makefile指导构建编译的过程中会利用这些变量，从而实现选择性的编译 neoperf.h主要新增了四个接口，对neoprof设备（此处指Type2-CXL设备）进行访问： 1234567891011/* * The following functions are used to access the neoprof device*/u64 get_nr_hotpages(void);//获取当前系统中的热页数量u64* get_hotpages(void);//获取热页u64 get_hotness_threshold(void);//获取热度阈值void set_hotness_threshold(u64 threshold);//设置热度阈值 neoperf.c驱动开发hello worldneoperf.c 以下部分参考驱动开发知识：https://www.cnblogs.com/downey-blog/p/10500828.html 123456module_init(neoprof_init);module_exit(neoprof_exit);MODULE_LICENSE(&quot;GPL v2&quot;);MODULE_AUTHOR(&quot;PKUZHOU&quot;);MODULE_DESCRIPTION(&quot;Neoprofiler Linux driver&quot;); io地址映射相关知识需要理解 IO端口的编址方式： 包括IO指令的端口映射方式、MMIO的统一内存映射方式 一些常见的IO操作函数 12void * ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags); //memset_io\\memcpy_fromio\\readb 参考：https://blog.csdn.net/do2jiang/article/details/5450839 neomem migration skeletoncommit ID 26cabad18 新增 NeoMem模块: migrate.c主要是提供接口migrate_misplaced_page_no_vma 调用一些mm中的内存操作函数，进行页面隔离、迁移 neomem.h eomem.c主要就是启动 neomem模块（调用core文件中启动守护进程） late_initcall()在内核启动后期适当时间执行，理解module_init等init宏的顺序，在include/linux/init.h中 linux设备驱动加载的先后顺序 neomem_core.c 内存中的各种分配函数 kthread_run内核线程 FPGA端侧模块结构顶层模块： cxltyp3_memexp_ddr4_top-&gt;ed_top_wrapper_typ3 ddr内存参数调整cxl ip考虑了不同ddr的，包括是否支持DBI、内存通道数量等。采用宏的方式区分，设置不同的方式时，需要对ip内通过宏定义来确定相关的内存参数，同时也需要在顶层模块对相关参数进行修改。 .tdzhnxzibgin{zoom:50%;} .jqpdpwecqorg{zoom:50%;} .qdoolikeixpu{zoom:50%;} 或者通过更改ip文件，重新生成新的IP文件夹 .asfymrugzpwg{zoom:50%;} quartus1set_global_assignment -name OPTIMIZATION_MODE &quot;AGGRESSIVE COMPILE TIME&quot; 烧录模式AS Jtag ps 三种烧录模式 Neomem todo代码存在一些可以完善的地方： CXL地址采用硬编码，可以引入设备树或者其他检测CXL物理地址的工具进行优化，参考"},{"title":"linux脚本备忘录","path":"/2024/11/26/备忘录/linux脚本备忘录/","content":"Linux脚本备忘录安装系统后的环境准备添加新用户 123456adduser #封装命令，处理完添加用户的全部过程 su到新用户显示username@hostname~$:useradd #底层命令，什么都没有加,su到新用户显示$:# 生成 8 位强密码PASSWORD=$(openssl rand -base64 6 | cut -c1-8)echo &quot;Password: $PASSWORD&quot; 用户添加sudo组 1234567usermod -aG sudo new_user#加完以后记得:newgrp sudo#作用有3：#1.切换到指定的组上下文#2.即时生效组更改#3.启动一个子 shell 配置sshd12345678#服务端安装apt install ssh-server#配置sudo vim /etc/ssh/sshd_config#重启服务sudo service restart sshd VimVim配置推荐 - ma6174 12wget 47.93.11.51:88/install_vim.shbash install_vim.sh zsh1234567891011121314#安装zshsudo apt install zsh#修改默认shell为zshchsh -s /bin/zsh#安装oh-my-zshsh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;##如果不成功，请执行下面两条命令，成功了就不需要做下面两条wget 47.93.11.51:88/install_zsh.shbash install_zsh.sh#安装zsh-syntax-highlightinggit clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 历史记录推荐命令插件12##命令自动推荐，根据历史记录git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 命令自动补全12345##命令自动补全插件mkdir ~/.oh-my-zsh/plugins/incrwget http://mimosa-pudica.net/src/incr-0.2.zsh -O ~/.oh-my-zsh/plugins/incr/incr.plugin.zsh##目录自动跳转插件sudo apt install autojump .zshrc配置文件配置12#插件添加zsh-syntax-highlightingplugins=(git zsh-syntax-highlighting) 123456789#设置终端颜色，提示符，及上一条指令返回码提示autoload -U colors &amp;&amp; colorsPROMPT=&quot;%&#123;$fg[red]%&#125;%n%&#123;$reset_color%&#125;@%&#123;$fg[blue]%&#125;%m %&#123;$fg[yellow]%&#125;%1~ %&#123;$reset_color%&#125;%# &quot;RPROMPT=&quot;[%&#123;$fg[yellow]%&#125;%?%&#123;$reset_color%&#125;]&quot;# Useful support for interacting with Terminal.app or other terminal programs[ -r &quot;/etc/zshrc_$TERM_PROGRAM&quot; ] &amp;&amp; . &quot;/etc/zshrc_$TERM_PROGRAM&quot;source ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions/zsh-autosuggestions.plugin.zshsource /usr/share/autojump/autojump.shsource ~/.oh-my-zsh/plugins/incr/incr*.zsh ctags12345#安装sudo apt install ctags #建立索引ctags -I __THROW -I __attribute_pure__ -I __nonnull -I __attribute__ --file-scope=yes --langmap=c:+.h --languages=c,c++ --links=yes --c-kinds=+p --c++-kinds=+p --fields=+iaS --extra=+q -f ~/.vim/systags /usr/include/* /usr/include/x86_64-linux-gnu/sys/* /usr/include/x86_64-linux-gnu/bits/* /usr/include/arpa/* .vimrc添加索引 1set tags+=~/systags 安装glibc-doc 使用以下命令安装 1sudo apt install glibc-doc 常见路径hostname :/etc/hostname host: /ect/hosts tomcat1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#安装JDK8sudo apt install default-jre -ysudo apt install openjdk-11-jre-headless -ysudo apt install openjdk-8-jre-headless -y #sudo wget https://downloads.apache.org/tomcat/tomcat-8/v8.5.65/bin/apache-tomcat-8.5.65.tar.gzsudo wget https://mirrors.bfsu.edu.cn/apache/tomcat/tomcat-8/v8.5.73/bin/apache-tomcat-8.5.73.tar.gztar zxf apache-tomcat-8.5.73.tar.gzsudo mv apache-tomcat-8.5.73 /usr/local/tomcat#建立软连接sudo ln -s /usr/local/tomcat/bin/* /usr/local/sbin/#启动startup.sh start #端口检查netstat -anput | grep 8080#启动命令startup.sh start #//启动shutdown.sh #//关闭catalina.sh stop #//启动catalina.sh start #//关闭#关闭防火墙sudo ufw disable #tomcat 参数配置vim /usr/local/tomcat/conf/server.xml #.......&lt;Connector port=&quot;8081&quot; protocol=&quot;HTTP/1.1&quot; #将之前8080端口改成8081端口connectionTimeout=&quot;20000&quot; # redirectPort=&quot;8443&quot; /&gt;#目录修 # &lt;Host name=&quot;localhost&quot; appBase=&quot;/opt/www&quot; #将网站根目录改到/opt/www # unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt;#更改网站家目录，这里的ROOT必须大写，更改完成后需要重启sudo mkdir /opt/www/ROOT -p mysqlmysql 8.0下载 1wget https://repo.mysql.com//mysql-apt-config_0.8.20-1_all.deb 12345678#MySQL 设置#密码sudo mysql -uroot use mysql;update user set authentication_string=PASSWORD(&quot;自定义密码&quot;) where User=&quot;root&quot;;update user set plugin=&quot;mysql_native_password&quot; where User =&quot;root&quot;;flush privileges;quit; 对于Linux和windows下字符集不兼容的情况，需要替换 • 把文件中的所有的utf8mb4_0900_ai_ci替换为utf8_general_ci• 以及utf8mb4替换为utf8• 如上图所示的位置，上图只是一部分，注意全部替换。 数据库导出 1mysqldump -uroot -p &gt;c:ShareYunAlbum。sql 数据库导入 12use ShareYunAlbum source ~/ShqreYunAlbum.sql 卸载mysql 123456sudo apt purge mysql-* -ysudo rm -rf /etc/mysql/ /var/lib/mysqlsudo apt autoremovesudo apt autorecleansudo apt-get remove mysql-common dpkg -l |grep ^rc|awk &#x27;&#123;print $2&#125;&#x27; |sudo xargs dpkg -P"},{"title":"控台项目与iSet项目已使用Qt技能点整理","path":"/2024/10/15/Qt/技能点整理/","content":"Qt与QML知识总结Qt中的设计模式中间滑动的slider 2. doubleSpinBox3. iSet新建项目的两种模式ListWidget、选中状态设置为图标模式4.QTreeWidget 框架、表头、样式表、代理 Qt QTreeWidget树形控件用法详解_qtreewidget用法_睿科知识云的博客-CSDN博客 2. Qt大模块1. Qt DP指针2. 视图模型机制3. 视图框架4. QStyle 高度自定义实现5. 元对象与信号槽机制6.构建系统7.QInvokeMethod8.国际化3. Qt细节1. 基础控件2. Undo操作3. svg操作4. Qt不在对象树的工具汇总5.Qt中有有用的宏：Q_LIKELY 6.paint在install中绘制 4. Qt锦上添花1. 动画知识2. 拖拽3. 插件机制4.模块化构建5. Qt中的设计模式1. 单例模式2. 责任链模式3. 接口模式4. 适配器模式5.观察者模式， 线程观察、时间压缩 6.全局信号单例转发类 12345678MAINOPERATIONVIEW_EXPORT bool MainOperationView_Init(IISetWidget ** ppWidget, QWidget * parent)&#123; if (ppWidget == nullptr || parent == nullptr) return false; *ppWidget = new CMainOperationView(parent); return true;&#125; 6. C++知识c++11新特性，所有知识点都在这了！ - 知乎 (zhihu.com) this_thread ++ lambda的坑 12345for(int id = enCoef9_Rr ; id &lt;= enCoef9_Bb ;id++)&#123; connect(m_spinBoxs[id],QOverload&lt;double&gt;::of(&amp;QDoubleSpinBox::valueChanged),this,[&amp;](double value)&#123; OnCoefMatrixSlot(id,value); &#125;);&#125; id 恒等于 0 多继承与QOBject private 虚继承 123456789101112131415161718192021class CBase&#123;private:\tvirtual void virtualPrivateFuntion()&#123; std::cout&lt;&lt;&quot;base virtualPrivateFuntion&quot;;\t&#125;&#125;；class CSub :public CBase&#123;\tprivate:\tvirtual void virtualPrivateFuntion() override&#123; std::cout&lt;&lt;&quot;sub virtualPrivateFuntion&quot;;\t&#125;&#125;int main()&#123;\tCBase* pObject = new CSub();\tpObject-&gt;virtualPrivateFuntion();&#125;//结果：sub virtualPrivateFuntion，//结论：子类继承父类的private virtual可以重写 可变参数、变参模板 函数包装器 std::shared_ptrreset、make_shared 右值引用C++反射元编程Metaprogram is a program about a program. 7.杂项QStatusBar插件机制解耦快捷键ISet7.0 接口设计 MVC8.轮子1.单例2.工作线程封装3.stl 迭代器模式和适配器模式报错整理： QMenu 没有添加Action时，不能直接visible或这exec； setGeometry: Unable to set geometry 的一种解决办法是重写sizehint，而不是使用setFixedSize； 工具使用AddressSanitizer（不适用与MinGW）[AddressSanitizer 定位嵌入式c&#x2F;c++内存错误 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/436177229#:~:text=AddressSanitizer （又名 ASan）是 C%2FC%2B%2B 的内存错误检测器。 AddressSanitizer 由 google,的一部分，而从 4.8 版开始逐渐成为 GCC 的一部分。 这也意味着如果交叉编译器版本低于 4.8 ，是无法使用的。) Qt 拾遗 008 在 Qt 中使用 Address Sanitizer - 简书 (jianshu.com) 在Qt中使用gcc 4.8.0的地址消毒剂(Address Sanitizer) MTuner软件【精选】基于MTuner软件进行qt的mingw编译程序的内存泄漏检测_mtuner怎么使用_yantuguiguziPGJ的博客-CSDN博客"}]