---
title: CUDA入门
tags: [CUDA]
categories: [CUDA]
poster:
  topic: CUDA入门
  headline: CUDA入门
  caption: 
  color: 
comments: true
indexing: true
breadcrumb: true
type: tech
date: 2025-09-06 19:57:10
description:
cover:
banner:
references:
    - '[CUDA算子手撕与面试](https://zhuanlan.zhihu.com/p/12661298743)'
---





## hello world

```cpp
#include<iostream>
#include<cuda_runtime.h>
 __constant__ char d_message[20];

//核函数
__global__ void welcome(char *msg){
    int idx = blockIdx.x*blockDim.x+threadIdx.x;
    msg[idx] = d_message[idx];
}

int main(){
    char* d_msg;
    char* h_msg;
    const char message[] = "Welcom to LeetGPU!";

    //分配内存    
    const int length = strlen(message)+1; 
    h_msg = (char*)malloc(length*sizeof(char));
    cudaMalloc(&d_msg,length*sizeof(char));
    //拷贝内存
    cudaMemcpyToSymbol(d_message,message,length);

    welcome<<<1,length>>>(d_msg);

    cudaMemcpy(h_msg,d_msg,length*sizeof(char),cudaMemcpyDeviceToHost);

    h_msg[length -1] = '\0';

    std::cout<<h_msg<<std::endl;

    free(h_msg);
    cudaFree(d_msg);
    return 0;
}
```





## size确定

简单考虑：

每个block中的线程数取128,256 block_size

之后对应的grid_size用总线程数上取整block_size

```C++
#define CEIL(a,b) (a+b-1)/b
dim3 block_size(256);
dim3 grid_size（CEIL(N,block_size.x));
```

[更多考虑]([[CUDA 学习笔记\] CUDA kernel 的 grid_size 和 block_size 选择_下列哪些是核函数的执行配置-CSDN博客](https://blog.csdn.net/LostUnravel/article/details/135721041))



## 共享内存

同一个线程块内的所有线程可见，块之间不可见。

由硬件划分成多个 **bank**，并行访问时要避免 bank 冲突。



静态

```c++
__global__ void kernel(float *input, float *output) {
    // 静态分配共享内存
    __shared__ float buffer[256];

    int tid = threadIdx.x;
    buffer[tid] = input[tid];
    __syncthreads();  // 同步，确保数据写入完成

    // 示例：每个线程将前一个线程的数据加到自己上
    if (tid > 0)
        buffer[tid] += buffer[tid - 1];
    __syncthreads();

    output[tid] = buffer[tid];
}
```

动态

```c++
__global__ void kernel_dynamic(float *input, float *output) {
    extern __shared__ float buffer[]; // 动态共享内存
    int tid = threadIdx.x;
    buffer[tid] = input[tid];
    __syncthreads();

    output[tid] = buffer[tid] * 2;
}

int size = 256 * sizeof(float);
kernel_dynamic<<<1, 256, size>>>(input, output);
```

